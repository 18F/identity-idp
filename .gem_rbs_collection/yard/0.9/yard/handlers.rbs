# !!! GENERATED FILE !!!
# Please see yard/0.9/_generators/README.md

# Handlers are called during the data processing part of YARD's
# parsing phase. This allows YARD as well as any custom extension to
# analyze source and generate {CodeObjects} to be stored for later use.
module YARD::Handlers
end

# Handlers are pluggable semantic parsers for YARD's code generation
# phase. They allow developers to control what information gets
# generated by YARD, giving them the ability to, for instance, document
# any Ruby DSLs that a customized framework may use. A good example
# of this would be the ability to document and generate meta data for
# the 'describe' declaration of the RSpec testing framework by simply
# adding a handler for such a keyword. Similarly, any Ruby API that
# takes advantage of class level declarations could add these to the
# documentation in a very explicit format by treating them as first-
# class objects in any outputted documentation.
#
# == Overview of a Typical Handler Scenario
#
# Generally, a handler class will declare a set of statements which
# it will handle using the {handles} class declaration. It will then
# implement the {#process} method to do the work. The processing would
# usually involve the manipulation of the {#namespace}, {#owner}
# {CodeObjects::Base code objects} or the creation of new ones, in
# which case they should be registered by {#register}, a method that
# sets some basic attributes for the new objects.
#
# Handlers are usually simple and take up to a page of code to process
# and register a new object or add new attributes to the current +namespace+.
#
# == Setting up a Handler for Use
#
# A Handler is automatically registered when it is subclassed from the
# base class. The only other thing that needs to be done is to specify
# which statement the handler will process. This is done with the +handles+
# declaration, taking either a {Parser::Ruby::Legacy::RubyToken}, {String} or `Regexp`.
# Here is a simple example which processes module statements.
#
#   class MyModuleHandler < YARD::Handlers::Base
#     handles TkMODULE
#
#     def process
#       # do something
#     end
#   end
#
# == Processing Handler Data
#
# The goal of a specific handler is really up to the developer, and as
# such there is no real guideline on how to process the data. However,
# it is important to know where the data is coming from to be able to use
# it.
#
# === +statement+ Attribute
#
# The +statement+ attribute pertains to the {Parser::Ruby::Legacy::Statement} object
# containing a set of tokens parsed in by the parser. This is the main set
# of data to be analyzed and processed. The comments attached to the statement
# can be accessed by the {Parser::Ruby::Legacy::Statement#comments} method, but generally
# the data to be processed will live in the +tokens+ attribute. This list
# can be converted to a +String+ using +#to_s+ to parse the data with
# regular expressions (or other text processing mechanisms), if needed.
#
# === +namespace+ Attribute
#
# The +namespace+ attribute is a {CodeObjects::NamespaceObject namespace object}
# which represents the current namespace that the parser is in. For instance:
#
#   module SomeModule
#     class MyClass
#       def mymethod; end
#     end
#   end
#
# If a handler was to parse the 'class MyClass' statement, it would
# be necessary to know that it belonged inside the SomeModule module.
# This is the value that +namespace+ would return when processing such
# a statement. If the class was then entered and another handler was
# called on the method, the +namespace+ would be set to the 'MyClass'
# code object.
#
# === +owner+ Attribute
#
# The +owner+ attribute is similar to the +namespace+ attribute in that
# it also follows the scope of the code during parsing. However, a namespace
# object is loosely defined as a module or class and YARD has the ability
# to parse beyond module and class blocks (inside methods, for instance),
# so the +owner+ attribute would not be limited to modules and classes.
#
# To put this into context, the example from above will be used. If a method
# handler was added to the mix and decided to parse inside the method body,
# the +owner+ would be set to the method object but the namespace would remain
# set to the class. This would allow the developer to process any method
# definitions set inside a method (def x; def y; 2 end end) by adding them
# to the correct namespace (the class, not the method).
#
# In summary, the distinction between +namespace+ and +owner+ can be thought
# of as the difference between first-class Ruby objects (namespaces) and
# second-class Ruby objects (methods).
#
# === +visibility+ and +scope+ Attributes
#
# Mainly needed for parsing methods, the +visibility+ and +scope+ attributes
# refer to the public/protected/private and class/instance values (respectively)
# of the current parsing position.
#
# == Parsing Blocks in Statements
#
# In addition to parsing a statement and creating new objects, some
# handlers may wish to continue parsing the code inside the statement's
# block (if there is one). In this context, a block means the inside
# of any statement, be it class definition, module definition, if
# statement or classic 'Ruby block'.
#
# For example, a class statement would be "class MyClass" and the block
# would be a list of statements including the method definitions inside
# the class. For a class handler, the programmer would execute the
# {#parse_block} method to continue parsing code inside the block, with
# the +namespace+ now pointing to the class object the handler created.
#
# YARD has the ability to continue into any block: class, module, method,
# even if statements. For this reason, the block parsing method must be
# invoked explicitly out of efficiency sake.
#
# @abstract Subclass this class to provide a handler for YARD to use
#   during the processing phase.
#
# @see CodeObjects::Base
# @see CodeObjects::NamespaceObject
# @see handles
# @see #namespace
# @see #owner
# @see #register
# @see #parse_block
class YARD::Handlers::Base
  # @return [Processor] the processor object that manages all global state
  #   during handling.
  attr_reader parser: YARD::Handlers::Processor
  # @return [Object] the statement object currently being processed. Usually
  #   refers to one semantic language statement, though the strict definition
  #   depends on the parser used.
  attr_reader statement: untyped
  # Returns the value of attribute owner.
  attr_accessor owner: untyped
  # Returns the value of attribute namespace.
  attr_accessor namespace: untyped
  # Returns the value of attribute visibility.
  attr_accessor visibility: untyped
  # Returns the value of attribute scope.
  attr_accessor scope: untyped
  # Returns the value of attribute globals.
  attr_reader globals: untyped
  # Returns the value of attribute extra_state.
  attr_reader extra_state: untyped
  # Clear all registered subclasses. Testing purposes only
  # @return [void]
  def self.clear_subclasses: () -> void
  # Returns all registered handler subclasses.
  # @return [Array<Base>] a list of handlers
  def self.subclasses: () -> Array[YARD::Parser::Base]
  def self.inherited: (untyped subclass) -> untyped
  # Declares the statement type which will be processed
  # by this handler.
  #
  # A match need not be unique to a handler. Multiple
  # handlers can process the same statement. However,
  # in this case, care should be taken to make sure that
  # {#parse_block} would only be executed by one of
  # the handlers, otherwise the same code will be parsed
  # multiple times and slow YARD down.
  #
  # @param [Parser::Ruby::Legacy::RubyToken, Symbol, String, Regexp] matches
  #   statements that match the declaration will be
  #   processed by this handler. A {String} match is
  #   equivalent to a +/\Astring/+ regular expression
  #   (match from the beginning of the line), and all
  #   token matches match only the first token of the
  #   statement.
  #
  def self.handles: (*YARD::Parser::Ruby::Legacy::RubyToken | Symbol | String | Regexp matches) -> untyped
  # This class is implemented by {Ruby::Base} and {Ruby::Legacy::Base}.
  # To implement a base handler class for another language, implement
  # this method to return true if the handler should process the given
  # statement object. Use {handlers} to enumerate the matchers declared
  # for the handler class.
  #
  # @param statement a statement object or node (depends on language type)
  # @return [Boolean] whether or not this handler object should process
  #   the given statement
  def self.handles?: (untyped statement) -> bool
  # @return [Array] a list of matchers for the handler object.
  # @see handles?
  def self.handlers: () -> Array[untyped]
  # Declares that the handler should only be called when inside a
  # {CodeObjects::NamespaceObject}, not a method body.
  #
  # @return [void]
  def self.namespace_only: () -> void
  # @return [Boolean] whether the handler should only be processed inside
  #   a namespace.
  def self.namespace_only?: () -> bool
  # Declares that a handler should only be called when inside a filename
  # by its basename or a regex match for the full path.
  #
  # @param [String, Regexp] filename a matching filename or regex
  # @return [void]
  # @since 0.6.2
  def self.in_file: (String | Regexp filename) -> void
  # @return [Boolean] whether the filename matches the declared file
  #   match for a handler. If no file match is specified, returns true.
  # @since 0.6.2
  def self.matches_file?: (untyped filename) -> bool
  # Generates a +process+ method, equivalent to +def process; ... end+.
  # Blocks defined with this syntax will be wrapped inside an anonymous
  # module so that the handler class can be extended with mixins that
  # override the +process+ method without alias chaining.
  #
  # @!macro yard.handlers.process
  #   @!method process
  #   Main processing callback
  #   @return [void]
  # @see #process
  # @return [void]
  # @since 0.5.4
  def self.process: () -> void
  def initialize: (untyped source_parser, untyped stmt) -> void
  # The main handler method called by the parser on a statement
  # that matches the {handles} declaration.
  #
  # Subclasses should override this method to provide the handling
  # functionality for the class.
  #
  # @return [Array<CodeObjects::Base>, CodeObjects::Base, Object]
  #   If this method returns a code object (or a list of them),
  #   they are passed to the +#register+ method which adds basic
  #   attributes. It is not necessary to return any objects and in
  #   some cases you may want to explicitly avoid the returning of
  #   any objects for post-processing by the register method.
  #
  # @see handles
  # @see #register
  #
  def process: () -> untyped
  # Parses the semantic "block" contained in the statement node.
  #
  # @abstract Subclasses should call {Processor#process parser.process}
  def parse_block: (*untyped) -> untyped
  # Aborts a handler by raising {Handlers::HandlerAborted}.
  # An exception will only be logged in debugging mode for
  # this kind of handler exit.
  #
  # @since 0.8.4
  def abort!: () -> untyped
  # Executes a given block with specific state values for {#owner},
  # {#namespace} and {#scope}.
  #
  # @option opts [CodeObjects::NamespaceObject] :namespace (value of #namespace)
  #   the namespace object that {#namespace} will be equal to for the
  #   duration of the block.
  # @option opts [Symbol] :scope (:instance)
  #   the scope for the duration of the block.
  # @option opts [CodeObjects::Base] :owner (value of #owner)
  #   the owner object (method) for the duration of the block
  # @yield a block to execute with the given state values.
  def push_state: (?Hash[untyped, untyped] opts) -> untyped
  # Do some post processing on a list of code objects.
  # Adds basic attributes to the list of objects like
  # the filename, line number, {CodeObjects::Base#dynamic},
  # source code and {CodeObjects::Base#docstring},
  # but only if they don't exist.
  #
  # @param [Array<CodeObjects::Base>] objects
  #   the list of objects to post-process.
  #
  # @return [CodeObjects::Base, Array<CodeObjects::Base>]
  #   returns whatever is passed in, for chainability.
  #
  def register: (*Array[YARD::CodeObjects::Base] objects) -> (Array[YARD::CodeObjects::Base] | YARD::CodeObjects::Base)
  # Ensures that the object's namespace is loaded before attaching it
  # to the namespace.
  #
  # @param [CodeObjects::Base] object the object to register
  # @return [void]
  # @since 0.8.0
  def register_ensure_loaded: (YARD::CodeObjects::Base object) -> void
  # Registers the file/line of the declaration with the object
  #
  # @param [CodeObjects::Base] object the object to register
  # @return [void]
  # @since 0.8.0
  def register_file_info: (YARD::CodeObjects::Base object, ?untyped file, ?untyped line, ?untyped comments) -> void
  # Registers any docstring found for the object and expands macros
  #
  # @param [CodeObjects::Base] object the object to register
  # @return [void]
  # @since 0.8.0
  def register_docstring: (YARD::CodeObjects::Base object, ?untyped docstring, ?untyped stmt) -> void
  # Registers the object as being inside a specific group
  #
  # @param [CodeObjects::Base] object the object to register
  # @return [void]
  # @since 0.8.0
  def register_group: (YARD::CodeObjects::Base object, ?untyped group) -> void
  # Registers any transitive tags from the namespace on the object
  #
  # @param [CodeObjects::Base, nil] object the object to register
  # @return [void]
  # @since 0.8.0
  def register_transitive_tags: (YARD::CodeObjects::Base? object) -> void
  # @param [CodeObjects::Base] object the object to register
  # @return [void]
  # @since 0.8.0
  def register_source: (YARD::CodeObjects::Base object, ?untyped source, ?untyped type) -> void
  # Registers visibility on a method object. If the object does not
  # respond to setting visibility, nothing is done.
  #
  # @param [#visibility=] object the object to register
  # @param [Symbol] visibility the visibility to set on the object
  # @since 0.8.0
  def register_visibility: (untyped object, ?Symbol visibility) -> untyped
  # Registers the same method information on the module function, if
  # the object was defined as a module function.
  #
  # @param [CodeObjects::Base] object the possible module function object
  #   to copy data for
  # @since 0.8.0
  def register_module_function: (YARD::CodeObjects::Base object) -> untyped
  # Registers the object as dynamic if the object is defined inside
  # a method or block (owner != namespace)
  #
  # @param [CodeObjects::Base] object the object to register
  # @return [void]
  # @since 0.8.0
  def register_dynamic: (YARD::CodeObjects::Base object) -> void
  # Ensures that a specific +object+ has been parsed and loaded into the
  # registry. This is necessary when adding data to a namespace, for instance,
  # since the namespace may not have been processed yet (it can be located
  # in a file that has not been handled).
  #
  # Calling this method defers the handler until all other files have been
  # processed. If the object gets resolved, the rest of the handler continues,
  # otherwise an exception is raised.
  #
  # @example Adding a mixin to the String class programmatically
  #   ensure_loaded! P('String')
  #   # "String" is now guaranteed to be loaded
  #   P('String').mixins << P('MyMixin')
  #
  # @param [Proxy, CodeObjects::Base] object the object to resolve.
  # @param [Integer] max_retries the number of times to defer the handler
  #   before raising a +NamespaceMissingError+.
  # @raise [NamespaceMissingError] if the object is not resolved within
  #   +max_retries+ attempts, this exception is raised and the handler
  #   finishes processing.
  def ensure_loaded!: (YARD::CodeObjects::Proxy | YARD::CodeObjects::Base object, ?Integer max_retries) -> untyped
  # @abstract Implement this method to return the parameters in a method call
  #   statement. It should return an empty list if the statement is not a
  #   method call.
  # @return [Array<String>] a list of argument names
  def call_params: () -> Array[String]
  # @abstract Implement this method to return the method being called in
  #   a method call. It should return nil if the statement is not a method
  #   call.
  # @return [String] the method name being called
  # @return [nil] if the statement is not a method call
  def caller_method: () -> String?
end

# CRuby Handlers
# @since 0.8.0
module YARD::Handlers::C
end

class YARD::Handlers::C::AliasHandler < ::YARD::Handlers::C::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
  MATCH: untyped
end

class YARD::Handlers::C::AttributeHandler < ::YARD::Handlers::C::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
  MATCH: untyped
end

class YARD::Handlers::C::Base < ::YARD::Handlers::Base
  # @return [Boolean] whether the handler handles this statement
  def self.handles?: (untyped statement, untyped processor) -> bool
  def self.statement_class: (?untyped type) -> untyped
  # @group Registering objects
  def register_docstring: (untyped object, ?untyped docstring, ?untyped stmt) -> untyped
  def register_file_info: (untyped object, ?untyped file, ?untyped line, ?untyped comments) -> untyped
  def register_source: (untyped object, ?untyped source, ?untyped type) -> untyped
  def register_visibility: (untyped object, ?untyped visibility) -> untyped
  # @group Looking up Symbol and Var Values
  def symbols: () -> untyped
  def override_comments: () -> untyped
  def namespace_for_variable: (untyped var) -> untyped
  def ensure_variable_defined!: (untyped var, ?untyped max_retries) -> untyped
  def namespaces: () -> untyped
  def processed_files: () -> untyped
  # @group Parsing an Inner Block
  def parse_block: (?untyped opts) -> untyped
  # @group Processing other files
  def process_file: (untyped file, untyped object) -> untyped
  private def remove_var_prefix: (untyped var) -> untyped
  def handle_class: (untyped var_name, untyped class_name, untyped parent, ?untyped in_module) -> untyped
  def handle_module: (untyped var_name, untyped module_name, ?untyped in_module) -> untyped
  def handle_method: (untyped scope, untyped var_name, untyped name, untyped func_name, ?untyped _source_file) -> untyped
  def handle_attribute: (untyped var_name, untyped name, untyped read, untyped write) -> untyped
  def handle_alias: (untyped var_name, untyped new_name, untyped old_name) -> untyped
  def handle_constants: (untyped type, untyped var_name, untyped const_name, untyped value) -> untyped
  private def find_constant_docstring: (untyped object) -> untyped
  private def find_method_body: (untyped object, untyped symbol) -> untyped
  private def record_parameters: (untyped object, untyped symbol, untyped src) -> untyped
  # @param [MethodObject] obj
  def add_predicate_return_tag: (YARD::CodeObjects::MethodObject obj) -> untyped
  # Generated by update_error_map.rb (Copy+past results)
  ERROR_CLASS_NAMES: untyped
end

class YARD::Handlers::C::ClassHandler < ::YARD::Handlers::C::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
  MATCH1: untyped
  MATCH2: untyped
end

class YARD::Handlers::C::ConstantHandler < ::YARD::Handlers::C::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
  MATCH: untyped
end

module YARD::Handlers::C::HandlerMethods
  def handle_class: (untyped var_name, untyped class_name, untyped parent, ?untyped in_module) -> untyped

  def handle_module: (untyped var_name, untyped module_name, ?untyped in_module) -> untyped

  def handle_method: (untyped scope, untyped var_name, untyped name, untyped func_name, ?untyped _source_file) -> untyped

  def handle_attribute: (untyped var_name, untyped name, untyped read, untyped write) -> untyped

  def handle_alias: (untyped var_name, untyped new_name, untyped old_name) -> untyped

  def handle_constants: (untyped type, untyped var_name, untyped const_name, untyped value) -> untyped

  private def find_constant_docstring: (untyped object) -> untyped

  private def find_method_body: (untyped object, untyped symbol) -> untyped

  private def record_parameters: (untyped object, untyped symbol, untyped src) -> untyped

  # @param [MethodObject] obj
  def add_predicate_return_tag: (YARD::CodeObjects::MethodObject obj) -> untyped
end

# Handles the Init_Libname() method
class YARD::Handlers::C::InitHandler < ::YARD::Handlers::C::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
  MATCH: untyped
end

class YARD::Handlers::C::MethodHandler < ::YARD::Handlers::C::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
  MATCH1: untyped
  MATCH2: untyped
  MATCH3: untyped
end

class YARD::Handlers::C::MixinHandler < ::YARD::Handlers::C::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
  MATCH: untyped
end

class YARD::Handlers::C::ModuleHandler < ::YARD::Handlers::C::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
  MATCH1: untyped
  MATCH2: untyped
end

# Parses comments
class YARD::Handlers::C::OverrideCommentHandler < ::YARD::Handlers::C::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
  def register_docstring: (untyped object, ?untyped docstring, ?untyped stmt) -> untyped
  def register_file_info: (untyped object, ?untyped file, ?untyped line, ?untyped comments) -> untyped
end

class YARD::Handlers::C::PathHandler < ::YARD::Handlers::C::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
  MATCH: untyped
end

class YARD::Handlers::C::StructHandler < ::YARD::Handlers::C::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
  MATCH: untyped
end

# Keeps track of function bodies for symbol lookup during Ruby method declarations
class YARD::Handlers::C::SymbolHandler < ::YARD::Handlers::C::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
  MATCH: untyped
end

# Shared logic between C and Ruby handlers.
module YARD::Handlers::Common
end

# Shared functionality between Ruby and C method handlers.
module YARD::Handlers::Common::MethodHandler
  # @param [MethodObject] obj
  def add_predicate_return_tag: (untyped obj) -> untyped
end

# Raise this error when a handler should exit before completing.
# The exception will be silenced, allowing the next handler(s) in the
# queue to be executed.
# @since 0.8.4
class YARD::Handlers::HandlerAborted < ::RuntimeError
end

# Raised during processing phase when a handler needs to perform
# an operation on an object's namespace but the namespace could
# not be resolved.
class YARD::Handlers::NamespaceMissingError < ::YARD::Parser::UndocumentableError
  # The object the error occurred on
  # @return [CodeObjects::Base] a code object
  attr_accessor object: YARD::CodeObjects::Base
  def initialize: (untyped object) -> void
end

# Iterates over all statements in a file and delegates them to the
# {Handlers::Base} objects that are registered to handle the statement.
#
# This class is passed to each handler and keeps overall processing state.
# For example, if the {#visibility} is set in a handler, all following
# statements will have access to this state. This allows "public",
# "protected" and "private" statements to be handled in classes and modules.
# In addition, the {#namespace} can be set during parsing to control
# where objects are being created from. You can also access extra stateful
# properties that any handler can set during the duration of the post
# processing of a file from {#extra_state}. If you need to access state
# across different files, look at {#globals}.
#
# @see Handlers::Base
class YARD::Handlers::Processor
  # @return [Hash] a list of registered parser type extensions
  # @private
  # @since 0.6.0
  attr_reader self.namespace_for_handler: Hash[untyped, untyped]
  # @return [String] the filename
  attr_accessor file: String
  # @return [CodeObjects::NamespaceObject] the current namespace
  attr_accessor namespace: YARD::CodeObjects::NamespaceObject
  # @return [Symbol] the current visibility (public, private, protected)
  attr_accessor visibility: Symbol
  # @return [Symbol] the current scope (class, instance)
  attr_accessor scope: Symbol
  # @return [CodeObjects::Base, nil] unlike the namespace, the owner
  #   is a non-namespace object that should be stored between statements.
  #   For instance, when parsing a method body, the {CodeObjects::MethodObject}
  #   is set as the owner, in case any extra method information is processed.
  attr_accessor owner: YARD::CodeObjects::Base?
  # @return [Symbol] the parser type (:ruby, :ruby18, :c)
  attr_accessor parser_type: Symbol
  # Handlers can share state for the entire post processing stage through
  # this attribute. Note that post processing stage spans multiple files.
  # To share state only within a single file, use {#extra_state}
  #
  # @example Sharing state among two handlers
  #   class Handler1 < YARD::Handlers::Ruby::Base
  #     handles :class
  #     process { globals.foo = :bar }
  #   end
  #
  #   class Handler2 < YARD::Handlers::Ruby::Base
  #     handles :method
  #     process { puts globals.foo }
  #   end
  # @return [OpenStruct] global shared state for post-processing stage
  # @see #extra_state
  attr_accessor globals: OpenStruct
  # Share state across different handlers inside of a file.
  # This attribute is similar to {#visibility}, {#scope}, {#namespace}
  # and {#owner}, in that they all maintain state across all handlers
  # for the entire source file. Use this attribute to store any data
  # your handler might need to save during the parsing of a file. If
  # you need to save state across files, see {#globals}.
  #
  # @return [OpenStruct] an open structure that can store arbitrary data
  # @see #globals
  attr_accessor extra_state: OpenStruct
  # Registers a new namespace for handlers of the given type.
  # @since 0.6.0
  def self.register_handler_namespace: (untyped type, untyped ns) -> untyped
  # Creates a new Processor for a +file+.
  # @param [Parser::SourceParser] parser the parser used to initialize the processor
  def initialize: (YARD::Parser::SourceParser parser) -> void
  # Processes a list of statements by finding handlers to process each
  # one.
  #
  # @param [Array] statements a list of statements
  # @return [void]
  def process: (Array[untyped] statements) -> void
  # Continue parsing the remainder of the files in the +globals.ordered_parser+
  # object. After the remainder of files are parsed, processing will continue
  # on the current file.
  #
  # @return [void]
  # @see Parser::OrderedParser
  def parse_remaining_files: () -> void
  # Searches for all handlers in {Base.subclasses} that match the +statement+
  #
  # @param statement the statement object to match.
  # @return [Array<Base>] a list of handlers to process the statement with.
  def find_handlers: (untyped statement) -> Array[YARD::Handlers::Base]
  private def handles?: (untyped handler, untyped statement) -> bool
  # Returns the handler base class
  # @return [Base] the base class
  private def handler_base_class: () -> YARD::Handlers::Base
  # The module holding the handlers to be loaded
  #
  # @return [Module] the module containing the handlers depending on
  #   {#parser_type}.
  private def handler_base_namespace: () -> Module
  # Loads handlers from {#handler_base_namespace}. This ensures that
  # Ruby1.9 handlers are never loaded into 1.8; also lowers the amount
  # of modules that are loaded
  # @return [void]
  private def load_handlers: () -> void
end

# All Ruby handlers
module YARD::Handlers::Ruby
end

# Handles alias and alias_method calls
class YARD::Handlers::Ruby::AliasHandler < ::YARD::Handlers::Ruby::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
end

# Handles +attr_*+ statements in modules/classes
class YARD::Handlers::Ruby::AttributeHandler < ::YARD::Handlers::Ruby::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
  # Strips out any non-essential arguments from the attr statement.
  #
  # @param [Array<Parser::Ruby::AstNode>] params a list of the parameters
  #   in the attr call.
  # @return [Array<String>] the validated attribute names
  # @raise [Parser::UndocumentableError] if the arguments are not valid.
  def validated_attribute_names: (Array[YARD::Parser::Ruby::AstNode] params) -> Array[String]
end

# This is the base handler class for the new-style (1.9) Ruby parser.
# All handlers that subclass this base class will be used when the
# new-style parser is used. For implementing legacy handlers, see
# {Legacy::Base}.
#
# @abstract See {Handlers::Base} for subclassing information.
# @see Handlers::Base
# @see Legacy::Base
class YARD::Handlers::Ruby::Base < ::YARD::Handlers::Base
  # Matcher for handling any type of method call. Method calls can
  # be expressed by many {AstNode} types depending on the syntax
  # with which it is called, so YARD allows you to use this matcher
  # to simplify matching a method call.
  #
  # @example Match the "describe" method call
  #   handles method_call(:describe)
  #
  #   # The following will be matched:
  #   # describe(...)
  #   # object.describe(...)
  #   # describe "argument" do ... end
  #
  # @param [#to_s] name matches the method call of this name
  # @return [void]
  def self.method_call: (?untyped name) -> void
  # Matcher for handling a node with a specific meta-type. An {AstNode}
  # has a {AstNode#type} to define its type but can also be associated
  # with a set of types. For instance, +:if+ and +:unless+ are both
  # of the meta-type +:condition+.
  #
  # A meta-type is any method on the {AstNode} class ending in "?",
  # though you should not include the "?" suffix in your declaration.
  # Some examples are: "condition", "call", "literal", "kw", "token",
  # "ref".
  #
  # @example Handling any conditional statement (if, unless)
  #   handles meta_type(:condition)
  # @param [Symbol] type the meta-type to match. A meta-type can be
  #   any method name + "?" that {AstNode} responds to.
  # @return [void]
  def self.meta_type: (Symbol type) -> void
  # @return [Boolean] whether or not an {AstNode} object should be
  #   handled by this handler
  def self.handles?: (untyped node) -> bool
  # @group Parsing an Inner Block
  def parse_block: (untyped inner_node, ?untyped opts) -> untyped
  # @group Macro Handling
  def call_params: () -> untyped
  def caller_method: () -> untyped
  # Builds and s-expression by creating {AstNode} objects with
  # the type provided by the first argument.
  #
  # @example An implicit list of keywords
  #   ast = s(s(:kw, "if"), s(:kw, "else"))
  #   ast.type # => :list
  # @example A method call
  #   s(:command, s(:var_ref, "mymethod"))
  #
  # @overload s(*nodes, opts = {})
  #   @param [Array<AstNode>] nodes a list of nodes.
  #   @param [Hash] opts any extra options (docstring, file, source) to
  #     set on the object
  #   @return [AstNode] an implicit node where node.type == +:list+
  # @overload s(type, *children, opts = {})
  #   @param [Symbol] type the node type
  #   @param [Array<AstNode>] children any child nodes inside this one
  #   @param [Hash] opts any extra options to set on the object
  #   @return [AstNode] a node of type +type+.
  # @see AstNode#initialize
  def s: (*untyped args) -> untyped
end

# Matches if/unless conditions inside classes and attempts to process only
# one branch (by evaluating the condition if possible).
#
# @example A simple class conditional
#   class Foo
#     if 0
#       # This method is ignored
#       def xyz; end
#     end
#   end
class YARD::Handlers::Ruby::ClassConditionHandler < ::YARD::Handlers::Ruby::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
  # Parses the condition part of the if/unless statement
  #
  # @return [true, false, nil] true if the condition can be definitely
  #   parsed to true, false if not, and nil if the condition cannot be
  #   parsed with certainty (it's dynamic)
  def parse_condition: () -> bool?
  def parse_then_block: () -> untyped
  def parse_else_block: () -> untyped
end

# Handles class declarations
class YARD::Handlers::Ruby::ClassHandler < ::YARD::Handlers::Ruby::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
  # Extract the parameters from the Struct.new AST node, returning them as a list
  # of strings
  #
  # @param [MethodCallNode] superclass the AST node for the Struct.new call
  # @return [Array<String>] the member names to generate methods for
  private def extract_parameters: (YARD::Parser::Ruby::MethodCallNode superclass) -> Array[String]
  private def create_struct_superclass: (untyped superclass, untyped superclass_def) -> untyped
  private def struct_superclass_name: (untyped superclass) -> untyped
  private def parse_struct_superclass: (untyped klass, untyped superclass) -> untyped
  private def parse_superclass: (untyped superclass) -> untyped
  # Extracts the user's defined @member tag for a given class and its member. Returns
  # nil if the user did not define a @member tag for this struct entry.
  #
  # @param [ClassObject] klass the class whose tags we're searching
  # @param [String] member the name of the struct member we need
  # @param [Symbol] type reader method, or writer method?
  # @return [Tags::Tag, nil] the tag matching the request, or nil if not found
  def member_tag_for_member: (YARD::CodeObjects::ClassObject klass, String member, ?Symbol type) -> YARD::Tags::Tag?
  # Retrieves all members defined in @attr* tags
  #
  # @param [ClassObject] klass the class with the attributes
  # @return [Array<String>] the list of members defined as attributes on the class
  def members_from_tags: (YARD::CodeObjects::ClassObject klass) -> Array[String]
  # Determines whether to create an attribute method based on the class's
  # tags.
  #
  # @param [ClassObject] klass the class whose tags we're searching
  # @param [String] member the name of the struct member we need
  # @param [Symbol] type (:read) reader method, or writer method?
  # @return [Boolean] should the attribute be created?
  def create_member_method?: (YARD::CodeObjects::ClassObject klass, String member, ?Symbol type) -> bool
  # Gets the return type for the member in a nicely formatted string. Used
  # to be injected into auto-generated docstrings.
  #
  # @param [Tags::Tag] member_tag the tag object to check for types
  # @return [String] the user-declared type of the struct member, or [Object] if
  #   the user did not define a type for this member.
  def return_type_from_tag: (YARD::Tags::Tag member_tag) -> String
  # Creates the auto-generated docstring for the getter method of a struct's
  # member. This is used so the generated documentation will look just like that
  # of an attribute defined using attr_accessor.
  #
  # @param [ClassObject] klass the class whose members we're working with
  # @param [String] member the name of the member we're generating documentation for
  # @return [String] a docstring to be attached to the getter method for this member
  def add_reader_tags: (YARD::CodeObjects::ClassObject klass, untyped new_method, String member) -> String
  # Creates the auto-generated docstring for the setter method of a struct's
  # member. This is used so the generated documentation will look just like that
  # of an attribute defined using attr_accessor.
  #
  # @param [ClassObject] klass the class whose members we're working with
  # @param [String] member the name of the member we're generating documentation for
  # @return [String] a docstring to be attached to the setter method for this member
  def add_writer_tags: (YARD::CodeObjects::ClassObject klass, untyped new_method, String member) -> String
  # Creates and registers a class object with the given name and superclass name.
  # Returns it for further use.
  #
  # @param [String] classname the name of the class
  # @param [String] superclass the name of the superclass
  # @return [ClassObject] the class object for further processing/method attaching
  def create_class: (String classname, String superclass) -> YARD::CodeObjects::ClassObject
  # Creates the setter (writer) method and attaches it to the class as an attribute.
  # Also sets up the docstring to prettify the documentation output.
  #
  # @param [ClassObject] klass the class to attach the method to
  # @param [String] member the name of the member we're generating a method for
  def create_writer: (YARD::CodeObjects::ClassObject klass, String member) -> untyped
  # Creates the getter (reader) method and attaches it to the class as an attribute.
  # Also sets up the docstring to prettify the documentation output.
  #
  # @param [ClassObject] klass the class to attach the method to
  # @param [String] member the name of the member we're generating a method for
  def create_reader: (YARD::CodeObjects::ClassObject klass, String member) -> untyped
  # Creates the given member methods and attaches them to the given ClassObject.
  #
  # @param [ClassObject] klass the class to generate attributes for
  # @param [Array<String>] members a list of member names
  def create_attributes: (YARD::CodeObjects::ClassObject klass, Array[String] members) -> untyped
end

# Handles a class variable (@@variable)
class YARD::Handlers::Ruby::ClassVariableHandler < ::YARD::Handlers::Ruby::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
end

# Handles any lone comment statement in a Ruby file
class YARD::Handlers::Ruby::CommentHandler < ::YARD::Handlers::Ruby::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
end

# Handles any constant assignment
class YARD::Handlers::Ruby::ConstantHandler < ::YARD::Handlers::Ruby::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
  private def process_constant: (untyped statement) -> untyped
  private def process_structclass: (untyped statement) -> untyped
  # Extract the parameters from the Struct.new AST node, returning them as a list
  # of strings
  #
  # @param [MethodCallNode] superclass the AST node for the Struct.new call
  # @return [Array<String>] the member names to generate methods for
  private def extract_parameters: (YARD::Parser::Ruby::MethodCallNode superclass) -> Array[String]
  # Extracts the user's defined @member tag for a given class and its member. Returns
  # nil if the user did not define a @member tag for this struct entry.
  #
  # @param [ClassObject] klass the class whose tags we're searching
  # @param [String] member the name of the struct member we need
  # @param [Symbol] type reader method, or writer method?
  # @return [Tags::Tag, nil] the tag matching the request, or nil if not found
  def member_tag_for_member: (YARD::CodeObjects::ClassObject klass, String member, ?Symbol type) -> YARD::Tags::Tag?
  # Retrieves all members defined in @attr* tags
  #
  # @param [ClassObject] klass the class with the attributes
  # @return [Array<String>] the list of members defined as attributes on the class
  def members_from_tags: (YARD::CodeObjects::ClassObject klass) -> Array[String]
  # Determines whether to create an attribute method based on the class's
  # tags.
  #
  # @param [ClassObject] klass the class whose tags we're searching
  # @param [String] member the name of the struct member we need
  # @param [Symbol] type (:read) reader method, or writer method?
  # @return [Boolean] should the attribute be created?
  def create_member_method?: (YARD::CodeObjects::ClassObject klass, String member, ?Symbol type) -> bool
  # Gets the return type for the member in a nicely formatted string. Used
  # to be injected into auto-generated docstrings.
  #
  # @param [Tags::Tag] member_tag the tag object to check for types
  # @return [String] the user-declared type of the struct member, or [Object] if
  #   the user did not define a type for this member.
  def return_type_from_tag: (YARD::Tags::Tag member_tag) -> String
  # Creates the auto-generated docstring for the getter method of a struct's
  # member. This is used so the generated documentation will look just like that
  # of an attribute defined using attr_accessor.
  #
  # @param [ClassObject] klass the class whose members we're working with
  # @param [String] member the name of the member we're generating documentation for
  # @return [String] a docstring to be attached to the getter method for this member
  def add_reader_tags: (YARD::CodeObjects::ClassObject klass, untyped new_method, String member) -> String
  # Creates the auto-generated docstring for the setter method of a struct's
  # member. This is used so the generated documentation will look just like that
  # of an attribute defined using attr_accessor.
  #
  # @param [ClassObject] klass the class whose members we're working with
  # @param [String] member the name of the member we're generating documentation for
  # @return [String] a docstring to be attached to the setter method for this member
  def add_writer_tags: (YARD::CodeObjects::ClassObject klass, untyped new_method, String member) -> String
  # Creates and registers a class object with the given name and superclass name.
  # Returns it for further use.
  #
  # @param [String] classname the name of the class
  # @param [String] superclass the name of the superclass
  # @return [ClassObject] the class object for further processing/method attaching
  def create_class: (String classname, String superclass) -> YARD::CodeObjects::ClassObject
  # Creates the setter (writer) method and attaches it to the class as an attribute.
  # Also sets up the docstring to prettify the documentation output.
  #
  # @param [ClassObject] klass the class to attach the method to
  # @param [String] member the name of the member we're generating a method for
  def create_writer: (YARD::CodeObjects::ClassObject klass, String member) -> untyped
  # Creates the getter (reader) method and attaches it to the class as an attribute.
  # Also sets up the docstring to prettify the documentation output.
  #
  # @param [ClassObject] klass the class to attach the method to
  # @param [String] member the name of the member we're generating a method for
  def create_reader: (YARD::CodeObjects::ClassObject klass, String member) -> untyped
  # Creates the given member methods and attaches them to the given ClassObject.
  #
  # @param [ClassObject] klass the class to generate attributes for
  # @param [Array<String>] members a list of member names
  def create_attributes: (YARD::CodeObjects::ClassObject klass, Array[String] members) -> untyped
end

# Handles automatic detection of dsl-style methods
class YARD::Handlers::Ruby::DSLHandler < ::YARD::Handlers::Ruby::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
  def handle_comments: () -> untyped
  def register_docstring: (untyped object, ?untyped docstring, ?untyped stmt) -> untyped
  private def implicit_docstring?: () -> bool
  private def method_name: () -> untyped
  private def method_signature: () -> untyped
  private def find_attached_macro: () -> untyped
  # @return [Boolean] whether caller method matches a macro or
  #   its alias names.
  private def macro_name_matches: (untyped macro) -> bool
end

module YARD::Handlers::Ruby::DSLHandlerMethods
  IGNORE_METHODS: untyped

  def handle_comments: () -> untyped

  def register_docstring: (untyped object, ?untyped docstring, ?untyped stmt) -> untyped

  private def implicit_docstring?: () -> bool

  private def method_name: () -> untyped

  private def method_signature: () -> untyped

  private def find_attached_macro: () -> untyped

  # @return [Boolean] whether caller method matches a macro or
  #   its alias names.
  private def macro_name_matches: (untyped macro) -> bool
end

# Helper methods to assist with processing decorators.
module YARD::Handlers::Ruby::DecoratorHandlerMethods
  # @overload process_decorator(*nodes, opts = {}, &block)
  #   Takes care of parsing method definitions passed to decorators
  #   as parameters, as well as parsing chained decorators.
  #
  #   Use this in a handler's process block.
  #
  #   @yieldparam method [YARD::CodeObjects::MethodObject] Method being decorated.
  #   @yieldparam node [YARD::Parser::Ruby::AstNode] AST node of the decorated method.
  #   @yieldparam name [Symbol] Name of the decorated method.
  #   @return [Array<Hash>] Array of hashes containing :method, :node, :name.
  #     See yield params.
  #
  #   @param nodes [YARD::Parser::Ruby::AstNode] AST nodes that refer to decorated
  #     methods, like indexes of statement.parameter. Defaults to all parameters.
  #     Pass nil to specify zero parameters.
  #
  #   @option opts [:instance, :class] :scope (:instance) Scope to use for each
  #     MethodObject.
  #
  #   @option opts [true, false] :transfer_docstring Set false to disable
  #     transferring the decorator docstring to method definitions passed to the
  #     decorator as parameters.
  #
  #   @option opts [true, false] :transfer_source Set false to disable
  #     transferring the decorator source code string to method definitions
  #     passed to the decorator as parameters.
  #
  #   @example Basic Usage
  #     # Simply pass the method docs through to the method definition.
  #     process do
  #       process_decorator
  #     end
  #
  #   @example Setting a method's visibility to private.
  #     process do
  #       process_decorator :scope => :class do |method|
  #         method.visibility = :private if method.respond_to? :visibility
  #       end
  #     end
  def process_decorator: (*untyped nodes) -> untyped

  private def process_decorator_parameter: (untyped node, ?untyped opts) -> untyped
end

# Handles 'raise' calls inside methods
class YARD::Handlers::Ruby::ExceptionHandler < ::YARD::Handlers::Ruby::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
end

# Handles 'extend' call to include modules into the class scope of another
# @see MixinHandler
class YARD::Handlers::Ruby::ExtendHandler < ::YARD::Handlers::Ruby::MixinHandler
  def scope: () -> untyped
  private def process_mixin: (untyped mixin) -> untyped
end

# To implement a custom handler matcher, subclass this class and implement
# {#matches?} to return whether a node matches the handler.
#
# @example A Custom Handler Matcher Extension
#   # Implements a handler that checks for a specific string
#   # in the node's source.
#   class MyExtension < HandlesExtension
#     def matches?(node) node.source.include?(name) end
#   end
#
#   # This handler will handle any node where the source includes 'foo'
#   class MyHandler < Handlers::Ruby::Base
#     handles MyExtension.new('foo')
#   end
class YARD::Handlers::Ruby::HandlesExtension
  # @return [String] the extension matcher value
  attr_reader name: String
  # Creates a new extension with a specific matcher value +name+
  # @param [Object] name the matcher value to check against {#matches?}
  def initialize: (untyped name) -> void
  # Tests if the node matches the handler
  # @param [Parser::Ruby::AstNode] node a Ruby node
  # @return [Boolean] whether the +node+ matches the handler
  def matches?: (YARD::Parser::Ruby::AstNode node) -> bool
end

# Handlers for old Ruby 1.8 parser
module YARD::Handlers::Ruby::Legacy
end

# Handles alias and alias_method calls
#
class YARD::Handlers::Ruby::Legacy::AliasHandler < ::YARD::Handlers::Ruby::Legacy::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
end

# Handles +attr_*+ statements in modules/classes
#
class YARD::Handlers::Ruby::Legacy::AttributeHandler < ::YARD::Handlers::Ruby::Legacy::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
end

# This is the base handler for the legacy parser. To implement a legacy
# handler, subclass this class.
#
# @abstract (see Ruby::Base)
class YARD::Handlers::Ruby::Legacy::Base < ::YARD::Handlers::Base
  # @return [Boolean] whether or not a {Parser::Ruby::Legacy::Statement} object should be handled
  #   by this handler.
  def self.handles?: (untyped stmt) -> bool
  # Parses a statement's block with a set of state values. If the
  # statement has no block, nothing happens. A description of state
  # values can be found at {Handlers::Base#push_state}
  #
  # @param [Hash] opts State options
  # @option opts (see Handlers::Base#push_state)
  # @see Handlers::Base#push_state #push_state
  def parse_block: (?Hash[untyped, untyped] opts) -> untyped
  def call_params: () -> untyped
  def caller_method: () -> untyped
  # Extracts method information for macro expansion only
  #
  # @todo This is a duplicate implementation of {MethodHandler}. Refactor.
  # @return [Array<String,Array<Array<String>>>] the method name followed by method
  #   arguments (name and optional value)
  private def extract_method_details: () -> Array[Array[Array[String]] | String]
  # The string value of a token. For example, the return value for the symbol :sym
  # would be :sym. The return value for a string +"foo #{ bar}"+ would be the literal
  # +"foo #{ bar}"+ without any interpolation. The return value of the identifier
  # 'test' would be the same value: 'test'. Here is a list of common types and
  # their return values:
  #
  # @example
  #   tokval(TokenList.new('"foo"').first) => "foo"
  #   tokval(TokenList.new(':foo').first) => :foo
  #   tokval(TokenList.new('CONSTANT').first, RubyToken::TkId) => "CONSTANT"
  #   tokval(TokenList.new('identifier').first, RubyToken::TkId) => "identifier"
  #   tokval(TokenList.new('3.25').first) => 3.25
  #   tokval(TokenList.new('/xyz/i').first) => /xyz/i
  #
  # @param [Token] token The token of the class
  #
  # @param [Array<Class<Token>>, Symbol] accepted_types
  #   The allowed token types that this token can be. Defaults to [{TkVal}].
  #   A list of types would be, for example, [+TkSTRING+, +TkSYMBOL+], to return
  #   the token's value if it is either of those types. If +TkVal+ is accepted,
  #   +TkNode+ is also accepted.
  #
  #   Certain symbol keys are allowed to specify multiple types in one fell swoop.
  #   These symbols are:
  #     :string       => +TkSTRING+, +TkDSTRING+, +TkDXSTRING+ and +TkXSTRING+
  #     :attr         => +TkSYMBOL+ and +TkSTRING+
  #     :identifier   => +TkIDENTIFIER, +TkFID+ and +TkGVAR+.
  #     :number       => +TkFLOAT+, +TkINTEGER+
  #
  # @return [Object] if the token is one of the accepted types, in its real value form.
  #   It should be noted that identifiers and constants are kept in String form.
  # @return [nil] if the token is not any of the specified accepted types
  private def tokval: (YARD::Parser::Ruby::Legacy::RubyToken::Token token, *Array[singleton(YARD::Parser::Ruby::Legacy::RubyToken::Token)] | Symbol accepted_types) -> untyped
  # Returns a list of symbols or string values from a statement.
  # The list must be a valid comma delimited list, and values
  # will only be returned to the end of the list only.
  #
  # Example:
  #   attr_accessor :a, 'b', :c, :d => ['a', 'b', 'c', 'd']
  #   attr_accessor 'a', UNACCEPTED_TYPE, 'c' => ['a', 'c']
  #
  # The tokval list of a {Parser::Ruby::Legacy::TokenList} of the above
  # code would be the {#tokval} value of :a, 'b',
  # :c and :d.
  #
  # It should also be noted that this function stops immediately at
  # any ruby keyword encountered:
  #   "attr_accessor :a, :b, :c if x == 5"  => ['a', 'b', 'c']
  #
  # @param [TokenList] tokenlist The list of tokens to process.
  # @param [Array<Class<Token>>] accepted_types passed to {#tokval}
  # @return [Array<String>] the list of tokvalues in the list.
  # @return [Array<EMPTY>] if there are no symbols or Strings in the list
  # @see #tokval
  private def tokval_list: (untyped tokenlist, *Array[singleton(YARD::Parser::Ruby::Legacy::RubyToken::Token)] accepted_types) -> Array[untyped]
  # @private
  def set_token_position: (untyped line, untyped char) -> untyped
  # @private
  def Token: (untyped token, ?untyped value) -> untyped
end

# Matches if/unless conditions inside classes and attempts to process only
# one branch (by evaluating the condition if possible).
#
# @example A simple class conditional
#   class Foo
#     if 0
#       # This method is ignored
#       def xyz; end
#     end
#   end
# @since 0.5.4
class YARD::Handlers::Ruby::Legacy::ClassConditionHandler < ::YARD::Handlers::Ruby::Legacy::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
  # Parses the condition part of the if/unless statement
  #
  # @return [true, false, nil] true if the condition can be definitely
  #   parsed to true, false if not, and nil if the condition cannot be
  #   parsed with certainty (it's dynamic)
  # @since 0.5.5
  def parse_condition: () -> bool?
  # @since 0.5.5
  def parse_then_block: () -> untyped
  # @since 0.5.5
  def parse_else_block: () -> untyped
end

# Handles class declarations
#
class YARD::Handlers::Ruby::Legacy::ClassHandler < ::YARD::Handlers::Ruby::Legacy::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
  # Extracts the parameter list from the Struct.new declaration and returns it
  # formatted as a list of member names. Expects the user will have used symbols
  # to define the struct member names
  #
  # @param [String] superstring the string declaring the superclass
  # @return [Array<String>] a list of member names
  private def extract_parameters: (String superstring) -> Array[String]
  private def create_struct_superclass: (untyped superclass, untyped superclass_def) -> untyped
  private def struct_superclass_name: (untyped superclass) -> untyped
  private def parse_struct_subclass: (untyped klass, untyped superclass_def) -> untyped
  private def parse_superclass: (untyped superclass) -> untyped
  # Extracts the user's defined @member tag for a given class and its member. Returns
  # nil if the user did not define a @member tag for this struct entry.
  #
  # @param [ClassObject] klass the class whose tags we're searching
  # @param [String] member the name of the struct member we need
  # @param [Symbol] type reader method, or writer method?
  # @return [Tags::Tag, nil] the tag matching the request, or nil if not found
  def member_tag_for_member: (YARD::CodeObjects::ClassObject klass, String member, ?Symbol type) -> YARD::Tags::Tag?
  # Retrieves all members defined in @attr* tags
  #
  # @param [ClassObject] klass the class with the attributes
  # @return [Array<String>] the list of members defined as attributes on the class
  def members_from_tags: (YARD::CodeObjects::ClassObject klass) -> Array[String]
  # Determines whether to create an attribute method based on the class's
  # tags.
  #
  # @param [ClassObject] klass the class whose tags we're searching
  # @param [String] member the name of the struct member we need
  # @param [Symbol] type (:read) reader method, or writer method?
  # @return [Boolean] should the attribute be created?
  def create_member_method?: (YARD::CodeObjects::ClassObject klass, String member, ?Symbol type) -> bool
  # Gets the return type for the member in a nicely formatted string. Used
  # to be injected into auto-generated docstrings.
  #
  # @param [Tags::Tag] member_tag the tag object to check for types
  # @return [String] the user-declared type of the struct member, or [Object] if
  #   the user did not define a type for this member.
  def return_type_from_tag: (YARD::Tags::Tag member_tag) -> String
  # Creates the auto-generated docstring for the getter method of a struct's
  # member. This is used so the generated documentation will look just like that
  # of an attribute defined using attr_accessor.
  #
  # @param [ClassObject] klass the class whose members we're working with
  # @param [String] member the name of the member we're generating documentation for
  # @return [String] a docstring to be attached to the getter method for this member
  def add_reader_tags: (YARD::CodeObjects::ClassObject klass, untyped new_method, String member) -> String
  # Creates the auto-generated docstring for the setter method of a struct's
  # member. This is used so the generated documentation will look just like that
  # of an attribute defined using attr_accessor.
  #
  # @param [ClassObject] klass the class whose members we're working with
  # @param [String] member the name of the member we're generating documentation for
  # @return [String] a docstring to be attached to the setter method for this member
  def add_writer_tags: (YARD::CodeObjects::ClassObject klass, untyped new_method, String member) -> String
  # Creates and registers a class object with the given name and superclass name.
  # Returns it for further use.
  #
  # @param [String] classname the name of the class
  # @param [String] superclass the name of the superclass
  # @return [ClassObject] the class object for further processing/method attaching
  def create_class: (String classname, String superclass) -> YARD::CodeObjects::ClassObject
  # Creates the setter (writer) method and attaches it to the class as an attribute.
  # Also sets up the docstring to prettify the documentation output.
  #
  # @param [ClassObject] klass the class to attach the method to
  # @param [String] member the name of the member we're generating a method for
  def create_writer: (YARD::CodeObjects::ClassObject klass, String member) -> untyped
  # Creates the getter (reader) method and attaches it to the class as an attribute.
  # Also sets up the docstring to prettify the documentation output.
  #
  # @param [ClassObject] klass the class to attach the method to
  # @param [String] member the name of the member we're generating a method for
  def create_reader: (YARD::CodeObjects::ClassObject klass, String member) -> untyped
  # Creates the given member methods and attaches them to the given ClassObject.
  #
  # @param [ClassObject] klass the class to generate attributes for
  # @param [Array<String>] members a list of member names
  def create_attributes: (YARD::CodeObjects::ClassObject klass, Array[String] members) -> untyped
end

# Handles a class variable (@@variable)
#
class YARD::Handlers::Ruby::Legacy::ClassVariableHandler < ::YARD::Handlers::Ruby::Legacy::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
  HANDLER_MATCH: untyped
end

# Handles any lone comment statement in a Ruby file
#
class YARD::Handlers::Ruby::Legacy::CommentHandler < ::YARD::Handlers::Ruby::Legacy::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
end

# Handles any constant assignment
#
class YARD::Handlers::Ruby::Legacy::ConstantHandler < ::YARD::Handlers::Ruby::Legacy::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
  private def process_structclass: (untyped classname, untyped parameters) -> untyped
  private def extract_parameters: (untyped parameters) -> untyped
  # Extracts the user's defined @member tag for a given class and its member. Returns
  # nil if the user did not define a @member tag for this struct entry.
  #
  # @param [ClassObject] klass the class whose tags we're searching
  # @param [String] member the name of the struct member we need
  # @param [Symbol] type reader method, or writer method?
  # @return [Tags::Tag, nil] the tag matching the request, or nil if not found
  def member_tag_for_member: (YARD::CodeObjects::ClassObject klass, String member, ?Symbol type) -> YARD::Tags::Tag?
  # Retrieves all members defined in @attr* tags
  #
  # @param [ClassObject] klass the class with the attributes
  # @return [Array<String>] the list of members defined as attributes on the class
  def members_from_tags: (YARD::CodeObjects::ClassObject klass) -> Array[String]
  # Determines whether to create an attribute method based on the class's
  # tags.
  #
  # @param [ClassObject] klass the class whose tags we're searching
  # @param [String] member the name of the struct member we need
  # @param [Symbol] type (:read) reader method, or writer method?
  # @return [Boolean] should the attribute be created?
  def create_member_method?: (YARD::CodeObjects::ClassObject klass, String member, ?Symbol type) -> bool
  # Gets the return type for the member in a nicely formatted string. Used
  # to be injected into auto-generated docstrings.
  #
  # @param [Tags::Tag] member_tag the tag object to check for types
  # @return [String] the user-declared type of the struct member, or [Object] if
  #   the user did not define a type for this member.
  def return_type_from_tag: (YARD::Tags::Tag member_tag) -> String
  # Creates the auto-generated docstring for the getter method of a struct's
  # member. This is used so the generated documentation will look just like that
  # of an attribute defined using attr_accessor.
  #
  # @param [ClassObject] klass the class whose members we're working with
  # @param [String] member the name of the member we're generating documentation for
  # @return [String] a docstring to be attached to the getter method for this member
  def add_reader_tags: (YARD::CodeObjects::ClassObject klass, untyped new_method, String member) -> String
  # Creates the auto-generated docstring for the setter method of a struct's
  # member. This is used so the generated documentation will look just like that
  # of an attribute defined using attr_accessor.
  #
  # @param [ClassObject] klass the class whose members we're working with
  # @param [String] member the name of the member we're generating documentation for
  # @return [String] a docstring to be attached to the setter method for this member
  def add_writer_tags: (YARD::CodeObjects::ClassObject klass, untyped new_method, String member) -> String
  # Creates and registers a class object with the given name and superclass name.
  # Returns it for further use.
  #
  # @param [String] classname the name of the class
  # @param [String] superclass the name of the superclass
  # @return [ClassObject] the class object for further processing/method attaching
  def create_class: (String classname, String superclass) -> YARD::CodeObjects::ClassObject
  # Creates the setter (writer) method and attaches it to the class as an attribute.
  # Also sets up the docstring to prettify the documentation output.
  #
  # @param [ClassObject] klass the class to attach the method to
  # @param [String] member the name of the member we're generating a method for
  def create_writer: (YARD::CodeObjects::ClassObject klass, String member) -> untyped
  # Creates the getter (reader) method and attaches it to the class as an attribute.
  # Also sets up the docstring to prettify the documentation output.
  #
  # @param [ClassObject] klass the class to attach the method to
  # @param [String] member the name of the member we're generating a method for
  def create_reader: (YARD::CodeObjects::ClassObject klass, String member) -> untyped
  # Creates the given member methods and attaches them to the given ClassObject.
  #
  # @param [ClassObject] klass the class to generate attributes for
  # @param [Array<String>] members a list of member names
  def create_attributes: (YARD::CodeObjects::ClassObject klass, Array[String] members) -> untyped
  HANDLER_MATCH: untyped
end

# Handles automatic detection of dsl-style methods
#
class YARD::Handlers::Ruby::Legacy::DSLHandler < ::YARD::Handlers::Ruby::Legacy::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
  def handle_comments: () -> untyped
  def register_docstring: (untyped object, ?untyped docstring, ?untyped stmt) -> untyped
  private def implicit_docstring?: () -> bool
  private def method_name: () -> untyped
  private def method_signature: () -> untyped
  private def find_attached_macro: () -> untyped
  # @return [Boolean] whether caller method matches a macro or
  #   its alias names.
  private def macro_name_matches: (untyped macro) -> bool
end

# Handles 'raise' calls inside methods
#
class YARD::Handlers::Ruby::Legacy::ExceptionHandler < ::YARD::Handlers::Ruby::Legacy::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
end

# Handles 'extend' call to include modules into the class scope of another
# @see MixinHandler
#
class YARD::Handlers::Ruby::Legacy::ExtendHandler < ::YARD::Handlers::Ruby::Legacy::MixinHandler
  def scope: () -> untyped
  private def process_mixin: (untyped mixin) -> untyped
end

# Handles a method definition
#
class YARD::Handlers::Ruby::Legacy::MethodHandler < ::YARD::Handlers::Ruby::Legacy::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
end

# Handles the 'include' statement to mixin a module in the instance scope
#
class YARD::Handlers::Ruby::Legacy::MixinHandler < ::YARD::Handlers::Ruby::Legacy::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
  private def process_mixin: (untyped mixin) -> untyped
end

# Handles module_function calls to turn methods into public class methods.
# Also creates a private instance copy of the method.
#
class YARD::Handlers::Ruby::Legacy::ModuleFunctionHandler < ::YARD::Handlers::Ruby::Legacy::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
end

# Handles the declaration of a module
#
class YARD::Handlers::Ruby::Legacy::ModuleHandler < ::YARD::Handlers::Ruby::Legacy::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
end

# Sets visibility of a class method to private.
#
class YARD::Handlers::Ruby::Legacy::PrivateClassMethodHandler < ::YARD::Handlers::Ruby::Legacy::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
  private def privatize_class_method: (untyped name) -> untyped
end

# Sets visibility of a constant (class, module, const)
#
class YARD::Handlers::Ruby::Legacy::PrivateConstantHandler < ::YARD::Handlers::Ruby::Legacy::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
  private def privatize_constant: (untyped name) -> untyped
end

# Handles 'private', 'protected', and 'public' calls.
#
class YARD::Handlers::Ruby::Legacy::VisibilityHandler < ::YARD::Handlers::Ruby::Legacy::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
end

# Handles 'yield' calls
#
class YARD::Handlers::Ruby::Legacy::YieldHandler < ::YARD::Handlers::Ruby::Legacy::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
end

class YARD::Handlers::Ruby::MethodCallWrapper < ::YARD::Handlers::Ruby::HandlesExtension
  def matches?: (untyped node) -> bool
end

# Handles a conditional inside a method
class YARD::Handlers::Ruby::MethodConditionHandler < ::YARD::Handlers::Ruby::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
end

# Handles a method definition
class YARD::Handlers::Ruby::MethodHandler < ::YARD::Handlers::Ruby::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
  def format_args: () -> untyped
  # @param [MethodObject] obj
  def add_predicate_return_tag: (YARD::CodeObjects::MethodObject obj) -> untyped
end

# Handles the 'include' statement to mixin a module in the instance scope
class YARD::Handlers::Ruby::MixinHandler < ::YARD::Handlers::Ruby::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
  def process_mixin: (untyped mixin) -> untyped
  def recipient: (untyped mixin) -> untyped
end

# Handles module_function calls to turn methods into public class methods.
# Also creates a private instance copy of the method.
class YARD::Handlers::Ruby::ModuleFunctionHandler < ::YARD::Handlers::Ruby::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
  def make_module_function: (untyped instance_method, untyped namespace) -> untyped
  # @overload process_decorator(*nodes, opts = {}, &block)
  #   Takes care of parsing method definitions passed to decorators
  #   as parameters, as well as parsing chained decorators.
  #
  #   Use this in a handler's process block.
  #
  #   @yieldparam method [YARD::CodeObjects::MethodObject] Method being decorated.
  #   @yieldparam node [YARD::Parser::Ruby::AstNode] AST node of the decorated method.
  #   @yieldparam name [Symbol] Name of the decorated method.
  #   @return [Array<Hash>] Array of hashes containing :method, :node, :name.
  #     See yield params.
  #
  #   @param nodes [YARD::Parser::Ruby::AstNode] AST nodes that refer to decorated
  #     methods, like indexes of statement.parameter. Defaults to all parameters.
  #     Pass nil to specify zero parameters.
  #
  #   @option opts [:instance, :class] :scope (:instance) Scope to use for each
  #     MethodObject.
  #
  #   @option opts [true, false] :transfer_docstring Set false to disable
  #     transferring the decorator docstring to method definitions passed to the
  #     decorator as parameters.
  #
  #   @option opts [true, false] :transfer_source Set false to disable
  #     transferring the decorator source code string to method definitions
  #     passed to the decorator as parameters.
  #
  #   @example Basic Usage
  #     # Simply pass the method docs through to the method definition.
  #     process do
  #       process_decorator
  #     end
  #
  #   @example Setting a method's visibility to private.
  #     process do
  #       process_decorator :scope => :class do |method|
  #         method.visibility = :private if method.respond_to? :visibility
  #       end
  #     end
  def process_decorator: (*untyped nodes) -> untyped
  private def process_decorator_parameter: (untyped node, ?untyped opts) -> untyped
end

# Handles the declaration of a module
class YARD::Handlers::Ruby::ModuleHandler < ::YARD::Handlers::Ruby::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
end

# Sets visibility of a class method to private.
class YARD::Handlers::Ruby::PrivateClassMethodHandler < ::YARD::Handlers::Ruby::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
  # @overload process_decorator(*nodes, opts = {}, &block)
  #   Takes care of parsing method definitions passed to decorators
  #   as parameters, as well as parsing chained decorators.
  #
  #   Use this in a handler's process block.
  #
  #   @yieldparam method [YARD::CodeObjects::MethodObject] Method being decorated.
  #   @yieldparam node [YARD::Parser::Ruby::AstNode] AST node of the decorated method.
  #   @yieldparam name [Symbol] Name of the decorated method.
  #   @return [Array<Hash>] Array of hashes containing :method, :node, :name.
  #     See yield params.
  #
  #   @param nodes [YARD::Parser::Ruby::AstNode] AST nodes that refer to decorated
  #     methods, like indexes of statement.parameter. Defaults to all parameters.
  #     Pass nil to specify zero parameters.
  #
  #   @option opts [:instance, :class] :scope (:instance) Scope to use for each
  #     MethodObject.
  #
  #   @option opts [true, false] :transfer_docstring Set false to disable
  #     transferring the decorator docstring to method definitions passed to the
  #     decorator as parameters.
  #
  #   @option opts [true, false] :transfer_source Set false to disable
  #     transferring the decorator source code string to method definitions
  #     passed to the decorator as parameters.
  #
  #   @example Basic Usage
  #     # Simply pass the method docs through to the method definition.
  #     process do
  #       process_decorator
  #     end
  #
  #   @example Setting a method's visibility to private.
  #     process do
  #       process_decorator :scope => :class do |method|
  #         method.visibility = :private if method.respond_to? :visibility
  #       end
  #     end
  def process_decorator: (*untyped nodes) -> untyped
  private def process_decorator_parameter: (untyped node, ?untyped opts) -> untyped
end

# Sets visibility of a constant (class, module, const)
class YARD::Handlers::Ruby::PrivateConstantHandler < ::YARD::Handlers::Ruby::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
  private def privatize_constant: (untyped node) -> untyped
end

# Sets visibility of a class method to public.
class YARD::Handlers::Ruby::PublicClassMethodHandler < ::YARD::Handlers::Ruby::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
  # @overload process_decorator(*nodes, opts = {}, &block)
  #   Takes care of parsing method definitions passed to decorators
  #   as parameters, as well as parsing chained decorators.
  #
  #   Use this in a handler's process block.
  #
  #   @yieldparam method [YARD::CodeObjects::MethodObject] Method being decorated.
  #   @yieldparam node [YARD::Parser::Ruby::AstNode] AST node of the decorated method.
  #   @yieldparam name [Symbol] Name of the decorated method.
  #   @return [Array<Hash>] Array of hashes containing :method, :node, :name.
  #     See yield params.
  #
  #   @param nodes [YARD::Parser::Ruby::AstNode] AST nodes that refer to decorated
  #     methods, like indexes of statement.parameter. Defaults to all parameters.
  #     Pass nil to specify zero parameters.
  #
  #   @option opts [:instance, :class] :scope (:instance) Scope to use for each
  #     MethodObject.
  #
  #   @option opts [true, false] :transfer_docstring Set false to disable
  #     transferring the decorator docstring to method definitions passed to the
  #     decorator as parameters.
  #
  #   @option opts [true, false] :transfer_source Set false to disable
  #     transferring the decorator source code string to method definitions
  #     passed to the decorator as parameters.
  #
  #   @example Basic Usage
  #     # Simply pass the method docs through to the method definition.
  #     process do
  #       process_decorator
  #     end
  #
  #   @example Setting a method's visibility to private.
  #     process do
  #       process_decorator :scope => :class do |method|
  #         method.visibility = :private if method.respond_to? :visibility
  #       end
  #     end
  def process_decorator: (*untyped nodes) -> untyped
  private def process_decorator_parameter: (untyped node, ?untyped opts) -> untyped
end

# Helper methods to parse @attr_* tags on a class.
#
# @deprecated The use of +@attr+ tags are deprecated since 0.8.0 in favour of
#   the +@!attribute+ directive. This module should not be relied on.
# @since 0.5.6
module YARD::Handlers::Ruby::StructHandlerMethods
  # Extracts the user's defined @member tag for a given class and its member. Returns
  # nil if the user did not define a @member tag for this struct entry.
  #
  # @param [ClassObject] klass the class whose tags we're searching
  # @param [String] member the name of the struct member we need
  # @param [Symbol] type reader method, or writer method?
  # @return [Tags::Tag, nil] the tag matching the request, or nil if not found
  def member_tag_for_member: (YARD::CodeObjects::ClassObject klass, String member, ?Symbol type) -> YARD::Tags::Tag?

  # Retrieves all members defined in @attr* tags
  #
  # @param [ClassObject] klass the class with the attributes
  # @return [Array<String>] the list of members defined as attributes on the class
  def members_from_tags: (YARD::CodeObjects::ClassObject klass) -> Array[String]

  # Determines whether to create an attribute method based on the class's
  # tags.
  #
  # @param [ClassObject] klass the class whose tags we're searching
  # @param [String] member the name of the struct member we need
  # @param [Symbol] type (:read) reader method, or writer method?
  # @return [Boolean] should the attribute be created?
  def create_member_method?: (YARD::CodeObjects::ClassObject klass, String member, ?Symbol type) -> bool

  # Gets the return type for the member in a nicely formatted string. Used
  # to be injected into auto-generated docstrings.
  #
  # @param [Tags::Tag] member_tag the tag object to check for types
  # @return [String] the user-declared type of the struct member, or [Object] if
  #   the user did not define a type for this member.
  def return_type_from_tag: (YARD::Tags::Tag member_tag) -> String

  # Creates the auto-generated docstring for the getter method of a struct's
  # member. This is used so the generated documentation will look just like that
  # of an attribute defined using attr_accessor.
  #
  # @param [ClassObject] klass the class whose members we're working with
  # @param [String] member the name of the member we're generating documentation for
  # @return [String] a docstring to be attached to the getter method for this member
  def add_reader_tags: (YARD::CodeObjects::ClassObject klass, untyped new_method, String member) -> String

  # Creates the auto-generated docstring for the setter method of a struct's
  # member. This is used so the generated documentation will look just like that
  # of an attribute defined using attr_accessor.
  #
  # @param [ClassObject] klass the class whose members we're working with
  # @param [String] member the name of the member we're generating documentation for
  # @return [String] a docstring to be attached to the setter method for this member
  def add_writer_tags: (YARD::CodeObjects::ClassObject klass, untyped new_method, String member) -> String

  # Creates and registers a class object with the given name and superclass name.
  # Returns it for further use.
  #
  # @param [String] classname the name of the class
  # @param [String] superclass the name of the superclass
  # @return [ClassObject] the class object for further processing/method attaching
  def create_class: (String classname, String superclass) -> YARD::CodeObjects::ClassObject

  # Creates the setter (writer) method and attaches it to the class as an attribute.
  # Also sets up the docstring to prettify the documentation output.
  #
  # @param [ClassObject] klass the class to attach the method to
  # @param [String] member the name of the member we're generating a method for
  def create_writer: (YARD::CodeObjects::ClassObject klass, String member) -> untyped

  # Creates the getter (reader) method and attaches it to the class as an attribute.
  # Also sets up the docstring to prettify the documentation output.
  #
  # @param [ClassObject] klass the class to attach the method to
  # @param [String] member the name of the member we're generating a method for
  def create_reader: (YARD::CodeObjects::ClassObject klass, String member) -> untyped

  # Creates the given member methods and attaches them to the given ClassObject.
  #
  # @param [ClassObject] klass the class to generate attributes for
  # @param [Array<String>] members a list of member names
  def create_attributes: (YARD::CodeObjects::ClassObject klass, Array[String] members) -> untyped
end

class YARD::Handlers::Ruby::TestNodeWrapper < ::YARD::Handlers::Ruby::HandlesExtension
  def matches?: (untyped node) -> bool
end

# Handles 'private', 'protected', and 'public' calls.
class YARD::Handlers::Ruby::VisibilityHandler < ::YARD::Handlers::Ruby::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
  # @overload process_decorator(*nodes, opts = {}, &block)
  #   Takes care of parsing method definitions passed to decorators
  #   as parameters, as well as parsing chained decorators.
  #
  #   Use this in a handler's process block.
  #
  #   @yieldparam method [YARD::CodeObjects::MethodObject] Method being decorated.
  #   @yieldparam node [YARD::Parser::Ruby::AstNode] AST node of the decorated method.
  #   @yieldparam name [Symbol] Name of the decorated method.
  #   @return [Array<Hash>] Array of hashes containing :method, :node, :name.
  #     See yield params.
  #
  #   @param nodes [YARD::Parser::Ruby::AstNode] AST nodes that refer to decorated
  #     methods, like indexes of statement.parameter. Defaults to all parameters.
  #     Pass nil to specify zero parameters.
  #
  #   @option opts [:instance, :class] :scope (:instance) Scope to use for each
  #     MethodObject.
  #
  #   @option opts [true, false] :transfer_docstring Set false to disable
  #     transferring the decorator docstring to method definitions passed to the
  #     decorator as parameters.
  #
  #   @option opts [true, false] :transfer_source Set false to disable
  #     transferring the decorator source code string to method definitions
  #     passed to the decorator as parameters.
  #
  #   @example Basic Usage
  #     # Simply pass the method docs through to the method definition.
  #     process do
  #       process_decorator
  #     end
  #
  #   @example Setting a method's visibility to private.
  #     process do
  #       process_decorator :scope => :class do |method|
  #         method.visibility = :private if method.respond_to? :visibility
  #       end
  #     end
  def process_decorator: (*untyped nodes) -> untyped
  private def process_decorator_parameter: (untyped node, ?untyped opts) -> untyped
end

# Handles 'yield' calls
class YARD::Handlers::Ruby::YieldHandler < ::YARD::Handlers::Ruby::Base
  #
  # @!method process
  # Main processing callback
  # @return [void]
  def process: () -> void
end
