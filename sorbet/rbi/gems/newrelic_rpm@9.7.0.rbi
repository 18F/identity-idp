# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `newrelic_rpm` gem.
# Please instead update this file by running `bin/tapioca gem newrelic_rpm`.


# source://newrelic_rpm//lib/new_relic/dependency_detection.rb#5
module DependencyDetection
  private

  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#10
  def defer(&block); end

  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#36
  def dependency_by_name(name); end

  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#26
  def detect!; end

  class << self
    # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#10
    def defer(&block); end

    # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#36
    def dependency_by_name(name); end

    # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#26
    def detect!; end
  end
end

# source://newrelic_rpm//lib/new_relic/dependency_detection.rb#40
class DependencyDetection::Dependent
  # @return [Dependent] a new instance of Dependent
  #
  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#55
  def initialize; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#138
  def allowed_by_config?; end

  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#169
  def auto_configured?; end

  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#169
  def chain_configured?; end

  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#95
  def chain_instrument(instrumenting_module, supportability_name = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#101
  def chain_instrument_target(target, instrumenting_module, supportability_name = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#121
  def check_dependencies; end

  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#159
  def config_key; end

  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#51
  def config_name; end

  # Sets the attribute config_name
  #
  # @param value the value to set the attribute config_name to.
  #
  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#43
  def config_name=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#197
  def config_value; end

  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#67
  def configure_as_unsatisfied; end

  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#207
  def configure_with(new_config_name); end

  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#215
  def conflicts_with_prepend(&block); end

  # Returns the value of attribute dependencies.
  #
  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#44
  def dependencies; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#63
  def dependencies_satisfied?; end

  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#134
  def depends_on(&block); end

  # TODO: MAJOR VERSION
  # will only return true if a disabled key is found and is truthy
  #
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#144
  def deprecated_disabled_configured?; end

  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#169
  def disabled_configured?; end

  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#108
  def execute; end

  # Returns the value of attribute executed.
  #
  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#41
  def executed; end

  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#47
  def executed!; end

  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#211
  def executes(&block); end

  # Extracts the instrumented library name from the instrumenting module's name
  # Given "NewRelic::Agent::Instrumentation::NetHTTP::Prepend"
  # Will extract "NetHTTP" which is in the 2nd to last spot
  #
  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#78
  def extract_supportability_name(instrumenting_module); end

  # fetches and transform potentially invalid value given to one of the valid config values
  # logs the resolved value during debug mode.
  #
  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#182
  def fetch_config_value(key); end

  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#82
  def log_and_instrument(method, instrumenting_module, supportability_name); end

  # Returns the value of attribute name.
  #
  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#42
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#42
  def name=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#203
  def named(new_name); end

  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#169
  def prepend_configured?; end

  # Returns the value of attribute prepend_conflicts.
  #
  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#45
  def prepend_conflicts; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#223
  def prepend_conflicts?; end

  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#89
  def prepend_instrument(target_class, instrumenting_module, supportability_name = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#71
  def source_location_for(klass, method_name); end

  # update any :auto config value to be either :prepend or :chain after auto
  # determination has selected one of those to use
  #
  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#190
  def update_config_value(use_prepend); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#219
  def use_prepend?; end

  # returns only a valid value for instrumentation configuration
  # If user uses "enabled" it's converted to "auto"
  #
  # source://newrelic_rpm//lib/new_relic/dependency_detection.rb#176
  def valid_config_value(retrieved_value); end
end

# source://newrelic_rpm//lib/new_relic/dependency_detection.rb#166
DependencyDetection::Dependent::AUTO_CONFIG_VALUE = T.let(T.unsafe(nil), Symbol)

# source://newrelic_rpm//lib/new_relic/dependency_detection.rb#165
DependencyDetection::Dependent::VALID_CONFIG_VALUES = T.let(T.unsafe(nil), Array)

# source://newrelic_rpm//lib/new_relic/version.rb#6
module NewRelic; end

# source://newrelic_rpm//lib/new_relic/constants.rb#6
NewRelic::ASTERISK = T.let(T.unsafe(nil), String)

# This module contains most of the public API methods for the Ruby Agent.
#
# For adding custom instrumentation to method invocations, see
# the docs for {NewRelic::Agent::MethodTracer} and
# {NewRelic::Agent::MethodTracer::ClassMethods}.
#
# For information on how to trace transactions in non-Rack contexts,
# see {NewRelic::Agent::Instrumentation::ControllerInstrumentation}.
#
# For general documentation about the Ruby agent, see:
# https://docs.newrelic.com/docs/agents/ruby-agent
#
# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/null_logger.rb#8
module NewRelic::Agent
  extend ::NewRelic::Agent
  extend ::Forwardable
  extend ::NewRelic::SupportabilityHelper

  # Add attributes to the transaction trace, Insights Transaction event, and
  # any traced errors recorded for the current transaction.
  #
  # If Browser Monitoring is enabled, and the
  # browser_monitoring.attributes.enabled configuration setting is true,
  # these custom attributes will also be present in the script injected into
  # the response body, making them available on Insights PageView events.
  #
  # @api public
  # @param params [Hash] A Hash of attributes to be attached to the transaction event.
  #   Keys should be strings or symbols, and values
  #   may be strings, symbols, numeric values or
  #   booleans.
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#618
  def add_custom_attributes(params); end

  # Add global custom attributes to log events for the current agent instance. As these attributes are global to the
  # agent instance, they will be attached to all log events generated by the agent, and this methods usage isn't
  # suitable for setting dynamic values.
  #
  # @api public
  # @param params [Hash] A Hash of attributes to attach to log
  #   events. The agent accepts up to 240 custom
  #   log event attributes.
  #
  #   Keys will be coerced into Strings and must
  #   be less than 256 characters. Keys longer
  #   than 255 characters will be truncated.
  #
  #   Values may be Strings, Symbols, numeric
  #   values or Booleans and must be less than
  #   4095 characters. If the value is a String
  #   or a Symbol, values longer than 4094
  #   characters will be truncated. If the value
  #   exceeds 4094 characters and is of a
  #   different class, the attribute pair will
  #   be dropped.
  #
  #   This API can be called multiple times.
  #   If the same key is passed more than once,
  #   the value associated with the last call
  #   will be preserved.
  #
  #   Attribute pairs with empty or nil contents
  #   will be dropped.
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#695
  def add_custom_log_attributes(params); end

  # Add custom attributes to the span event for the current span. Attributes will be visible on spans in the
  # New Relic Distributed Tracing UI and on span events in New Relic Insights.
  #
  # Custom attributes will not be transmitted when +high_security+ setting is enabled or
  # +custom_attributes+ setting is disabled.
  #
  # @api public
  # @param params [Hash] A Hash of attributes to be attached to the span event.
  #   Keys should be strings or symbols, and values
  #   may be strings, symbols, numeric values or
  #   booleans.
  # @see https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/glossary#span
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#654
  def add_custom_span_attributes(params); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#160
  def add_deferred_method_tracers_now; end

  # Add instrumentation files to the agent.  The argument should be
  # a glob matching ruby scripts which will be executed at the time
  # instrumentation is loaded.  Since instrumentation is not loaded
  # when the agent is not running it's better to use this method to
  # register instrumentation than just loading the files directly,
  # although that probably also works.
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#480
  def add_instrumentation(file_pattern); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#633
  def add_new_segment_attributes(params, segment); end

  # A third-party class may call add_method_tracer before the agent
  # is initialized; these methods enable us to defer these calls
  # until we have started up and can process them.
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#148
  def add_or_defer_method_tracer(receiver, method_name, metric_name, options); end

  # Register this method as a callback for processes that fork
  # jobs.
  #
  # If the master/parent connects to the agent prior to forking the
  # agent in the forked process will use that agent_run.  Otherwise
  # the forked process will establish a new connection with the
  # server.
  #
  # Use this especially when you fork the process to run background
  # jobs or other work.  If you are doing this with a web dispatcher
  # that forks worker processes then you will need to force the
  # agent to reconnect, which it won't do by default.  Passenger and
  # Unicorn are already handled, nothing special needed for them.
  #
  # Options:
  # * <tt>:force_reconnect => true</tt> to force the spawned process to
  #   establish a new connection, such as when forking a long running process.
  #   The default is false--it will only connect to the server if the parent
  #   had not connected.
  # * <tt>:keep_retrying => false</tt> if we try to initiate a new
  #   connection, this tells me to only try it once so this method returns
  #   quickly if there is some kind of latency with the server.
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#443
  def after_fork(options = T.unsafe(nil)); end

  # The singleton Agent instance.  Used internally.
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#119
  def agent; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#127
  def agent=(new_instance); end

  # see ActiveSupport::Inflector.demodulize
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#222
  def base_name(klass_name); end

  # This method returns a string suitable for inclusion in a page - known as
  # 'manual instrumentation' for Real User Monitoring. Can return either a
  # script tag with associated javascript, or in the case of disabled Real
  # User Monitoring, an empty string
  #
  # This is the header string - it should be placed as high in the page as is
  # reasonably possible - that is, before any style or javascript inclusions,
  # but after any header-related meta tags
  #
  # In previous agents there was a corresponding footer required, but all the
  # work is now done by this single method.
  #
  # @api public
  # @param nonce [String] The nonce to use in the javascript tag for browser instrumentation
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#861
  def browser_timing_header(nonce = T.unsafe(nil)); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#170
  def config; end

  # Yield to the block without collecting any metrics or traces in
  # any of the subsequent calls.  If executed recursively, will keep
  # track of the first entry point and turn on tracing again after
  # leaving that block.  This uses the thread local Tracer::State.
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#556
  def disable_all_tracing; end

  # This method sets the state of sql recording in the transaction
  # sampler feature. Within the given block, no sql will be recorded
  #
  # usage:
  #
  #   NewRelic::Agent.disable_sql_recording do
  #     ...
  #   end
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#580
  def disable_sql_recording; end

  # Clear out any data the agent has buffered but has not yet transmitted
  # to the collector.
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#465
  def drop_buffered_data; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#109
  def error_group_callback; end

  # Get the name of the current running transaction.  This is useful if you
  # want to modify the default name.
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#764
  def get_transaction_name; end

  # This method disables the recording of Apdex metrics in the current
  # transaction.
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#534
  def ignore_apdex; end

  # This method disables browser monitoring javascript injection in the
  # current transaction.
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#544
  def ignore_enduser; end

  # Set a filter to be applied to errors that the Ruby agent will
  # track.  The block should evaluate to the exception to track
  # (which could be different from the original exception) or nil to
  # ignore this exception.
  #
  # The block is yielded to with the exception to filter.
  #
  # Return the new block or the existing filter Proc if no block is passed.
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#266
  def ignore_error_filter(&block); end

  # This method disables the recording of the current transaction. No metrics,
  # traced errors, transaction traces, Insights events, slow SQL traces,
  # or RUM injection will happen for this transaction.
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#524
  def ignore_transaction; end

  # Increment a simple counter metric.
  #
  # +metric_name+ should follow a slash separated path convention. Application
  # specific metrics should begin with "Custom/".
  #
  # This method is safe to use from any thread.
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#239
  def increment_metric(metric_name, amount = T.unsafe(nil)); end

  # The singleton Agent instance.  Used internally.
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#119
  def instance; end

  # Returns a new hash containing trace and entity metadata that can be used
  # to relate data to a trace or to an entity in APM.
  #
  # This hash includes:
  # * trace.id    - The current trace id, if there is a current trace id. This
  #   value may be omitted.
  # * span.id     - The current span id, if there is a current span.  This
  #   value may be omitted.
  # * entity.name - The name of the current application. This is read from
  #   the +app_name+ key in your config.  If there are multiple application
  #   names, the first one is used.
  # * entity.type - The entity type is hardcoded to the string +'SERVICE'+.
  # * entity.guid - The guid of the current entity.
  # * hostname    - The fully qualified hostname.
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#834
  def linking_metadata; end

  # Primary interface to logging is fronted by this accessor
  # Access via ::NewRelic::Agent.logger
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#136
  def logger; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#140
  def logger=(log); end

  # Call this to manually start the agent in situations where the agent does
  # not auto-start.
  #
  # When the app environment loads, so does the agent. However, the
  # agent will only connect to the service if a web front-end is found. If
  # you want to selectively monitor ruby processes that don't use
  # web plugins, then call this method in your code and the agent
  # will fire up and start reporting to the service.
  #
  # Options are passed in as overrides for values in the
  # newrelic.yml, such as app_name.  In addition, the option +log+
  # will take a logger that will be used instead of the standard
  # file logger.  The setting for the newrelic.yml section to use
  # (ie, RAILS_ENV) can be overridden with an :env argument.
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#411
  def manual_start(options = T.unsafe(nil)); end

  # Send an error to New Relic.
  #
  # Any option keys other than the ones listed here are treated as
  # <code>:custom_params</code>.
  #
  # *Note:* Previous versions of the agent allowed passing
  # <code>:request_params</code>, but those are now ignored.  If you
  # need to record the request parameters, call this method inside a
  # transaction or pass the information in
  # <code>:custom_params</code>.
  #
  # Most of the time, you do not need to specify the
  # <code>:uri</code> or <code>:metric</code> options; only pass
  # them if you are calling <code>notice_error</code> outside a
  # transaction.
  #
  # @api public
  # @option options
  # @option options
  # @option options
  # @option options
  # @param exception [Exception] Error you wish to send
  # @param options [Hash] Modify how New Relic processes the error
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#304
  def notice_error(exception, options = T.unsafe(nil)); end

  # Fire an event of the specified +event_type+, passing it an the given +args+
  # to any registered handlers.
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#801
  def notify(event_type, *args); end

  # Record a custom event to be sent to New Relic Insights.
  # The recorded event will be buffered in memory until the next time the
  # agent sends data to New Relic's servers.
  #
  # If you want to be able to tie the information recorded via this call back
  # to the web request or background job that it happened in, you may want to
  # instead use the add_custom_attributes API call to attach attributes to
  # the Transaction event that will automatically be generated for the
  # request.
  #
  # A timestamp will be automatically added to the recorded event when this
  # method is called.
  #
  # @api public
  # @param event_type [Symbol or String] The name of the event type to record. Event
  #   types must consist of only alphanumeric
  #   characters, '_', ':', or ' '.
  # @param event_attrs [Hash] A Hash of attributes to be attached to the event.
  #   Keys should be strings or symbols, and values
  #   may be strings, symbols, numeric values or
  #   booleans.
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#380
  def record_custom_event(event_type, event_attrs); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#217
  def record_instrumentation_invocation(library); end

  # Record a value for the given metric name.
  #
  # This method should be used to record event-based metrics such as method
  # calls that are associated with a specific duration or magnitude.
  #
  # +metric_name+ should follow a slash separated path convention. Application
  # specific metrics should begin with "Custom/".
  #
  # +value+ should be either a single Numeric value representing the duration/
  # magnitude of the event being recorded, or a Hash containing :count,
  # :total, :min, :max, and :sum_of_squares keys. The latter form is useful
  # for recording pre-aggregated metrics collected externally.
  #
  # This method is safe to use from any thread.
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#198
  def record_metric(metric_name, value); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#211
  def record_metric_once(metric_name, value = T.unsafe(nil)); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def register_report_channel(*args, **_arg1, &block); end

  # Require agent testing helper methods
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#488
  def require_test_helper; end

  # For testing
  # Important that we don't change the instance or we orphan callbacks
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#176
  def reset_config; end

  # Set a callback proc for determining an error's error group name
  #
  # Typically this method should be called only once to set a callback for
  # use with all noticed errors. If it is called multiple times, each new
  # callback given will replace the old one.
  #
  # The proc will be called with a single hash as its input argument and is
  # expected to return a string representing the desired error group.
  #
  # see https://docs.newrelic.com/docs/errors-inbox/errors-inbox/#groups
  #
  # The hash passed to the customer defined callback proc has the following
  # keys:
  #
  # :error => The Ruby error class instance, likely inheriting from
  #           StandardError. Call `#class`, `#message`, and `#backtrace` on
  #           the error object to retrieve the error's class, message, and
  #           backtrace.
  # :customAttributes => Any customer defined custom attributes that have been
  #                      associated with the current transaction.
  # :'request.uri' => The current request URI if available
  # :'http.statusCode' => The HTTP status code (200, 404, etc.) if available
  # :'http.method' => The HTTP method (GET, PUT, etc.) if available
  # :'error.expected' => Whether (true) or not (false) the error was expected
  # :options => The options hash passed to `NewRelic::Agent.notice_error`
  #
  # @api public
  # @param callback_proc [Proc] the callback proc
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#341
  def set_error_group_callback(callback_proc); end

  # This method sets the block sent to this method as a sql
  # obfuscator.  The block will be called with a single String SQL
  # statement to obfuscate.  The method must return the obfuscated
  # String SQL.  If chaining of obfuscators is required, use type =
  # :before or :after
  #
  # type = :before, :replace, :after
  #
  # Example:
  #
  #    NewRelic::Agent.set_sql_obfuscator(:replace) do |sql|
  #       my_obfuscator(sql)
  #    end
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#509
  def set_sql_obfuscator(type = T.unsafe(nil), &block); end

  # Set the name of the current running transaction.  The agent will
  # apply a reasonable default based on framework routing, but in
  # cases where this is insufficient, this can be used to manually
  # control the name of the transaction.
  #
  # The category of transaction can be specified via the +:category+ option.
  # The following are the only valid categories:
  #
  # * <tt>:category => :controller</tt> indicates that this is a
  #   controller action and will appear with all the other actions.
  # * <tt>:category => :task</tt> indicates that this is a
  #   background task and will show up in New Relic with other background
  #   tasks instead of in the controllers list
  # * <tt>:category => :middleware</tt> if you are instrumenting a rack
  #   middleware call.  The <tt>:name</tt> is optional, useful if you
  #   have more than one potential transaction in the #call.
  # * <tt>:category => :uri</tt> indicates that this is a
  #   web transaction whose name is a normalized URI, where  'normalized'
  #   means the URI does not have any elements with data in them such
  #   as in many REST URIs.
  #
  # The default category is the same as the running transaction.
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#754
  def set_transaction_name(name, options = T.unsafe(nil)); end

  # Set the user id for the current transaction. When present, this value will be included in the agent attributes for transaction and error events as 'enduser.id'.
  #
  # @api public
  # @param user_id [String] The user id to add to the current transaction attributes
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#710
  def set_user_id(user_id); end

  # Shutdown the agent.  Call this before exiting.  Sends any queued data
  # and kills the background thread.
  #
  # @api public
  # @param options [Hash] Unused options Hash, for back compatibility only
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#456
  def shutdown(options = T.unsafe(nil)); end

  # Subscribe to events of +event_type+, calling the given +handler+
  # when one is sent.
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#795
  def subscribe(event_type, &handler); end

  # Check to see if we are capturing metrics currently on this thread.
  #
  # @api public
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#596
  def tl_is_execution_traced?; end

  # Yield to a block that is run with a database metric name context.  This means
  # the Database instrumentation will use this for the metric name if it does not
  # otherwise know about a model.  This is reentrant.
  #
  # identify the operation with.
  #
  # @api public
  # @param model [String, Class, #to_s] the DB model class
  # @param method [String] the name of the finder method or other method to
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#785
  def with_database_metric_name(model, method = T.unsafe(nil), product = T.unsafe(nil), &block); end
end

# source://newrelic_rpm//lib/new_relic/agent/adaptive_sampler.rb#7
class NewRelic::Agent::AdaptiveSampler
  # @return [AdaptiveSampler] a new instance of AdaptiveSampler
  #
  # source://newrelic_rpm//lib/new_relic/agent/adaptive_sampler.rb#8
  def initialize(target_samples = T.unsafe(nil), period_duration = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/adaptive_sampler.rb#42
  def exponential_backoff; end

  # Called at the beginning of each transaction, increments seen and
  # returns a boolean indicating if we should mark the transaction as
  # sampled. This uses the adaptive sampling algorithm.
  #
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/adaptive_sampler.rb#23
  def sampled?; end

  # source://newrelic_rpm//lib/new_relic/agent/adaptive_sampler.rb#46
  def stats; end

  private

  # source://newrelic_rpm//lib/new_relic/agent/adaptive_sampler.rb#72
  def register_config_callbacks; end

  # source://newrelic_rpm//lib/new_relic/agent/adaptive_sampler.rb#92
  def register_sampling_period_callback; end

  # source://newrelic_rpm//lib/new_relic/agent/adaptive_sampler.rb#77
  def register_sampling_target_callback; end

  # source://newrelic_rpm//lib/new_relic/agent/adaptive_sampler.rb#59
  def reset_if_period_expired!; end
end

# The agent is a singleton that is instantiated when the plugin is
# activated.  It collects performance data from ruby applications
# in realtime as the application runs, and periodically sends that
# data to the NewRelic server.
#
# source://newrelic_rpm//lib/new_relic/agent/agent.rb#54
class NewRelic::Agent::Agent
  include ::NewRelic::Agent::AgentHelpers::Connect
  include ::NewRelic::Agent::AgentHelpers::Harvest
  include ::NewRelic::Agent::AgentHelpers::StartWorkerThread
  include ::NewRelic::Agent::AgentHelpers::SpecialStartup
  include ::NewRelic::Agent::AgentHelpers::Startup
  include ::NewRelic::Agent::AgentHelpers::Shutdown
  include ::NewRelic::Agent::AgentHelpers::Transmit
  include ::NewRelic::Agent::Agent::InstanceMethods
  extend ::NewRelic::Agent::Agent::ClassMethods

  # @return [Agent] a new instance of Agent
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#67
  def initialize; end

  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#124
  def refresh_attribute_filter; end

  private

  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#76
  def init_basics; end

  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#89
  def init_components; end

  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#101
  def init_event_handlers; end

  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#114
  def setup_attribute_filter; end

  class << self
    # source://newrelic_rpm//lib/new_relic/agent/agent.rb#55
    def config; end
  end
end

# contains all the class-level methods for NewRelic::Agent::Agent
#
# source://newrelic_rpm//lib/new_relic/agent/agent.rb#129
module NewRelic::Agent::Agent::ClassMethods
  # Should only be called by NewRelic::Control - returns a
  # memoized singleton instance of the agent, creating one if needed
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#132
  def instance; end
end

# Holds all the methods defined on NewRelic::Agent::Agent
# instances
#
# source://newrelic_rpm//lib/new_relic/agent/agent.rb#139
module NewRelic::Agent::Agent::InstanceMethods
  # Returns the value of attribute adaptive_sampler.
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#174
  def adaptive_sampler; end

  # This method should be called in a forked process after a fork.
  # It assumes the parent process initialized the agent, but does
  # not assume the agent started.
  #
  # The call is idempotent, but not reentrant.
  #
  # * It clears any metrics carried over from the parent process
  # * Restarts the sampler thread if necessary
  # * Initiates a new agent run and worker loop unless that was done
  #   in the parent process and +:force_reconnect+ is not true
  #
  # Options:
  # * <tt>:force_reconnect => true</tt> to force the spawned process to
  #   establish a new connection, such as when forking a long running process.
  #   The default is false--it will only connect to the server if the parent
  #   had not connected.
  # * <tt>:keep_retrying => false</tt> if we try to initiate a new
  #   connection, this tells me to only try it once so this method returns
  #   quickly if there is some kind of latency with the server.
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#207
  def after_fork(options = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#184
  def agent_id=(agent_id); end

  # Returns the value of attribute attribute_filter.
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#173
  def attribute_filter; end

  # cross application tracing ids and encoding
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#152
  def cross_process_id; end

  # Returns the value of attribute custom_event_aggregator.
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#169
  def custom_event_aggregator; end

  # Clear out the metric data, errors, and transaction traces, etc.
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#288
  def drop_buffered_data; end

  # error collector is a simple collection of recorded errors
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#146
  def error_collector; end

  # Global events dispatcher. This will provides our primary mechanism
  # for agent-wide events, such as finishing configuration, error notification
  # and request before/after from Rack.
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#158
  def events; end

  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#310
  def flush_pipe_data; end

  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#238
  def install_pipe_service(channel_id); end

  # builder for JS agent scripts to inject
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#150
  def javascript_instrumentor; end

  # Returns the value of attribute log_event_aggregator.
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#171
  def log_event_aggregator; end

  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#337
  def merge_data_for_endpoint(endpoint, data); end

  # listens and responds to events that need to process headers
  # for synthetics and distributed tracing
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#162
  def monitors; end

  # GC::Profiler.total_time is not monotonic so we wrap it.
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#168
  def monotonic_gc_profiler; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#222
  def needs_after_fork_work?; end

  # Pop the current trace execution status.  Restore trace execution status
  # to what it was before we pushed the current flag.
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#283
  def pop_trace_execution_flag; end

  # Push flag indicating whether we should be tracing in this
  # thread. This uses a stack which allows us to disable tracing
  # children of a transaction without affecting the tracing of
  # the whole transaction
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#277
  def push_trace_execution_flag(should_trace = T.unsafe(nil)); end

  # whether we should record raw, obfuscated, or no sql
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#148
  def record_sql; end

  # Clear out state for any objects that we know lock from our parents
  # This is necessary for cases where we're in a forked child and Ruby
  # might be holding locks for background thread that aren't there anymore.
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#306
  def reset_objects_with_locks; end

  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#249
  def revert_to_default_configuration; end

  # service for communicating with collector
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#154
  def service; end

  # Sets a thread local variable as to whether we should or
  # should not record sql in the current thread. Returns the
  # previous value, if there is one
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#266
  def set_record_sql(should_record); end

  # Returns the value of attribute span_event_aggregator.
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#170
  def span_event_aggregator; end

  # Returns the value of attribute sql_sampler.
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#144
  def sql_sampler; end

  # the statistics engine that holds all the timeslice data
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#141
  def stats_engine; end

  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#180
  def synthetics_event_aggregator; end

  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#176
  def transaction_event_aggregator; end

  # Returns the value of attribute transaction_event_recorder.
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#172
  def transaction_event_recorder; end

  # Transaction and metric renaming rules as provided by the
  # collector on connect.  The former are applied during txns,
  # the latter during harvest.
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#166
  def transaction_rules; end

  # Transaction and metric renaming rules as provided by the
  # collector on connect.  The former are applied during txns,
  # the latter during harvest.
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#166
  def transaction_rules=(_arg0); end

  # the transaction sampler that handles recording transactions
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#143
  def transaction_sampler; end

  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#254
  def trap_signals_for_litespeed; end

  private

  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#323
  def container_for_endpoint(endpoint); end

  # A shorthand for NewRelic::Control.instance
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent.rb#319
  def control; end
end

# source://newrelic_rpm//lib/new_relic/agent/agent_helpers/connect.rb#7
module NewRelic::Agent::AgentHelpers; end

# This module is an artifact of a refactoring of the connect
# method - all of its methods are used in that context, so it
# can be refactored at will. It should be fully tested
#
# source://newrelic_rpm//lib/new_relic/agent/agent_helpers/connect.rb#11
module NewRelic::Agent::AgentHelpers::Connect
  # Establish a connection to New Relic servers.
  #
  # By default, if a connection has already been established, this method
  # will be a no-op.
  #
  # @option options
  # @option options
  # @param options [Hash]
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/connect.rb#183
  def connect(options = T.unsafe(nil)); end

  # number of attempts we've made to contact the server
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/connect.rb#13
  def connect_attempts; end

  # number of attempts we've made to contact the server
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/connect.rb#13
  def connect_attempts=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/connect.rb#158
  def connect_options(options); end

  # Per the spec at
  # /agents/agent-specs/Collector-Response-Handling.md, retry
  # connections after a specific backoff sequence to prevent
  # hammering the server.
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/connect.rb#41
  def connect_retry_period; end

  # Builds the payload to send to the connect service,
  # connects, then configures the agent using the response from
  # the connect service
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/connect.rb#96
  def connect_to_server; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/connect.rb#22
  def connected?; end

  # Disconnect just sets the connect state to disconnected, preventing
  # further retries.
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/connect.rb#17
  def disconnect; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/connect.rb#26
  def disconnected?; end

  # Checks whether we should send environment info, and if so,
  # returns the snapshot from the local environment.
  # Generating the EnvironmentReport has the potential to trigger
  # require calls in Rails environments, so this method should only
  # be called synchronously from on the main thread.
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/connect.rb#83
  def environment_for_connect; end

  # Constructs and memoizes an event_harvest_config hash to be used in
  # the payload sent during connect (and reconnect)
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/connect.rb#89
  def event_harvest_config; end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/connect.rb#64
  def handle_license_error(error); end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/connect.rb#72
  def handle_unrecoverable_agent_error(error); end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/connect.rb#123
  def log_collector_messages(messages); end

  # Logs when we connect to the server, for debugging purposes
  # - makes sure we know if an agent has not connected
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/connect.rb#114
  def log_connection(config_data); end

  # When we have a problem connecting to the server, we need
  # to tell the user what happened, since this is not an error
  # we can handle gracefully.
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/connect.rb#52
  def log_error(error); end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/connect.rb#45
  def note_connect_failure; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/connect.rb#206
  def retry_from_error?(e, opts); end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/connect.rb#33
  def should_connect?(force = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/connect.rb#137
  def signal_connected; end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/connect.rb#143
  def wait_on_connect(timeout); end

  # Used for testing to let us know we've actually started to wait
  #
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/connect.rb#133
  def waited_on_connect?; end
end

# source://newrelic_rpm//lib/new_relic/agent/agent_helpers/connect.rb#129
class NewRelic::Agent::AgentHelpers::Connect::WaitOnConnectTimeout < ::StandardError; end

# source://newrelic_rpm//lib/new_relic/agent/agent_helpers/harvest.rb#8
module NewRelic::Agent::AgentHelpers::Harvest
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/harvest.rb#130
  def check_for_and_handle_agent_commands; end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/harvest.rb#81
  def harvest_and_send_analytic_event_data; end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/harvest.rb#86
  def harvest_and_send_custom_event_data; end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/harvest.rb#102
  def harvest_and_send_data_types; end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/harvest.rb#90
  def harvest_and_send_error_event_data; end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/harvest.rb#77
  def harvest_and_send_errors; end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/harvest.rb#73
  def harvest_and_send_for_agent_commands; end

  # Harvests data from the given container, sends it to the named endpoint
  # on the service, and automatically merges back in upon a recoverable
  # failure.
  #
  # The given container should respond to:
  #
  #  #harvest!
  #    returns a payload that contains enumerable collection of data items and
  #    optional metadata to be sent to the collector.
  #
  #  #reset!
  #    drop any stored data and reset to a clean state.
  #
  #  #merge!(payload)
  #    merge the given payload back into the internal buffer of the
  #    container, so that it may be harvested again later.
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/harvest.rb#26
  def harvest_and_send_from_container(container, endpoint); end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/harvest.rb#98
  def harvest_and_send_log_event_data; end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/harvest.rb#59
  def harvest_and_send_slowest_sql; end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/harvest.rb#94
  def harvest_and_send_span_event_data; end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/harvest.rb#54
  def harvest_and_send_timeslice_data; end

  # This handles getting the transaction traces and then sending
  # them across the wire.  This includes gathering SQL
  # explanations, stripping out stack traces, and normalizing
  # SQL.  note that we explain only the sql statements whose
  # nodes' execution times exceed our threshold (to avoid
  # unnecessary overhead of running explains on fast queries.)
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/harvest.rb#69
  def harvest_and_send_transaction_traces; end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/harvest.rb#43
  def harvest_from_container(container, endpoint); end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/harvest.rb#35
  def harvest_size(container, items); end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/harvest.rb#145
  def log_remote_unavailable(endpoint, e); end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/harvest.rb#112
  def send_data_to_endpoint(endpoint, payload, container); end
end

# source://newrelic_rpm//lib/new_relic/agent/agent_helpers/shutdown.rb#8
module NewRelic::Agent::AgentHelpers::Shutdown
  # This method contacts the server to send remaining data and
  # let the server know that the agent is shutting down - this
  # allows us to do things like accurately set the end of the
  # lifetime of the process
  #
  # If this process comes from a parent process, it will not
  # disconnect, so that the parent process can continue to send data
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/shutdown.rb#42
  def graceful_disconnect; end

  # Attempt a graceful shutdown of the agent, flushing any remaining
  # data.
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/shutdown.rb#11
  def shutdown; end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/shutdown.rb#60
  def shutdown_service; end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/shutdown.rb#25
  def untraced_graceful_disconnect; end
end

# source://newrelic_rpm//lib/new_relic/agent/agent_helpers/special_startup.rb#8
module NewRelic::Agent::AgentHelpers::SpecialStartup
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/special_startup.rb#35
  def defer_for_delayed_job?; end

  # Return true if we're using resque and it hasn't had a chance to (potentially)
  # daemonize itself. This avoids hanging when there's a Thread started
  # before Resque calls Process.daemon (Jira RUBY-857)
  #
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/special_startup.rb#25
  def defer_for_resque?; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/special_startup.rb#31
  def in_resque_child_process?; end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/special_startup.rb#65
  def install_exit_handler; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/special_startup.rb#59
  def should_install_exit_handler?; end

  # This matters when the following three criteria are met:
  #
  # 1. A Sinatra 'classic' application is being run
  # 2. The app is being run by executing the main file directly, rather
  #    than via a config.ru file.
  # 3. newrelic_rpm is required *after* sinatra
  #
  # In this case, the entire application runs from an at_exit handler in
  # Sinatra, and if we were to install ours, it would be executed before
  # the one in Sinatra, meaning that we'd shutdown the agent too early
  # and never collect any data.
  #
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/special_startup.rb#51
  def sinatra_classic_app?; end

  # If we're using a dispatcher that forks before serving
  # requests, we need to wait until the children are forked
  # before connecting, otherwise the parent process sends useless data
  #
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/special_startup.rb#12
  def using_forking_dispatcher?; end
end

# source://newrelic_rpm//lib/new_relic/agent/agent_helpers/start_worker_thread.rb#8
module NewRelic::Agent::AgentHelpers::StartWorkerThread
  # a wrapper method to handle all the errors that can happen
  # in the connection and worker thread system. This
  # guarantees a no-throw from the background thread.
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/start_worker_thread.rb#108
  def catch_errors; end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/start_worker_thread.rb#62
  def create_and_run_event_loop; end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/start_worker_thread.rb#33
  def create_event_loop; end

  # This is the method that is run in a new thread in order to
  # background the harvesting and sending of data during the
  # normal operation of the agent.
  #
  # Takes connection options that determine how we should
  # connect to the server, and loops endlessly - typically we
  # never return from this method unless we're shutting down
  # the agent
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/start_worker_thread.rb#127
  def deferred_work!(connection_options); end

  # when a disconnect is requested, stop the current thread, which
  # is the worker thread that gathers data and talks to the
  # server.
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/start_worker_thread.rb#88
  def handle_force_disconnect(error); end

  # Handles the case where the server tells us to restart -
  # this clears the data, clears connection attempts, and
  # waits a while to reconnect.
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/start_worker_thread.rb#77
  def handle_force_restart(error); end

  # Handles an unknown error in the worker thread by logging
  # it and disconnecting the agent, since we are now in an
  # unknown state.
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/start_worker_thread.rb#97
  def handle_other_error(error); end

  # Certain event types may sometimes need to be on the same interval as metrics,
  # so we will check config assigned in EventHarvestConfig to determine the interval
  # on which to report them
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/start_worker_thread.rb#57
  def interval_for(event_type); end

  # Try to launch the worker thread and connect to the server.
  #
  # See #connect for a description of connection_options.
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/start_worker_thread.rb#20
  def start_worker_thread(connection_options = T.unsafe(nil)); end

  # If the @worker_thread encounters an error during the attempt to connect to the collector
  # then the connect attempts enter an exponential backoff retry loop.  To avoid potential
  # race conditions with shutting down while also attempting to reconnect, we join the
  # pending data to the server, but without waiting indefinitely for a reconnect to succeed.
  # The use-case where this typically arises is in cronjob scheduled rake tasks where there's
  # also some network stability/latency issues happening.
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/start_worker_thread.rb#44
  def stop_event_loop; end

  private

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/start_worker_thread.rb#162
  def establish_fire_everies(data_harvest); end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/start_worker_thread.rb#144
  def establish_interval_transmissions; end
end

# source://newrelic_rpm//lib/new_relic/agent/agent_helpers/start_worker_thread.rb#12
NewRelic::Agent::AgentHelpers::StartWorkerThread::CUSTOM_EVENT_DATA = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/agent_helpers/start_worker_thread.rb#13
NewRelic::Agent::AgentHelpers::StartWorkerThread::ERROR_EVENT_DATA = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/agent_helpers/start_worker_thread.rb#15
NewRelic::Agent::AgentHelpers::StartWorkerThread::LOG_EVENT_DATA = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/agent_helpers/start_worker_thread.rb#9
NewRelic::Agent::AgentHelpers::StartWorkerThread::LOG_ONCE_KEYS_RESET_PERIOD = T.let(T.unsafe(nil), Float)

# source://newrelic_rpm//lib/new_relic/agent/agent_helpers/start_worker_thread.rb#14
NewRelic::Agent::AgentHelpers::StartWorkerThread::SPAN_EVENT_DATA = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/agent_helpers/start_worker_thread.rb#11
NewRelic::Agent::AgentHelpers::StartWorkerThread::TRANSACTION_EVENT_DATA = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/agent_helpers/startup.rb#8
module NewRelic::Agent::AgentHelpers::Startup
  # Check to see if the agent should start, returning +true+ if it should.
  #
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/startup.rb#168
  def agent_should_start?; end

  # Check whether we have already started, which is an error condition
  #
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/startup.rb#15
  def already_started?; end

  # Logs the configured application names
  #
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/startup.rb#110
  def app_name_configured?; end

  # Sanity-check the agent configuration and start the agent,
  # setting up the worker thread and the exit handler to shut
  # down the agent
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/startup.rb#38
  def check_config_and_start_agent; end

  # Connecting in the foreground blocks further startup of the
  # agent until we have a connection - useful in cases where
  # you're trying to log a very-short-running process and want
  # to get statistics from before a server connection
  # (typically 20 seconds) exists
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/startup.rb#120
  def connect_in_foreground; end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/startup.rb#156
  def correct_license_length; end

  # The agent is disabled when it is not force enabled by the
  # 'agent_enabled' option (e.g. in a manual start), or
  # enabled normally through the configuration file
  #
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/startup.rb#196
  def disabled?; end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/startup.rb#150
  def has_correct_license_key?; end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/startup.rb#137
  def has_license_key?; end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/startup.rb#89
  def log_app_name; end

  # Logs the dispatcher to the log file to assist with
  # debugging. When no debugger is present, logs this fact to
  # assist with proper dispatcher detection
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/startup.rb#79
  def log_dispatcher; end

  # Log the environment the app thinks it's running in.
  # Useful in debugging, as this is the key for config YAML lookups.
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/startup.rb#72
  def log_environment; end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/startup.rb#93
  def log_ignore_url_regexes; end

  # Log startup information that we almost always want to know
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/startup.rb#64
  def log_startup; end

  # Classy logging of the agent version and the current pid,
  # so we can disambiguate processes in the log file and make
  # sure they're running a reasonable version
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/startup.rb#105
  def log_version_and_pid; end

  # Warn the user if they have configured their agent not to
  # send data, that way we can see this clearly in the log file
  #
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/startup.rb#126
  def monitoring?; end

  # This is the shared method between the main agent startup and the
  # after_fork call restarting the thread in deferred dispatchers.
  #
  # Treatment of @started and env report is important to get right.
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/startup.rb#49
  def setup_and_start_agent(options = T.unsafe(nil)); end

  # Logs a bunch of data and starts the agent, if needed
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/startup.rb#23
  def start; end

  # True if we have initialized and completed 'start'
  #
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/startup.rb#10
  def started?; end
end

# source://newrelic_rpm//lib/new_relic/agent/agent_helpers/transmit.rb#8
module NewRelic::Agent::AgentHelpers::Transmit
  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/transmit.rb#10
  def transmit_analytic_event_data; end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/transmit.rb#15
  def transmit_custom_event_data; end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/transmit.rb#48
  def transmit_data; end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/transmit.rb#65
  def transmit_data_types; end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/transmit.rb#20
  def transmit_error_event_data; end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/transmit.rb#30
  def transmit_log_event_data; end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/transmit.rb#34
  def transmit_single_data_type(harvest_method, supportability_name); end

  # source://newrelic_rpm//lib/new_relic/agent/agent_helpers/transmit.rb#25
  def transmit_span_event_data; end
end

# source://newrelic_rpm//lib/new_relic/agent/agent_helpers/transmit.rb#14
NewRelic::Agent::AgentHelpers::Transmit::CUSTOM_EVENT = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/agent_helpers/transmit.rb#19
NewRelic::Agent::AgentHelpers::Transmit::ERROR_EVENT = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/agent_helpers/transmit.rb#29
NewRelic::Agent::AgentHelpers::Transmit::LOG_EVENT = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/agent_helpers/transmit.rb#24
NewRelic::Agent::AgentHelpers::Transmit::SPAN_EVENT = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/agent_helpers/transmit.rb#9
NewRelic::Agent::AgentHelpers::Transmit::TRANSACTION_EVENT = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/agent_logger.rb#13
class NewRelic::Agent::AgentLogger
  include ::NewRelic::Agent::LogOnce

  # @return [AgentLogger] a new instance of AgentLogger
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_logger.rb#16
  def initialize(root = T.unsafe(nil), override_logger = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/agent_logger.rb#43
  def debug(*msgs, &blk); end

  # source://newrelic_rpm//lib/new_relic/agent/agent_logger.rb#31
  def error(*msgs, &blk); end

  # source://newrelic_rpm//lib/new_relic/agent/agent_logger.rb#27
  def fatal(*msgs, &blk); end

  # source://newrelic_rpm//lib/new_relic/agent/agent_logger.rb#39
  def info(*msgs, &blk); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_logger.rb#47
  def is_startup_logger?; end

  # Use this when you want to log an exception with explicit control over
  # the log level that the backtrace is logged at. If you just want the
  # default behavior of backtraces logged at debug, use one of the methods
  # above and pass an Exception as one of the args.
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_logger.rb#55
  def log_exception(level, e, backtrace_level = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/agent_logger.rb#67
  def log_formatter=(formatter); end

  # source://newrelic_rpm//lib/new_relic/agent/agent_logger.rb#35
  def warn(*msgs, &blk); end

  private

  # source://newrelic_rpm//lib/new_relic/agent/agent_logger.rb#73
  def backtrace_from_exception(e); end

  # source://newrelic_rpm//lib/new_relic/agent/agent_logger.rb#100
  def create_log(root, override_logger); end

  # source://newrelic_rpm//lib/new_relic/agent/agent_logger.rb#114
  def create_log_to_file(root); end

  # source://newrelic_rpm//lib/new_relic/agent/agent_logger.rb#130
  def create_null_logger; end

  # Don't allow agent logs into agent log forwarding for now
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_logger.rb#173
  def disable_log_instrumentation!; end

  # source://newrelic_rpm//lib/new_relic/agent/agent_logger.rb#138
  def find_or_create_file_path(path_setting, root); end

  # Allows for passing exceptions in explicitly, which format with backtrace
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_logger.rb#84
  def format_and_send(level, *msgs, &block); end

  # source://newrelic_rpm//lib/new_relic/agent/agent_logger.rb#177
  def gather_startup_logs; end

  # source://newrelic_rpm//lib/new_relic/agent/agent_logger.rb#164
  def set_log_format!; end

  # source://newrelic_rpm//lib/new_relic/agent/agent_logger.rb#148
  def set_log_level!; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/agent_logger.rb#134
  def wants_stdout?; end

  class << self
    # source://newrelic_rpm//lib/new_relic/agent/agent_logger.rb#181
    def format_fatal_error(message); end

    # source://newrelic_rpm//lib/new_relic/agent/agent_logger.rb#160
    def log_level_for(level); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/agent_logger.rb#152
NewRelic::Agent::AgentLogger::LOG_LEVELS = T.let(T.unsafe(nil), Hash)

# source://newrelic_rpm//lib/new_relic/agent/attribute_filter.rb#64
class NewRelic::Agent::AttributeFilter
  # @return [AttributeFilter] a new instance of AttributeFilter
  #
  # source://newrelic_rpm//lib/new_relic/agent/attribute_filter.rb#78
  def initialize(config); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/attribute_filter.rb#211
  def allows?(allowed_destinations, requested_destination); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/attribute_filter.rb#215
  def allows_key?(key, destination); end

  # source://newrelic_rpm//lib/new_relic/agent/attribute_filter.rb#192
  def apply(attribute_name, default_destinations); end

  # source://newrelic_rpm//lib/new_relic/agent/attribute_filter.rb#177
  def build_rule(attribute_names, destinations, is_include); end

  # source://newrelic_rpm//lib/new_relic/agent/attribute_filter.rb#184
  def build_uri_rule(excluded_attributes); end

  # For attribute prefixes where we know the default destinations will
  # always be DST_NONE, we can statically determine that any attribute
  # starting with the prefix will not be allowed unless there's an include
  # rule that might match attributes starting with it.
  #
  # This allows us to skip significant preprocessing work (hash/array
  # flattening and type coercion) for HTTP request parameters and job
  # arguments for Sidekiq and Resque in the common case, since none of
  # these attributes are captured by default.
  #
  # source://newrelic_rpm//lib/new_relic/agent/attribute_filter.rb#242
  def cache_prefix_denylist; end

  # source://newrelic_rpm//lib/new_relic/agent/attribute_filter.rb#94
  def enabled_destinations_for_attributes(config); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/attribute_filter.rb#228
  def high_security?; end

  # source://newrelic_rpm//lib/new_relic/agent/attribute_filter.rb#169
  def include_destinations_for_capture_params(capturing); end

  # Note that the given prefix *must* be a Symbol
  #
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/attribute_filter.rb#250
  def might_allow_prefix?(prefix); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/attribute_filter.rb#254
  def might_allow_prefix_uncached?(prefix); end

  # source://newrelic_rpm//lib/new_relic/agent/attribute_filter.rb#115
  def prep_attributes_exclude_rules(config); end

  # source://newrelic_rpm//lib/new_relic/agent/attribute_filter.rb#134
  def prep_attributes_include_rules(config); end

  # source://newrelic_rpm//lib/new_relic/agent/attribute_filter.rb#125
  def prep_capture_params_rules(config); end

  # source://newrelic_rpm//lib/new_relic/agent/attribute_filter.rb#129
  def prep_datastore_rules(config); end

  # source://newrelic_rpm//lib/new_relic/agent/attribute_filter.rb#90
  def prep_enabled_destinations(config); end

  # source://newrelic_rpm//lib/new_relic/agent/attribute_filter.rb#105
  def prep_rules(config); end

  # Returns the value of attribute rules.
  #
  # source://newrelic_rpm//lib/new_relic/agent/attribute_filter.rb#76
  def rules; end

  # Note the key_cache is a global cache, accessible by multiple threads,
  # but is intentionally left unsynchronized for liveness. Writes will always
  # involve writing the same boolean value for each key, so there is no
  # worry of one value clobbering another. For reads, if a value hasn't been
  # written to the cache yet, the worst that will happen is that it will run
  # through the filter rules again. Both reads and writes will become
  # eventually consistent.
  #
  # source://newrelic_rpm//lib/new_relic/agent/attribute_filter.rb#152
  def setup_key_cache; end
end

# source://newrelic_rpm//lib/new_relic/agent/attribute_filter.rb#74
NewRelic::Agent::AttributeFilter::DST_ALL = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/agent/attribute_filter.rb#70
NewRelic::Agent::AttributeFilter::DST_BROWSER_MONITORING = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/agent/attribute_filter.rb#69
NewRelic::Agent::AttributeFilter::DST_ERROR_COLLECTOR = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/agent/attribute_filter.rb#65
NewRelic::Agent::AttributeFilter::DST_NONE = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/agent/attribute_filter.rb#71
NewRelic::Agent::AttributeFilter::DST_SPAN_EVENTS = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/agent/attribute_filter.rb#67
NewRelic::Agent::AttributeFilter::DST_TRANSACTION_EVENTS = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/agent/attribute_filter.rb#72
NewRelic::Agent::AttributeFilter::DST_TRANSACTION_SEGMENTS = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/agent/attribute_filter.rb#68
NewRelic::Agent::AttributeFilter::DST_TRANSACTION_TRACER = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/agent/attribute_filter.rb#272
class NewRelic::Agent::AttributeFilterRule
  # @return [AttributeFilterRule] a new instance of AttributeFilterRule
  #
  # source://newrelic_rpm//lib/new_relic/agent/attribute_filter.rb#275
  def initialize(attribute_name, destinations, is_include); end

  # Rules are sorted from least specific to most specific
  #
  # All else being the same, wildcards are considered less specific
  # All else being the same, include rules are less specific than excludes
  #
  # source://newrelic_rpm//lib/new_relic/agent/attribute_filter.rb#286
  def <=>(other); end

  # Returns the value of attribute attribute_name.
  #
  # source://newrelic_rpm//lib/new_relic/agent/attribute_filter.rb#273
  def attribute_name; end

  # Returns the value of attribute destinations.
  #
  # source://newrelic_rpm//lib/new_relic/agent/attribute_filter.rb#273
  def destinations; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/attribute_filter.rb#309
  def empty?; end

  # Returns the value of attribute is_include.
  #
  # source://newrelic_rpm//lib/new_relic/agent/attribute_filter.rb#273
  def is_include; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/attribute_filter.rb#301
  def match?(name); end

  # Returns the value of attribute wildcard.
  #
  # source://newrelic_rpm//lib/new_relic/agent/attribute_filter.rb#273
  def wildcard; end
end

# source://newrelic_rpm//lib/new_relic/agent/attribute_pre_filtering.rb#7
module NewRelic::Agent::AttributePreFiltering
  private

  # `nil`, empty enumerable objects, and `false` are all valid in their
  # own right as application data, so pre-filtering uses a special value
  # to indicate that filtered out data has been discarded
  #
  # source://newrelic_rpm//lib/new_relic/agent/attribute_pre_filtering.rb#104
  def discarded?(object); end

  # source://newrelic_rpm//lib/new_relic/agent/attribute_pre_filtering.rb#13
  def formulate_regexp_union(option); end

  # attribute filtering suppresses data that has already been flattened
  # and coerced (serialized as text) via #flatten_and_coerce, and is
  # restricted to basic text matching with a single optional wildcard.
  # pre filtering operates on raw Ruby objects beforehand and uses full
  # Ruby regex syntax
  #
  # source://newrelic_rpm//lib/new_relic/agent/attribute_pre_filtering.rb#33
  def pre_filter(values = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/attribute_pre_filtering.rb#83
  def pre_filter_array(array, options); end

  # source://newrelic_rpm//lib/new_relic/agent/attribute_pre_filtering.rb#61
  def pre_filter_hash(hash, options); end

  # source://newrelic_rpm//lib/new_relic/agent/attribute_pre_filtering.rb#51
  def pre_filter_object(object, options); end

  # source://newrelic_rpm//lib/new_relic/agent/attribute_pre_filtering.rb#94
  def pre_filter_scalar(scalar, options); end

  # source://newrelic_rpm//lib/new_relic/agent/attribute_pre_filtering.rb#22
  def string_to_regexp(str); end

  class << self
    # `nil`, empty enumerable objects, and `false` are all valid in their
    # own right as application data, so pre-filtering uses a special value
    # to indicate that filtered out data has been discarded
    #
    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/attribute_pre_filtering.rb#104
    def discarded?(object); end

    # source://newrelic_rpm//lib/new_relic/agent/attribute_pre_filtering.rb#13
    def formulate_regexp_union(option); end

    # attribute filtering suppresses data that has already been flattened
    # and coerced (serialized as text) via #flatten_and_coerce, and is
    # restricted to basic text matching with a single optional wildcard.
    # pre filtering operates on raw Ruby objects beforehand and uses full
    # Ruby regex syntax
    #
    # source://newrelic_rpm//lib/new_relic/agent/attribute_pre_filtering.rb#33
    def pre_filter(values = T.unsafe(nil), options = T.unsafe(nil)); end

    # source://newrelic_rpm//lib/new_relic/agent/attribute_pre_filtering.rb#83
    def pre_filter_array(array, options); end

    # source://newrelic_rpm//lib/new_relic/agent/attribute_pre_filtering.rb#61
    def pre_filter_hash(hash, options); end

    # source://newrelic_rpm//lib/new_relic/agent/attribute_pre_filtering.rb#51
    def pre_filter_object(object, options); end

    # source://newrelic_rpm//lib/new_relic/agent/attribute_pre_filtering.rb#94
    def pre_filter_scalar(scalar, options); end

    # source://newrelic_rpm//lib/new_relic/agent/attribute_pre_filtering.rb#22
    def string_to_regexp(str); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/attribute_pre_filtering.rb#11
NewRelic::Agent::AttributePreFiltering::DISCARDED = T.let(T.unsafe(nil), Symbol)

# source://newrelic_rpm//lib/new_relic/agent/attribute_pre_filtering.rb#10
NewRelic::Agent::AttributePreFiltering::PRE_FILTER_KEYS = T.let(T.unsafe(nil), Array)

# source://newrelic_rpm//lib/new_relic/agent/attribute_processing.rb#7
module NewRelic::Agent::AttributeProcessing
  private

  # source://newrelic_rpm//lib/new_relic/agent/attribute_processing.rb#13
  def flatten_and_coerce(object, prefix = T.unsafe(nil), result = T.unsafe(nil), &blk); end

  # source://newrelic_rpm//lib/new_relic/agent/attribute_processing.rb#46
  def flatten_and_coerce_array(array, prefix, result, &blk); end

  # source://newrelic_rpm//lib/new_relic/agent/attribute_processing.rb#31
  def flatten_and_coerce_hash(hash, prefix, result, &blk); end

  class << self
    # source://newrelic_rpm//lib/new_relic/agent/attribute_processing.rb#13
    def flatten_and_coerce(object, prefix = T.unsafe(nil), result = T.unsafe(nil), &blk); end

    # source://newrelic_rpm//lib/new_relic/agent/attribute_processing.rb#46
    def flatten_and_coerce_array(array, prefix, result, &blk); end

    # source://newrelic_rpm//lib/new_relic/agent/attribute_processing.rb#31
    def flatten_and_coerce_hash(hash, prefix, result, &blk); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/attribute_processing.rb#11
NewRelic::Agent::AttributeProcessing::EMPTY_ARRAY_STRING_LITERAL = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/attribute_processing.rb#10
NewRelic::Agent::AttributeProcessing::EMPTY_HASH_STRING_LITERAL = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/attributes.rb#9
class NewRelic::Agent::Attributes
  # @return [Attributes] a new instance of Attributes
  #
  # source://newrelic_rpm//lib/new_relic/agent/attributes.rb#16
  def initialize(filter); end

  # source://newrelic_rpm//lib/new_relic/agent/attributes.rb#28
  def add_agent_attribute(key, value, default_destinations); end

  # source://newrelic_rpm//lib/new_relic/agent/attributes.rb#36
  def add_agent_attribute_with_key_check(key, value, default_destinations); end

  # source://newrelic_rpm//lib/new_relic/agent/attributes.rb#45
  def add_intrinsic_attribute(key, value); end

  # source://newrelic_rpm//lib/new_relic/agent/attributes.rb#71
  def agent_attributes_for(destination); end

  # Returns the value of attribute custom_attributes.
  #
  # source://newrelic_rpm//lib/new_relic/agent/attributes.rb#14
  def custom_attributes; end

  # source://newrelic_rpm//lib/new_relic/agent/attributes.rb#67
  def custom_attributes_for(destination); end

  # source://newrelic_rpm//lib/new_relic/agent/attributes.rb#75
  def intrinsic_attributes_for(destination); end

  # source://newrelic_rpm//lib/new_relic/agent/attributes.rb#58
  def merge_custom_attributes(other); end

  # source://newrelic_rpm//lib/new_relic/agent/attributes.rb#49
  def merge_untrusted_agent_attributes(attributes, prefix, default_destinations); end

  private

  # source://newrelic_rpm//lib/new_relic/agent/attributes.rb#112
  def add(attributes, key, value); end

  # source://newrelic_rpm//lib/new_relic/agent/attributes.rb#86
  def add_custom_attribute(key, value); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/attributes.rb#134
  def exceeds_bytesize_limit?(value, limit); end

  # source://newrelic_rpm//lib/new_relic/agent/attributes.rb#122
  def for_destination(attributes, calculated_destinations, destination); end

  # Take one byte past our limit. Why? This lets us unconditionally chop!
  # the end. It'll either remove the one-character-too-many we have, or
  # peel off the partial, mangled character left by the byteslice.
  #
  # source://newrelic_rpm//lib/new_relic/agent/attributes.rb#147
  def slice(incoming); end
end

# source://newrelic_rpm//lib/new_relic/agent/attributes.rb#12
NewRelic::Agent::Attributes::COUNT_LIMIT = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/agent/attributes.rb#10
NewRelic::Agent::Attributes::KEY_LIMIT = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/agent/attributes.rb#11
NewRelic::Agent::Attributes::VALUE_LIMIT = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/agent/audit_logger.rb#12
class NewRelic::Agent::AuditLogger
  # @return [AuditLogger] a new instance of AuditLogger
  #
  # source://newrelic_rpm//lib/new_relic/agent/audit_logger.rb#13
  def initialize; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/audit_logger.rb#59
  def allowed_endpoint?(uri); end

  # source://newrelic_rpm//lib/new_relic/agent/audit_logger.rb#101
  def create_log_formatter; end

  # Sets the attribute enabled
  #
  # @param value the value to set the attribute enabled to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/audit_logger.rb#20
  def enabled=(_arg0); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/audit_logger.rb#22
  def enabled?; end

  # source://newrelic_rpm//lib/new_relic/agent/audit_logger.rb#81
  def ensure_log_path; end

  # source://newrelic_rpm//lib/new_relic/agent/audit_logger.rb#41
  def log_request(uri, data, marshaller); end

  # source://newrelic_rpm//lib/new_relic/agent/audit_logger.rb#30
  def log_request_headers(uri, headers); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/audit_logger.rb#26
  def setup?; end

  # source://newrelic_rpm//lib/new_relic/agent/audit_logger.rb#63
  def setup_logger; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/audit_logger.rb#97
  def wants_stdout?; end
end

# A singleton responsible for determining if the agent should start
# monitoring.
#
# If the agent is in a monitored environment (e.g. production) it will
# attempt to avoid starting at "inappropriate" times, for example in an IRB
# session.  On Heroku, logs typically go to STDOUT so agent logs can spam
# the console during interactive sessions.
#
# It should be possible to override Autostart logic with an explicit
# configuration, for example the NEW_RELIC_AGENT_ENABLED environment variable or
# agent_enabled key in newrelic.yml
#
# source://newrelic_rpm//lib/new_relic/agent/autostart.rb#18
module NewRelic::Agent::Autostart
  extend ::NewRelic::Agent::Autostart

  # The constants, executables (i.e. $0) and rake tasks used can be
  # configured with the config keys 'autostart.denylisted_constants',
  # 'autostart.denylisted_executables' and
  # 'autostart.denylisted_rake_tasks'
  #
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/autostart.rb#25
  def agent_should_start?; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/autostart.rb#56
  def denylisted?(value, &block); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/autostart.rb#33
  def denylisted_constants?; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/autostart.rb#50
  def denylisted_executables?; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/autostart.rb#60
  def in_denylisted_rake_task?; end
end

# source://newrelic_rpm//lib/new_relic/agent/autostart.rb#31
NewRelic::Agent::Autostart::COMMA = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/commands/agent_command.rb#7
module NewRelic::Agent::Commands; end

# source://newrelic_rpm//lib/new_relic/agent/commands/agent_command.rb#8
class NewRelic::Agent::Commands::AgentCommand
  # @return [AgentCommand] a new instance of AgentCommand
  #
  # source://newrelic_rpm//lib/new_relic/agent/commands/agent_command.rb#11
  def initialize(raw_collector_command); end

  # Returns the value of attribute arguments.
  #
  # source://newrelic_rpm//lib/new_relic/agent/commands/agent_command.rb#9
  def arguments; end

  # Returns the value of attribute id.
  #
  # source://newrelic_rpm//lib/new_relic/agent/commands/agent_command.rb#9
  def id; end

  # Returns the value of attribute name.
  #
  # source://newrelic_rpm//lib/new_relic/agent/commands/agent_command.rb#9
  def name; end
end

# source://newrelic_rpm//lib/new_relic/agent/commands/agent_command_router.rb#17
class NewRelic::Agent::Commands::AgentCommandRouter
  # @return [AgentCommandRouter] a new instance of AgentCommandRouter
  #
  # source://newrelic_rpm//lib/new_relic/agent/commands/agent_command_router.rb#22
  def initialize(event_listener = T.unsafe(nil)); end

  # Returns the value of attribute backtrace_service.
  #
  # source://newrelic_rpm//lib/new_relic/agent/commands/agent_command_router.rb#20
  def backtrace_service; end

  # Sets the attribute backtrace_service
  #
  # @param value the value to set the attribute backtrace_service to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/commands/agent_command_router.rb#20
  def backtrace_service=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/agent/commands/agent_command_router.rb#128
  def call_handler_for(agent_command); end

  # source://newrelic_rpm//lib/new_relic/agent/commands/agent_command_router.rb#42
  def check_for_and_handle_agent_commands; end

  # source://newrelic_rpm//lib/new_relic/agent/commands/agent_command_router.rb#124
  def error(err); end

  # source://newrelic_rpm//lib/new_relic/agent/commands/agent_command_router.rb#88
  def get_agent_commands; end

  # Returns the value of attribute handlers.
  #
  # source://newrelic_rpm//lib/new_relic/agent/commands/agent_command_router.rb#18
  def handlers; end

  # source://newrelic_rpm//lib/new_relic/agent/commands/agent_command_router.rb#55
  def harvest!; end

  # source://newrelic_rpm//lib/new_relic/agent/commands/agent_command_router.rb#70
  def harvest_from_thread_profiler_session; end

  # source://newrelic_rpm//lib/new_relic/agent/commands/agent_command_router.rb#107
  def invoke_command(agent_command); end

  # source://newrelic_rpm//lib/new_relic/agent/commands/agent_command_router.rb#94
  def invoke_commands(agent_commands); end

  # source://newrelic_rpm//lib/new_relic/agent/commands/agent_command_router.rb#79
  def log_profiles(profiles); end

  # We don't currently support merging thread profiles that failed to send
  # back into the AgentCommandRouter, so we just no-op this method.
  # Same with reset! - we don't support asynchronous cancellation of a
  # running thread profile currently.
  #
  # source://newrelic_rpm//lib/new_relic/agent/commands/agent_command_router.rb#66
  def merge!(*args); end

  # source://newrelic_rpm//lib/new_relic/agent/commands/agent_command_router.rb#38
  def new_relic_service; end

  # source://newrelic_rpm//lib/new_relic/agent/commands/agent_command_router.rb#49
  def on_before_shutdown(*args); end

  # source://newrelic_rpm//lib/new_relic/agent/commands/agent_command_router.rb#68
  def reset!; end

  # source://newrelic_rpm//lib/new_relic/agent/commands/agent_command_router.rb#133
  def select_handler(agent_command); end

  # source://newrelic_rpm//lib/new_relic/agent/commands/agent_command_router.rb#120
  def success; end

  # Returns the value of attribute thread_profiler_session.
  #
  # source://newrelic_rpm//lib/new_relic/agent/commands/agent_command_router.rb#20
  def thread_profiler_session; end

  # Sets the attribute thread_profiler_session
  #
  # @param value the value to set the attribute thread_profiler_session to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/commands/agent_command_router.rb#20
  def thread_profiler_session=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/agent/commands/agent_command_router.rb#137
  def unrecognized_agent_command(agent_command); end
end

# source://newrelic_rpm//lib/new_relic/agent/commands/agent_command_router.rb#104
class NewRelic::Agent::Commands::AgentCommandRouter::AgentCommandError < ::StandardError; end

# source://newrelic_rpm//lib/new_relic/agent/commands/agent_command_router.rb#118
NewRelic::Agent::Commands::AgentCommandRouter::ERROR_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/commands/agent_command_router.rb#117
NewRelic::Agent::Commands::AgentCommandRouter::SUCCESS_RESULT = T.let(T.unsafe(nil), Hash)

# source://newrelic_rpm//lib/new_relic/agent/commands/thread_profiler_session.rb#12
class NewRelic::Agent::Commands::ThreadProfilerSession
  # @return [ThreadProfilerSession] a new instance of ThreadProfilerSession
  #
  # source://newrelic_rpm//lib/new_relic/agent/commands/thread_profiler_session.rb#13
  def initialize(backtrace_service); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/commands/thread_profiler_session.rb#63
  def enabled?; end

  # source://newrelic_rpm//lib/new_relic/agent/commands/thread_profiler_session.rb#20
  def handle_start_command(agent_command); end

  # source://newrelic_rpm//lib/new_relic/agent/commands/thread_profiler_session.rb#27
  def handle_stop_command(agent_command); end

  # source://newrelic_rpm//lib/new_relic/agent/commands/thread_profiler_session.rb#52
  def harvest; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/commands/thread_profiler_session.rb#75
  def past_time?; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/commands/thread_profiler_session.rb#71
  def ready_to_harvest?; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/commands/thread_profiler_session.rb#67
  def running?; end

  # source://newrelic_rpm//lib/new_relic/agent/commands/thread_profiler_session.rb#32
  def start(agent_command); end

  # source://newrelic_rpm//lib/new_relic/agent/commands/thread_profiler_session.rb#43
  def stop(report_data); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/commands/thread_profiler_session.rb#81
  def stopped?; end

  private

  # source://newrelic_rpm//lib/new_relic/agent/commands/thread_profiler_session.rb#104
  def raise_already_started_error; end

  # @raise [NewRelic::Agent::Commands::AgentCommandRouter::AgentCommandError]
  #
  # source://newrelic_rpm//lib/new_relic/agent/commands/thread_profiler_session.rb#87
  def raise_command_error(msg); end

  # source://newrelic_rpm//lib/new_relic/agent/commands/thread_profiler_session.rb#99
  def raise_thread_profiler_disabled; end

  # source://newrelic_rpm//lib/new_relic/agent/commands/thread_profiler_session.rb#91
  def raise_unsupported_error; end
end

# source://newrelic_rpm//lib/new_relic/agent/configuration/mask_defaults.rb#7
module NewRelic::Agent::Configuration
  class << self
    # Marks the config option as deprecated in the documentation once generated.
    # Does not appear in logs.
    #
    # source://newrelic_rpm//lib/new_relic/agent/configuration/default_source.rb#26
    def deprecated_description(new_setting, description); end

    # source://newrelic_rpm//lib/new_relic/agent/configuration/default_source.rb#18
    def instrumentation_value_from_boolean(key); end

    # Helper since default Procs are evaluated in the context of this module
    #
    # source://newrelic_rpm//lib/new_relic/agent/configuration/default_source.rb#12
    def value_of(key); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/configuration/default_source.rb#264
NewRelic::Agent::Configuration::AUTOSTART_DENYLISTED_RAKE_TASKS = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/configuration/default_source.rb#31
class NewRelic::Agent::Configuration::Boolean
  class << self
    # source://newrelic_rpm//lib/new_relic/agent/configuration/default_source.rb#32
    def ===(o); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/configuration/default_source.rb#317
NewRelic::Agent::Configuration::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://newrelic_rpm//lib/new_relic/agent/configuration/default_source.rb#37
class NewRelic::Agent::Configuration::DefaultSource
  extend ::Forwardable

  # @return [DefaultSource] a new instance of DefaultSource
  #
  # source://newrelic_rpm//lib/new_relic/agent/configuration/default_source.rb#43
  def initialize; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def [](*args, **_arg1, &block); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/default_source.rb#47
  def default_values; end

  # Returns the value of attribute defaults.
  #
  # source://newrelic_rpm//lib/new_relic/agent/configuration/default_source.rb#38
  def defaults; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def delete(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def each(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def has_key?(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def keys(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def merge(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_hash(*args, **_arg1, &block); end

  class << self
    # source://newrelic_rpm//lib/new_relic/agent/configuration/default_source.rb#126
    def agent_enabled; end

    # source://newrelic_rpm//lib/new_relic/agent/configuration/default_source.rb#184
    def api_host; end

    # source://newrelic_rpm//lib/new_relic/agent/configuration/default_source.rb#146
    def app_name; end

    # source://newrelic_rpm//lib/new_relic/agent/configuration/default_source.rb#136
    def audit_log_path; end

    # source://newrelic_rpm//lib/new_relic/agent/configuration/default_source.rb#95
    def config_path; end

    # source://newrelic_rpm//lib/new_relic/agent/configuration/default_source.rb#60
    def config_search_paths; end

    # source://newrelic_rpm//lib/new_relic/agent/configuration/default_source.rb#241
    def convert_to_constant_list(raw_value); end

    # @raise [ArgumentError]
    #
    # source://newrelic_rpm//lib/new_relic/agent/configuration/default_source.rb#216
    def convert_to_hash(value); end

    # source://newrelic_rpm//lib/new_relic/agent/configuration/default_source.rb#205
    def convert_to_list(value); end

    # source://newrelic_rpm//lib/new_relic/agent/configuration/default_source.rb#233
    def convert_to_list_on_semicolon(value); end

    # source://newrelic_rpm//lib/new_relic/agent/configuration/default_source.rb#198
    def convert_to_regexp_list(raw_value); end

    # source://newrelic_rpm//lib/new_relic/agent/configuration/default_source.rb#150
    def dispatcher; end

    # source://newrelic_rpm//lib/new_relic/agent/configuration/default_source.rb#253
    def enforce_fallback(allowed_values: T.unsafe(nil), fallback: T.unsafe(nil)); end

    # source://newrelic_rpm//lib/new_relic/agent/configuration/default_source.rb#104
    def framework; end

    # source://newrelic_rpm//lib/new_relic/agent/configuration/default_source.rb#173
    def host; end

    # source://newrelic_rpm//lib/new_relic/agent/configuration/default_source.rb#162
    def profiling_available; end

    # source://newrelic_rpm//lib/new_relic/agent/configuration/default_source.rb#154
    def thread_profiler_enabled; end

    # source://newrelic_rpm//lib/new_relic/agent/configuration/default_source.rb#158
    def transaction_tracer_transaction_threshold; end

    # source://newrelic_rpm//lib/new_relic/agent/configuration/default_source.rb#55
    def transform_for(key); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/configuration/default_source.rb#134
NewRelic::Agent::Configuration::DefaultSource::DEFAULT_LOG_DIR = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/configuration/default_source.rb#232
NewRelic::Agent::Configuration::DefaultSource::SEMICOLON = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/configuration/dotted_hash.rb#8
class NewRelic::Agent::Configuration::DottedHash < ::Hash
  # @return [DottedHash] a new instance of DottedHash
  #
  # source://newrelic_rpm//lib/new_relic/agent/configuration/dotted_hash.rb#9
  def initialize(hash, keep_nesting = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/dotted_hash.rb#19
  def inspect; end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/dotted_hash.rb#23
  def to_hash; end

  protected

  # turns {'a' => {'b' => 'c'}} into {'a.b' => 'c'}
  #
  # source://newrelic_rpm//lib/new_relic/agent/configuration/dotted_hash.rb#36
  def dot_flattened(nested_hash, names = T.unsafe(nil), result = T.unsafe(nil)); end

  class << self
    # source://newrelic_rpm//lib/new_relic/agent/configuration/dotted_hash.rb#27
    def symbolize(hash); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/configuration/environment_source.rb#8
class NewRelic::Agent::Configuration::EnvironmentSource < ::NewRelic::Agent::Configuration::DottedHash
  # @return [EnvironmentSource] a new instance of EnvironmentSource
  #
  # source://newrelic_rpm//lib/new_relic/agent/configuration/environment_source.rb#18
  def initialize; end

  # Returns the value of attribute alias_map.
  #
  # source://newrelic_rpm//lib/new_relic/agent/configuration/environment_source.rb#16
  def alias_map; end

  # Sets the attribute alias_map
  #
  # @param value the value to set the attribute alias_map to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/configuration/environment_source.rb#16
  def alias_map=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/environment_source.rb#114
  def collect_new_relic_environment_variable_keys; end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/environment_source.rb#109
  def convert_environment_key_to_config_key(key); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/environment_source.rb#33
  def set_aliases(config_setting, value); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/environment_source.rb#63
  def set_config_file; end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/environment_source.rb#43
  def set_dotted_alias(original_config_setting); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/environment_source.rb#82
  def set_key_by_type(config_key, environment_key); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/environment_source.rb#52
  def set_log_file; end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/environment_source.rb#77
  def set_value_from_environment_variable(key); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/environment_source.rb#67
  def set_values_from_new_relic_environment_variables; end

  # Returns the value of attribute type_map.
  #
  # source://newrelic_rpm//lib/new_relic/agent/configuration/environment_source.rb#16
  def type_map; end

  # Sets the attribute type_map
  #
  # @param value the value to set the attribute type_map to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/configuration/environment_source.rb#16
  def type_map=(_arg0); end
end

# source://newrelic_rpm//lib/new_relic/agent/configuration/environment_source.rb#10
NewRelic::Agent::Configuration::EnvironmentSource::SPECIAL_CASE_KEYS = T.let(T.unsafe(nil), Array)

# source://newrelic_rpm//lib/new_relic/agent/configuration/environment_source.rb#9
NewRelic::Agent::Configuration::EnvironmentSource::SUPPORTED_PREFIXES = T.let(T.unsafe(nil), Regexp)

# source://newrelic_rpm//lib/new_relic/agent/configuration/event_harvest_config.rb#8
module NewRelic::Agent::Configuration::EventHarvestConfig
  extend ::NewRelic::Agent::Configuration::EventHarvestConfig

  # source://newrelic_rpm//lib/new_relic/agent/configuration/event_harvest_config.rb#26
  def from_config(config); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/event_harvest_config.rb#36
  def to_config_hash(connect_reply); end

  private

  # source://newrelic_rpm//lib/new_relic/agent/configuration/event_harvest_config.rb#46
  def transform_event_harvest_config_keys(connect_reply, event_harvest_interval); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/event_harvest_config.rb#57
  def transform_span_event_harvest_config(config_hash, connect_reply); end
end

# source://newrelic_rpm//lib/new_relic/agent/configuration/event_harvest_config.rb#11
NewRelic::Agent::Configuration::EventHarvestConfig::EVENT_HARVEST_CONFIG_KEY_MAPPING = T.let(T.unsafe(nil), Hash)

# not including span_event_data here because spans are handled separately in transform_span_event_harvest_config
#
# source://newrelic_rpm//lib/new_relic/agent/configuration/event_harvest_config.rb#19
NewRelic::Agent::Configuration::EventHarvestConfig::EVENT_HARVEST_EVENT_REPORT_PERIOD_KEY_MAPPING = T.let(T.unsafe(nil), Hash)

# source://newrelic_rpm//lib/new_relic/agent/configuration/high_security_source.rb#10
class NewRelic::Agent::Configuration::HighSecuritySource < ::NewRelic::Agent::Configuration::DottedHash
  # @return [HighSecuritySource] a new instance of HighSecuritySource
  #
  # source://newrelic_rpm//lib/new_relic/agent/configuration/high_security_source.rb#11
  def initialize(local_settings); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/high_security_source.rb#33
  def record_sql_setting(local_settings, key); end
end

# source://newrelic_rpm//lib/new_relic/agent/configuration/high_security_source.rb#29
NewRelic::Agent::Configuration::HighSecuritySource::OBFUSCATED = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/configuration/high_security_source.rb#27
NewRelic::Agent::Configuration::HighSecuritySource::OFF = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/configuration/high_security_source.rb#28
NewRelic::Agent::Configuration::HighSecuritySource::RAW = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/configuration/high_security_source.rb#31
NewRelic::Agent::Configuration::HighSecuritySource::SET_TO_OBFUSCATED = T.let(T.unsafe(nil), Array)

# source://newrelic_rpm//lib/new_relic/agent/configuration/mask_defaults.rb#8
NewRelic::Agent::Configuration::MASK_DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#17
class NewRelic::Agent::Configuration::Manager
  # @return [Manager] a new instance of Manager
  #
  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#34
  def initialize; end

  # Defining these explicitly saves object allocations that we incur
  # if we use Forwardable and def_delegators.
  #
  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#22
  def [](key); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#39
  def add_config_for_testing(source, level = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#225
  def apply_mask(hash); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#143
  def apply_transformations(key, value); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#270
  def break_label_string_into_pairs(labels); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#404
  def config_classes_for_testing; end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#389
  def delete_all_configs_for_testing; end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#139
  def evaluate_and_apply_transformations(key, value); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#131
  def evaluate_procs(value); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#113
  def fetch(key); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#205
  def finished_configuring?; end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#209
  def flattened; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#26
  def has_key?(key); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#165
  def invoke_callbacks(direction, source); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#30
  def keys; end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#328
  def limit_number_of_labels(pairs); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#378
  def log_config(direction, source); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#295
  def make_label_hash(pairs, labels = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#374
  def new_cache; end

  # This event is intended to be fired once during the entire lifespan of
  # an agent run, after the server source has been applied for the first
  # time.  This should indicate that all configuration has been applied,
  # and the main functions of the agent are safe to start.
  #
  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#201
  def notify_finished_configuring; end

  # This event is intended to be fired every time the server source is
  # applied.  This happens after the agent's initial connect, and again
  # on every forced reconnect.
  #
  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#193
  def notify_server_source_added; end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#400
  def num_configs_for_testing; end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#343
  def parse_labels_from_dictionary; end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#264
  def parse_labels_from_string; end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#252
  def parsed_labels; end

  # @yield []
  #
  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#160
  def register_callback(key, &proc); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#62
  def remove_config(source); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#48
  def remove_config_type(sym); end

  # We only take the last value provided for a given label type key
  #
  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#338
  def remove_duplicates(pairs); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#80
  def replace_or_add_config(source); end

  # reset the configuration hash, but do not replace previously auto
  # determined dependency detection values with nil or 'auto'
  #
  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#364
  def reset_cache; end

  # Generally only useful during initial construction and tests
  #
  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#348
  def reset_to_defaults; end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#105
  def source(key); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#232
  def to_collector_hash; end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#156
  def transform_from_default(key); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#314
  def truncate(text, key = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#285
  def valid_label_item?(item); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#277
  def valid_label_pairs?(label_pairs); end

  private

  # source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#410
  def config_stack; end
end

# source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#18
NewRelic::Agent::Configuration::Manager::DEPENDENCY_DETECTION_VALUES = T.let(T.unsafe(nil), Array)

# source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#246
NewRelic::Agent::Configuration::Manager::MALFORMED_LABELS_WARNING = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#249
NewRelic::Agent::Configuration::Manager::MAX_LABEL_COUNT = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#250
NewRelic::Agent::Configuration::Manager::MAX_LABEL_LENGTH = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/agent/configuration/manager.rb#247
NewRelic::Agent::Configuration::Manager::PARSING_LABELS_FAILURE = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/configuration/manual_source.rb#10
class NewRelic::Agent::Configuration::ManualSource < ::NewRelic::Agent::Configuration::DottedHash
  # @return [ManualSource] a new instance of ManualSource
  #
  # source://newrelic_rpm//lib/new_relic/agent/configuration/manual_source.rb#11
  def initialize(hash); end
end

# source://newrelic_rpm//lib/new_relic/agent/configuration/security_policy_source.rb#10
class NewRelic::Agent::Configuration::SecurityPolicySource < ::NewRelic::Agent::Configuration::DottedHash
  # @return [SecurityPolicySource] a new instance of SecurityPolicySource
  #
  # source://newrelic_rpm//lib/new_relic/agent/configuration/security_policy_source.rb#197
  def initialize(security_policies); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/security_policy_source.rb#204
  def build_overrides(security_policies); end

  class << self
    # source://newrelic_rpm//lib/new_relic/agent/configuration/security_policy_source.rb#26
    def change_setting(policies, option, new_value); end

    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/configuration/security_policy_source.rb#12
    def enabled?(option); end

    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/configuration/security_policy_source.rb#22
    def not_empty?(option); end

    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/configuration/security_policy_source.rb#16
    def record_sql_enabled?(option); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/configuration/security_policy_source.rb#202
NewRelic::Agent::Configuration::SecurityPolicySource::COLON_COLON = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/configuration/security_policy_source.rb#201
NewRelic::Agent::Configuration::SecurityPolicySource::ENABLED = T.let(T.unsafe(nil), String)

# The keys of the security settings map are the names of security
# policies received from the server. They map to multiple configuration
# options in the local config. There is a hash of metadata that
# corresponds to each configuration option with the following keys:
#
# option: the configuration option name
# supported: true if the agent has one or more corresponding
#   configuration options
# enabled_fn: a callable that takes the configuration option and returns
#   true if the option is enabled, false otherwise
# disabled_value: the value of the configuration option when it is
#   disabled
# permitted_fn: a callable, that will be executed if an option is
#   permitted by the security policy and is also enabled by the config
#
# source://newrelic_rpm//lib/new_relic/agent/configuration/security_policy_source.rb#53
NewRelic::Agent::Configuration::SecurityPolicySource::SECURITY_SETTINGS_MAP = T.let(T.unsafe(nil), Hash)

# source://newrelic_rpm//lib/new_relic/agent/configuration/server_source.rb#8
class NewRelic::Agent::Configuration::ServerSource < ::NewRelic::Agent::Configuration::DottedHash
  # @return [ServerSource] a new instance of ServerSource
  #
  # source://newrelic_rpm//lib/new_relic/agent/configuration/server_source.rb#36
  def initialize(connect_reply, existing_config = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/server_source.rb#88
  def add_event_harvest_config(merged_settings, connect_reply); end

  # These feature gates are not intended to be bullet-proof, but only to
  # avoid the overhead of collecting and transmitting additional data if
  # the user's subscription level precludes its use. The server is the
  # ultimate authority regarding subscription levels, so we expect it to
  # do the real enforcement there.
  #
  # source://newrelic_rpm//lib/new_relic/agent/configuration/server_source.rb#135
  def apply_feature_gates(merged_settings, connect_reply, existing_config); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/server_source.rb#99
  def event_harvest_config_is_valid(connect_reply); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/server_source.rb#113
  def filter_keys(merged_settings); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/server_source.rb#71
  def fix_transaction_threshold(merged_settings); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/server_source.rb#65
  def merge_agent_config_hash(merged_settings, connect_reply); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/server_source.rb#57
  def merge_top_level_keys(merged_settings, connect_reply); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/server_source.rb#155
  def ungated_value(key, merged_settings, existing_config); end
end

# source://newrelic_rpm//lib/new_relic/agent/configuration/server_source.rb#78
NewRelic::Agent::Configuration::ServerSource::EVENT_HARVEST_CONFIG_SUPPORTABILITY_METRIC_NAMES = T.let(T.unsafe(nil), Hash)

# These keys appear *outside* of the agent_config hash in the connect
# response, but should still be merged in as config settings to the
# main agent configuration.
#
# source://newrelic_rpm//lib/new_relic/agent/configuration/server_source.rb#12
NewRelic::Agent::Configuration::ServerSource::TOP_LEVEL_KEYS = T.let(T.unsafe(nil), Array)

# source://newrelic_rpm//lib/new_relic/agent/configuration/yaml_source.rb#10
class NewRelic::Agent::Configuration::YamlSource < ::NewRelic::Agent::Configuration::DottedHash
  # @return [YamlSource] a new instance of YamlSource
  #
  # source://newrelic_rpm//lib/new_relic/agent/configuration/yaml_source.rb#18
  def initialize(path, env); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/configuration/yaml_source.rb#49
  def failed?; end

  # Returns the value of attribute failures.
  #
  # source://newrelic_rpm//lib/new_relic/agent/configuration/yaml_source.rb#11
  def failures; end

  # Sets the attribute failures
  #
  # @param value the value to set the attribute failures to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/configuration/yaml_source.rb#11
  def failures=(_arg0); end

  # Returns the value of attribute file_path.
  #
  # source://newrelic_rpm//lib/new_relic/agent/configuration/yaml_source.rb#11
  def file_path; end

  # Sets the attribute file_path
  #
  # @param value the value to set the attribute file_path to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/configuration/yaml_source.rb#11
  def file_path=(_arg0); end

  # Returns the value of attribute generated_for_user.
  #
  # source://newrelic_rpm//lib/new_relic/agent/configuration/yaml_source.rb#12
  def generated_for_user; end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/yaml_source.rb#12
  def license_key; end

  protected

  # source://newrelic_rpm//lib/new_relic/agent/configuration/yaml_source.rb#170
  def apply_aliases(config); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/yaml_source.rb#133
  def booleanify_values(config, *keys); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/yaml_source.rb#157
  def dot_flattened(nested_hash, names = T.unsafe(nil), result = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/configuration/yaml_source.rb#148
  def is_boolean?(value); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/yaml_source.rb#152
  def log_failure(*messages); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/yaml_source.rb#92
  def process_erb(file); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/yaml_source.rb#105
  def process_yaml(file, env, config, path); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/yaml_source.rb#123
  def substitute_transaction_threshold(config); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/yaml_source.rb#55
  def validate_config_file_path(path); end

  # source://newrelic_rpm//lib/new_relic/agent/configuration/yaml_source.rb#66
  def warn_missing_config_file(path); end
end

# These are configuration options that have a value of a Hash
# This is used in YamlSource#dot_flattened prevent flattening these values
#
# source://newrelic_rpm//lib/new_relic/agent/configuration/yaml_source.rb#16
NewRelic::Agent::Configuration::YamlSource::CONFIG_WITH_HASH_VALUE = T.let(T.unsafe(nil), Array)

# source://newrelic_rpm//lib/new_relic/agent/connect/request_builder.rb#10
module NewRelic::Agent::Connect; end

# source://newrelic_rpm//lib/new_relic/agent/connect/request_builder.rb#11
class NewRelic::Agent::Connect::RequestBuilder
  # @return [RequestBuilder] a new instance of RequestBuilder
  #
  # source://newrelic_rpm//lib/new_relic/agent/connect/request_builder.rb#12
  def initialize(new_relic_service, config, event_harvest_config, environment_report); end

  # Initializes the hash of settings that we send to the
  # server. Returns a literal hash containing the options
  #
  # source://newrelic_rpm//lib/new_relic/agent/connect/request_builder.rb#21
  def connect_payload; end

  # source://newrelic_rpm//lib/new_relic/agent/connect/request_builder.rb#49
  def environment_metadata; end

  # source://newrelic_rpm//lib/new_relic/agent/connect/request_builder.rb#55
  def local_host; end

  # We've seen objects in the environment report (Rails.env in
  # particular) that can't serialize to JSON. Cope with that here and
  # clear out so downstream code doesn't have to check again.
  #
  # source://newrelic_rpm//lib/new_relic/agent/connect/request_builder.rb#43
  def sanitize_environment_report(environment_report); end
end

# source://newrelic_rpm//lib/new_relic/agent/connect/response_handler.rb#8
class NewRelic::Agent::Connect::ResponseHandler
  # @return [ResponseHandler] a new instance of ResponseHandler
  #
  # source://newrelic_rpm//lib/new_relic/agent/connect/response_handler.rb#9
  def initialize(agent, config); end

  # source://newrelic_rpm//lib/new_relic/agent/connect/response_handler.rb#48
  def add_security_policy_config(security_policies); end

  # source://newrelic_rpm//lib/new_relic/agent/connect/response_handler.rb#38
  def add_server_side_config(config_data); end

  # Takes a hash of configuration data returned from the
  # server and uses it to set local variables and to
  # initialize various parts of the agent that are configured
  # separately.
  #
  # Can accommodate most arbitrary data - anything extra is
  # ignored unless we say to do something with it here.
  #
  # source://newrelic_rpm//lib/new_relic/agent/connect/response_handler.rb#21
  def configure_agent(config_data); end
end

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_payload.rb#7
class NewRelic::Agent::CrossAppPayload
  # @return [CrossAppPayload] a new instance of CrossAppPayload
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_payload.rb#10
  def initialize(id, transaction, transaction_info); end

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_payload.rb#21
  def as_json_array(content_length); end

  # Returns the value of attribute id.
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_payload.rb#8
  def id; end

  # Returns the value of attribute referring_guid.
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_payload.rb#8
  def referring_guid; end

  # Returns the value of attribute referring_path_hash.
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_payload.rb#8
  def referring_path_hash; end

  # Returns the value of attribute referring_trip_id.
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_payload.rb#8
  def referring_trip_id; end

  # Returns the value of attribute transaction.
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_payload.rb#8
  def transaction; end

  private

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_payload.rb#39
  def string_or_false_for(value); end
end

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#9
module NewRelic::Agent::CrossAppTracing
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#64
  def add_message_cat_headers(headers); end

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#85
  def assign_cross_app_intrinsics; end

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#45
  def cat_path_hash; end

  # Returns the value of attribute cat_path_hashes.
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#23
  def cat_path_hashes; end

  # Sets the attribute cat_path_hashes
  #
  # @param value the value to set the attribute cat_path_hashes to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#23
  def cat_path_hashes=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#37
  def cat_trip_id; end

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#41
  def cross_app_monitor; end

  # Returns the value of attribute cross_app_payload.
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#23
  def cross_app_payload; end

  # Sets the attribute cross_app_payload
  #
  # @param value the value to set the attribute cross_app_payload to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#23
  def cross_app_payload=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#53
  def insert_cross_app_header(headers); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#33
  def is_cross_app?; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#29
  def is_cross_app_callee?; end

  # Returns the value of attribute is_cross_app_caller.
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#23
  def is_cross_app_caller; end

  # Sets the attribute is_cross_app_caller
  #
  # @param value the value to set the attribute is_cross_app_caller to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#23
  def is_cross_app_caller=(_arg0); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#25
  def is_cross_app_caller?; end

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#75
  def record_cross_app_metrics; end

  private

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#109
  def append_cat_info(payload); end

  # From inbound request headers
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#237
  def assign_intrinsic_transaction_attributes(state); end

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#105
  def cat_referring_path_hash; end

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#142
  def cross_app_enabled?; end

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#166
  def cross_application_tracer_enabled?; end

  # Extract x-process application data from the specified +response+ and return
  # it as an array of the form:
  #
  #  [
  #    <cross app ID>,
  #    <transaction name>,
  #    <queue time in seconds>,
  #    <response time in seconds>,
  #    <request content length in bytes>,
  #    <transaction GUID>
  #  ]
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#203
  def extract_appdata(response); end

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#92
  def insert_message_headers(headers, txn_guid, trip_id, path_hash, synthetics_header); end

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#175
  def insert_request_headers(request, txn_guid, trip_id, path_hash); end

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#217
  def message_has_crossapp_request_header?(headers); end

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#171
  def obfuscator; end

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#98
  def record_cat_path_hash(hash); end

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#221
  def reject_messaging_cat_headers(headers); end

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#183
  def response_has_crossapp_header?(response); end

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#232
  def trusted_valid_cross_app_id?(id); end

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#225
  def trusts?(id); end

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#213
  def valid_cross_app_id?(xp_id); end

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#148
  def valid_cross_process_id?; end

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#157
  def valid_encoding_key?; end

  class << self
    # From inbound request headers
    #
    # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#237
    def assign_intrinsic_transaction_attributes(state); end

    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#142
    def cross_app_enabled?; end

    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#166
    def cross_application_tracer_enabled?; end

    # Extract x-process application data from the specified +response+ and return
    # it as an array of the form:
    #
    #  [
    #    <cross app ID>,
    #    <transaction name>,
    #    <queue time in seconds>,
    #    <response time in seconds>,
    #    <request content length in bytes>,
    #    <transaction GUID>
    #  ]
    #
    # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#203
    def extract_appdata(response); end

    # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#175
    def insert_request_headers(request, txn_guid, trip_id, path_hash); end

    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#217
    def message_has_crossapp_request_header?(headers); end

    # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#171
    def obfuscator; end

    # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#221
    def reject_messaging_cat_headers(headers); end

    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#183
    def response_has_crossapp_header?(response); end

    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#232
    def trusted_valid_cross_app_id?(id); end

    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#225
    def trusts?(id); end

    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#213
    def valid_cross_app_id?(xp_id); end

    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#148
    def valid_cross_process_id?; end

    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#157
    def valid_encoding_key?; end
  end
end

# The cross app response header for "outgoing" calls
#
# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#11
NewRelic::Agent::CrossAppTracing::NR_APPDATA_HEADER = T.let(T.unsafe(nil), String)

# The cross app id header for "outgoing" calls
#
# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#14
NewRelic::Agent::CrossAppTracing::NR_ID_HEADER = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#19
NewRelic::Agent::CrossAppTracing::NR_MESSAGE_BROKER_ID_HEADER = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#21
NewRelic::Agent::CrossAppTracing::NR_MESSAGE_BROKER_SYNTHETICS_HEADER = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#20
NewRelic::Agent::CrossAppTracing::NR_MESSAGE_BROKER_TXN_HEADER = T.let(T.unsafe(nil), String)

# The cross app transaction header for "outgoing" calls
#
# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/cross_app_tracing.rb#17
NewRelic::Agent::CrossAppTracing::NR_TXN_HEADER = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/custom_event_aggregator.rb#10
class NewRelic::Agent::CustomEventAggregator < ::NewRelic::Agent::EventAggregator
  include ::NewRelic::Coerce

  # source://newrelic_rpm//lib/new_relic/agent/custom_event_aggregator.rb#22
  def record(type, attributes); end

  private

  # source://newrelic_rpm//lib/new_relic/agent/custom_event_aggregator.rb#60
  def after_harvest(metadata); end

  # source://newrelic_rpm//lib/new_relic/agent/custom_event_aggregator.rb#56
  def after_initialize; end

  # source://newrelic_rpm//lib/new_relic/agent/custom_event_aggregator.rb#47
  def create_event(type, priority, attributes); end

  # source://newrelic_rpm//lib/new_relic/agent/custom_event_aggregator.rb#79
  def note_dropped_event(type); end

  # source://newrelic_rpm//lib/new_relic/agent/custom_event_aggregator.rb#66
  def note_dropped_events(total_count, dropped_count); end

  # source://newrelic_rpm//lib/new_relic/agent/custom_event_aggregator.rb#72
  def record_supportability_metrics(total_count, captured_count, dropped_count); end
end

# source://newrelic_rpm//lib/new_relic/agent/custom_event_aggregator.rb#16
NewRelic::Agent::CustomEventAggregator::EVENT_TYPE_REGEX = T.let(T.unsafe(nil), Regexp)

# source://newrelic_rpm//lib/new_relic/agent/custom_event_aggregator.rb#15
NewRelic::Agent::CustomEventAggregator::PRIORITY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/custom_event_aggregator.rb#14
NewRelic::Agent::CustomEventAggregator::TIMESTAMP = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/custom_event_aggregator.rb#13
NewRelic::Agent::CustomEventAggregator::TYPE = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/database/obfuscation_helpers.rb#7
module NewRelic::Agent::Database
  extend ::NewRelic::Agent::Database

  # Properly encode, truncate, and dup the incoming query.
  # Take care not to the dup the query more than once as
  # correctly encoded may also dup the query.
  #
  # source://newrelic_rpm//lib/new_relic/agent/database.rb#20
  def capture_query(query); end

  # source://newrelic_rpm//lib/new_relic/agent/database.rb#93
  def close_connections; end

  # Perform this in the runtime environment of a managed
  # application, to explain the sql statement executed within a
  # node of a transaction sample. Returns an array of two arrays.
  # The first array contains the headers, while the second consists of
  # arrays of strings for each column returned by the explain query.
  # Note this happens only for statements whose execution time exceeds
  # a threshold (e.g. 500ms) and only within the slowest transaction
  # in a report period, selected for shipment to New Relic
  #
  # source://newrelic_rpm//lib/new_relic/agent/database.rb#105
  def explain_sql(statement); end

  # source://newrelic_rpm//lib/new_relic/agent/database.rb#89
  def get_connection(config, &connector); end

  # source://newrelic_rpm//lib/new_relic/agent/database.rb#42
  def obfuscate_sql(sql); end

  # source://newrelic_rpm//lib/new_relic/agent/database.rb#128
  def parse_operation_from_query(sql); end

  # source://newrelic_rpm//lib/new_relic/agent/database.rb#50
  def record_sql_method(config_section = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/database.rb#67
  def record_sql_method_key(config_section); end

  # source://newrelic_rpm//lib/new_relic/agent/database.rb#46
  def set_sql_obfuscator(type, &block); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/database.rb#84
  def should_collect_explain_plans?(config_section = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/database.rb#80
  def should_record_sql?(config_section = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/database.rb#32
  def truncate_query(query); end
end

# source://newrelic_rpm//lib/new_relic/agent/database.rb#136
class NewRelic::Agent::Database::ConnectionManager
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # Closes all the connections in the internal connection cache
  #
  # source://newrelic_rpm//lib/new_relic/agent/database.rb#159
  def close_connections; end

  # Returns a cached connection for a given ActiveRecord
  # configuration - these are stored or reopened as needed, and if
  # we cannot get one, we ignore it and move on without explaining
  # the sql
  #
  # source://newrelic_rpm//lib/new_relic/agent/database.rb#143
  def get_connection(config, &connector); end

  class << self
    private

    def allocate; end
    def new(*_arg0); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/database.rb#13
NewRelic::Agent::Database::ELLIPSIS = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/database/explain_plan_helpers.rb#11
module NewRelic::Agent::Database::ExplainPlanHelpers
  # source://newrelic_rpm//lib/new_relic/agent/database/explain_plan_helpers.rb#34
  def handle_exception_in_explain; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/database/explain_plan_helpers.rb#15
  def is_select?(sql); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/database/explain_plan_helpers.rb#30
  def multiple_queries?(sql); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/database/explain_plan_helpers.rb#19
  def parameterized?(sql); end

  # source://newrelic_rpm//lib/new_relic/agent/database/explain_plan_helpers.rb#97
  def process_explain_results_mysql(results); end

  # source://newrelic_rpm//lib/new_relic/agent/database/explain_plan_helpers.rb#118
  def process_explain_results_mysql2(results); end

  # source://newrelic_rpm//lib/new_relic/agent/database/explain_plan_helpers.rb#69
  def process_explain_results_postgres(results); end

  # source://newrelic_rpm//lib/new_relic/agent/database/explain_plan_helpers.rb#127
  def process_explain_results_sqlite(results); end

  # source://newrelic_rpm//lib/new_relic/agent/database/explain_plan_helpers.rb#47
  def process_resultset(results, adapter); end

  # Sequel returns explain plans as just one big pre-formatted String
  # In that case, we send a nil headers array, and the single string
  # wrapped in an array for the values.
  # Note that we don't use this method for Postgres explain plans, since
  # they need to be passed through the explain plan obfuscator first.
  #
  # source://newrelic_rpm//lib/new_relic/agent/database/explain_plan_helpers.rb#93
  def string_explain_plan_results(results); end
end

# SQL containing a semicolon in the middle (with something
# other than whitespace after it) may contain two or more
# queries.  It's not safe to EXPLAIN this kind of expression,
# since it could lead to executing unwanted SQL.
#
# source://newrelic_rpm//lib/new_relic/agent/database/explain_plan_helpers.rb#28
NewRelic::Agent::Database::ExplainPlanHelpers::MULTIPLE_QUERIES = T.let(T.unsafe(nil), Regexp)

# source://newrelic_rpm//lib/new_relic/agent/database/explain_plan_helpers.rb#67
NewRelic::Agent::Database::ExplainPlanHelpers::QUERY_PLAN = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/database/explain_plan_helpers.rb#13
NewRelic::Agent::Database::ExplainPlanHelpers::SELECT = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/database/explain_plan_helpers.rb#125
NewRelic::Agent::Database::ExplainPlanHelpers::SQLITE_EXPLAIN_COLUMNS = T.let(T.unsafe(nil), Array)

# source://newrelic_rpm//lib/new_relic/agent/database/explain_plan_helpers.rb#12
NewRelic::Agent::Database::ExplainPlanHelpers::SUPPORTED_ADAPTERS_FOR_EXPLAIN = T.let(T.unsafe(nil), Array)

# source://newrelic_rpm//lib/new_relic/agent/database.rb#112
NewRelic::Agent::Database::KNOWN_OPERATIONS = T.let(T.unsafe(nil), Array)

# source://newrelic_rpm//lib/new_relic/agent/database.rb#12
NewRelic::Agent::Database::MAX_QUERY_LENGTH = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/agent/database.rb#125
NewRelic::Agent::Database::OTHER_OPERATION = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/database/obfuscation_helpers.rb#8
module NewRelic::Agent::Database::ObfuscationHelpers
  # source://newrelic_rpm//lib/new_relic/agent/database/obfuscation_helpers.rb#92
  def detect_unmatched_pairs(obfuscated, adapter); end

  # source://newrelic_rpm//lib/new_relic/agent/database/obfuscation_helpers.rb#72
  def obfuscate(sql, adapter); end

  # source://newrelic_rpm//lib/new_relic/agent/database/obfuscation_helpers.rb#54
  def obfuscate_single_quote_literals(sql); end

  class << self
    # source://newrelic_rpm//lib/new_relic/agent/database/obfuscation_helpers.rb#60
    def generate_regex(dialect); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/database/obfuscation_helpers.rb#69
NewRelic::Agent::Database::ObfuscationHelpers::CASSANDRA_COMPONENTS_REGEX = T.let(T.unsafe(nil), Regexp)

# We use these to check whether the query contains any quote characters
# after obfuscation. If so, that's a good indication that the original
# query was malformed, and so our obfuscation can't reliably find
# literals. In such a case, we'll replace the entire query with a
# placeholder.
#
# source://newrelic_rpm//lib/new_relic/agent/database/obfuscation_helpers.rb#41
NewRelic::Agent::Database::ObfuscationHelpers::CLEANUP_REGEX = T.let(T.unsafe(nil), Hash)

# source://newrelic_rpm//lib/new_relic/agent/database/obfuscation_helpers.rb#9
NewRelic::Agent::Database::ObfuscationHelpers::COMPONENTS_REGEX_MAP = T.let(T.unsafe(nil), Hash)

# source://newrelic_rpm//lib/new_relic/agent/database/obfuscation_helpers.rb#22
NewRelic::Agent::Database::ObfuscationHelpers::DIALECT_COMPONENTS = T.let(T.unsafe(nil), Hash)

# source://newrelic_rpm//lib/new_relic/agent/database/obfuscation_helpers.rb#52
NewRelic::Agent::Database::ObfuscationHelpers::FAILED_TO_OBFUSCATE_MESSAGE = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/database/obfuscation_helpers.rb#70
NewRelic::Agent::Database::ObfuscationHelpers::FALLBACK_REGEX = T.let(T.unsafe(nil), Regexp)

# source://newrelic_rpm//lib/new_relic/agent/database/obfuscation_helpers.rb#65
NewRelic::Agent::Database::ObfuscationHelpers::MYSQL_COMPONENTS_REGEX = T.let(T.unsafe(nil), Regexp)

# source://newrelic_rpm//lib/new_relic/agent/database/obfuscation_helpers.rb#68
NewRelic::Agent::Database::ObfuscationHelpers::ORACLE_COMPONENTS_REGEX = T.let(T.unsafe(nil), Regexp)

# source://newrelic_rpm//lib/new_relic/agent/database/obfuscation_helpers.rb#51
NewRelic::Agent::Database::ObfuscationHelpers::PLACEHOLDER = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/database/obfuscation_helpers.rb#66
NewRelic::Agent::Database::ObfuscationHelpers::POSTGRES_COMPONENTS_REGEX = T.let(T.unsafe(nil), Regexp)

# source://newrelic_rpm//lib/new_relic/agent/database/obfuscation_helpers.rb#67
NewRelic::Agent::Database::ObfuscationHelpers::SQLITE_COMPONENTS_REGEX = T.let(T.unsafe(nil), Regexp)

# source://newrelic_rpm//lib/new_relic/agent/database/obfuscator.rb#10
class NewRelic::Agent::Database::Obfuscator
  include ::Singleton
  include ::NewRelic::Agent::Database::ObfuscationHelpers
  extend ::Singleton::SingletonClassMethods

  # @return [Obfuscator] a new instance of Obfuscator
  #
  # source://newrelic_rpm//lib/new_relic/agent/database/obfuscator.rb#19
  def initialize; end

  # source://newrelic_rpm//lib/new_relic/agent/database/obfuscator.rb#50
  def default_sql_obfuscator(sql); end

  # Returns the value of attribute obfuscator.
  #
  # source://newrelic_rpm//lib/new_relic/agent/database/obfuscator.rb#14
  def obfuscator; end

  # source://newrelic_rpm//lib/new_relic/agent/database/obfuscator.rb#23
  def reset; end

  # Sets the sql obfuscator used to clean up sql when sending it
  # to the server. Possible types are:
  #
  # :before => sets the block to run before the existing
  # obfuscators
  #
  # :after => sets the block to run after the existing
  # obfuscator(s)
  #
  # :replace => removes the current obfuscator and replaces it
  # with the provided block
  #
  # source://newrelic_rpm//lib/new_relic/agent/database/obfuscator.rb#38
  def set_sql_obfuscator(type, &block); end

  class << self
    private

    def allocate; end
    def new(*_arg0); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/database/obfuscator.rb#17
NewRelic::Agent::Database::Obfuscator::ELLIPSIS = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/database/obfuscator.rb#16
NewRelic::Agent::Database::Obfuscator::QUERY_TOO_LARGE_MESSAGE = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/database/postgres_explain_obfuscator.rb#8
module NewRelic::Agent::Database::PostgresExplainObfuscator
  extend ::NewRelic::Agent::Database::PostgresExplainObfuscator

  # source://newrelic_rpm//lib/new_relic/agent/database/postgres_explain_obfuscator.rb#17
  def obfuscate(explain); end
end

# source://newrelic_rpm//lib/new_relic/agent/database/postgres_explain_obfuscator.rb#15
NewRelic::Agent::Database::PostgresExplainObfuscator::LABEL_LINE_REGEX = T.let(T.unsafe(nil), Regexp)

# Note that this regex can't be shared with the ones in the
# Database::Obfuscator class because here we don't look for
# backslash-escaped strings.
#
# source://newrelic_rpm//lib/new_relic/agent/database/postgres_explain_obfuscator.rb#14
NewRelic::Agent::Database::PostgresExplainObfuscator::QUOTED_STRINGS_REGEX = T.let(T.unsafe(nil), Regexp)

# source://newrelic_rpm//lib/new_relic/agent/database.rb#78
NewRelic::Agent::Database::RECORD_FOR = T.let(T.unsafe(nil), Array)

# source://newrelic_rpm//lib/new_relic/agent/database.rb#126
NewRelic::Agent::Database::SQL_COMMENT_REGEX = T.let(T.unsafe(nil), Regexp)

# source://newrelic_rpm//lib/new_relic/agent/database.rb#172
class NewRelic::Agent::Database::Statement
  include ::NewRelic::Agent::Database::ExplainPlanHelpers

  # @return [Statement] a new instance of Statement
  #
  # source://newrelic_rpm//lib/new_relic/agent/database.rb#179
  def initialize(sql, config = T.unsafe(nil), explainer = T.unsafe(nil), binds = T.unsafe(nil), name = T.unsafe(nil), host = T.unsafe(nil), port_path_or_id = T.unsafe(nil), database_name = T.unsafe(nil)); end

  # This takes a connection config hash from ActiveRecord or Sequel and
  # returns a symbol describing the associated database adapter
  #
  # source://newrelic_rpm//lib/new_relic/agent/database.rb#204
  def adapter; end

  # source://newrelic_rpm//lib/new_relic/agent/database.rb#231
  def append_sql(new_sql); end

  # Returns the value of attribute binds.
  #
  # source://newrelic_rpm//lib/new_relic/agent/database.rb#175
  def binds; end

  # Sets the attribute binds
  #
  # @param value the value to set the attribute binds to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/database.rb#175
  def binds=(_arg0); end

  # Returns the value of attribute config.
  #
  # source://newrelic_rpm//lib/new_relic/agent/database.rb#175
  def config; end

  # Sets the attribute config
  #
  # @param value the value to set the attribute config to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/database.rb#175
  def config=(_arg0); end

  # Returns the value of attribute database_name.
  #
  # source://newrelic_rpm//lib/new_relic/agent/database.rb#175
  def database_name; end

  # Sets the attribute database_name
  #
  # @param value the value to set the attribute database_name to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/database.rb#175
  def database_name=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/agent/database.rb#215
  def explain; end

  # Returns the value of attribute explainer.
  #
  # source://newrelic_rpm//lib/new_relic/agent/database.rb#175
  def explainer; end

  # Sets the attribute explainer
  #
  # @param value the value to set the attribute explainer to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/database.rb#175
  def explainer=(_arg0); end

  # Returns the value of attribute host.
  #
  # source://newrelic_rpm//lib/new_relic/agent/database.rb#175
  def host; end

  # Sets the attribute host
  #
  # @param value the value to set the attribute host to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/database.rb#175
  def host=(_arg0); end

  # Returns the value of attribute name.
  #
  # source://newrelic_rpm//lib/new_relic/agent/database.rb#175
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/database.rb#175
  def name=(_arg0); end

  # Returns the value of attribute port_path_or_id.
  #
  # source://newrelic_rpm//lib/new_relic/agent/database.rb#175
  def port_path_or_id; end

  # Sets the attribute port_path_or_id
  #
  # @param value the value to set the attribute port_path_or_id to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/database.rb#175
  def port_path_or_id=(_arg0); end

  # Returns an sql statement that will be in the form most permissable by
  # the config. The format will be safe for transmission to New Relic.
  #
  # source://newrelic_rpm//lib/new_relic/agent/database.rb#193
  def safe_sql; end

  # Returns the value of attribute sql.
  #
  # source://newrelic_rpm//lib/new_relic/agent/database.rb#175
  def sql; end

  # Sets the attribute sql
  #
  # @param value the value to set the attribute sql to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/database.rb#175
  def sql=(_arg0); end

  private

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/database.rb#261
  def explainable?; end

  # source://newrelic_rpm//lib/new_relic/agent/database.rb#245
  def symbolized_adapter(adapter); end
end

# source://newrelic_rpm//lib/new_relic/agent/database.rb#177
NewRelic::Agent::Database::Statement::DEFAULT_QUERY_NAME = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/database.rb#242
NewRelic::Agent::Database::Statement::MYSQL2_PREFIX = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/database.rb#241
NewRelic::Agent::Database::Statement::MYSQL_PREFIX = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/database.rb#229
NewRelic::Agent::Database::Statement::NEWLINE = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/database.rb#239
NewRelic::Agent::Database::Statement::POSTGIS_PREFIX = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/database.rb#240
NewRelic::Agent::Database::Statement::POSTGRES_PREFIX = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/database.rb#243
NewRelic::Agent::Database::Statement::SQLITE_PREFIX = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/database_adapter.rb#7
class NewRelic::Agent::DatabaseAdapter
  # @return [DatabaseAdapter] a new instance of DatabaseAdapter
  #
  # source://newrelic_rpm//lib/new_relic/agent/database_adapter.rb#22
  def initialize(env, version); end

  # Returns the value of attribute env.
  #
  # source://newrelic_rpm//lib/new_relic/agent/database_adapter.rb#20
  def env; end

  # source://newrelic_rpm//lib/new_relic/agent/database_adapter.rb#27
  def value; end

  # Returns the value of attribute version.
  #
  # source://newrelic_rpm//lib/new_relic/agent/database_adapter.rb#20
  def version; end

  class << self
    # source://newrelic_rpm//lib/new_relic/agent/database_adapter.rb#14
    def value; end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/database_adapter.rb#8
NewRelic::Agent::DatabaseAdapter::VERSIONS = T.let(T.unsafe(nil), Hash)

# This module contains helper methods to facilitate instrumentation of
# datastores not directly supported by the Ruby agent. It is intended to be
# primarily used by authors of 3rd-party datastore instrumentation.
#
# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/datastores/metric_helper.rb#7
module NewRelic::Agent::Datastores
  class << self
    # Wrapper for simplifying attaching SQL queries during a transaction.
    #
    # If you are recording non-SQL data, please use {notice_statement}
    # instead.
    #
    #   NewRelic::Agent::Datastores.notice_sql(query, metrics, elapsed)
    #
    # @api public
    # @note THERE ARE SECURITY CONCERNS WHEN CAPTURING QUERY TEXT!
    #   New Relic's Transaction Tracing and Slow SQL features will
    #   attempt to apply obfuscation to the passed queries, but it is possible
    #   for a query format to be unsupported and result in exposing user
    #   information embedded within captured queries.
    # @param query [String] the SQL text to be captured. Note that depending
    #   on user settings, this string will be run through obfuscation, but
    #   some dialects of SQL (or non-SQL queries) are not guaranteed to be
    #   properly obfuscated by these routines!
    # @param scoped_metric [String] The most specific metric relating to this
    #   query. Typically the result of
    #   NewRelic::Agent::Datastores::MetricHelper#metrics_for
    # @param elapsed [Float] the elapsed time during query execution
    #
    # source://newrelic_rpm//lib/new_relic/agent/datastores.rb#162
    def notice_sql(query, scoped_metric, elapsed); end

    # Wrapper for simplifying attaching non-SQL data statements to a
    # transaction. For instance, Mongo or CQL queries, Memcached or Redis
    # keys would all be appropriate data to attach as statements.
    #
    # Data passed to this method is NOT obfuscated by New Relic, so please
    # ensure that user information is obfuscated if the agent setting
    # `transaction_tracer.record_sql` is set to `obfuscated`
    #
    #   NewRelic::Agent::Datastores.notice_statement("key", elapsed)
    #
    # @api public
    # @note THERE ARE SECURITY CONCERNS WHEN CAPTURING STATEMENTS!
    #   This method will properly ignore statements when the user has turned
    #   off capturing queries, but it is not able to obfuscate arbitrary data!
    #   To prevent exposing user information embedded in captured queries,
    #   please ensure all data passed to this method is safe to transmit to
    #   New Relic.
    # @param statement [String] text of the statement to capture.
    # @param elapsed [Float] the elapsed time during query execution
    #
    # source://newrelic_rpm//lib/new_relic/agent/datastores.rb#194
    def notice_statement(statement, elapsed); end

    # Add Datastore tracing to a method. This properly generates the metrics
    # for New Relic's Datastore features. It does not capture the actual
    # query content into Transaction Traces. Use wrap if you want to provide
    # that functionality.
    #
    # @api public
    # @param klass [Class] the class to instrument
    # @param method_name [String, Symbol] the name of instance method to
    #   instrument
    # @param product [String] name of your datastore for use in metric naming, e.g. "Redis"
    # @param operation [optional, String] the name of operation if different
    #   than the instrumented method name
    #
    # source://newrelic_rpm//lib/new_relic/agent/datastores.rb#35
    def trace(klass, method_name, product, operation = T.unsafe(nil)); end

    # Wrap a call to a datastore and record New Relic Datastore metrics. This
    # method can be used when a collection (i.e. table or model name) is
    # known at runtime to be included in the metric naming. It is intended
    # for situations that the simpler NewRelic::Agent::Datastores.trace can't
    # properly handle.
    #
    # To use this, wrap the datastore operation in the block passed to wrap.
    #
    #   NewRelic::Agent::Datastores.wrap("FauxDB", "find", "items") do
    #     FauxDB.find(query)
    #   end
    #
    # @api public
    # @note THERE ARE SECURITY CONCERNS WHEN CAPTURING QUERY TEXT!
    #   New Relic's Transaction Tracing and Slow SQL features will
    #   attempt to apply obfuscation to the passed queries, but it is possible
    #   for a query format to be unsupported and result in exposing user
    #   information embedded within captured queries.
    # @param product [String] the datastore name for use in metric naming,
    #   e.g. "FauxDB"
    # @param operation [String, Symbol] the name of operation (e.g. "select"),
    #   often named after the method that's being instrumented.
    # @param collection [optional, String] the collection name for use in
    #   statement-level metrics (i.e. table or model name)
    # @param callback [Proc, #call] proc or other callable to invoke after
    #   running the datastore block. Receives three arguments: result of the
    #   yield, the most specific (scoped) metric name, and elapsed time of the
    #   call. An example use is attaching SQL to Transaction Traces at the end
    #   of a wrapped datastore call.
    #
    #   callback = Proc.new do |result, metrics, elapsed|
    #   NewRelic::Agent::Datastores.notice_sql(query, metrics, elapsed)
    #   end
    #
    #   NewRelic::Agent::Datastores.wrap("FauxDB", "find", "items", callback) do
    #   FauxDB.find(query)
    #   end
    #
    # source://newrelic_rpm//lib/new_relic/agent/datastores.rb#109
    def wrap(product, operation, collection = T.unsafe(nil), callback = T.unsafe(nil)); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/datastores/metric_helper.rb#8
module NewRelic::Agent::Datastores::MetricHelper
  class << self
    # source://newrelic_rpm//lib/new_relic/agent/datastores/metric_helper.rb#40
    def all_suffix; end

    # source://newrelic_rpm//lib/new_relic/agent/datastores/metric_helper.rb#24
    def instance_metric_for(product, host, port_path_or_id); end

    # source://newrelic_rpm//lib/new_relic/agent/datastores/metric_helper.rb#84
    def metrics_for(product, operation, collection = T.unsafe(nil), generic_product = T.unsafe(nil), host = T.unsafe(nil), port_path_or_id = T.unsafe(nil)); end

    # source://newrelic_rpm//lib/new_relic/agent/datastores/metric_helper.rb#95
    def metrics_from_sql(product, sql); end

    # source://newrelic_rpm//lib/new_relic/agent/datastores/metric_helper.rb#100
    def operation_from_sql(sql); end

    # source://newrelic_rpm//lib/new_relic/agent/datastores/metric_helper.rb#20
    def operation_metric_for(product, operation); end

    # Allow Transaction#with_database_metric_name to override our
    # collection and operation
    #
    # source://newrelic_rpm//lib/new_relic/agent/datastores/metric_helper.rb#108
    def overridden_operation_and_collection; end

    # source://newrelic_rpm//lib/new_relic/agent/datastores/metric_helper.rb#74
    def product_operation_collection_for(product, operation, collection = T.unsafe(nil), generic_product = T.unsafe(nil)); end

    # source://newrelic_rpm//lib/new_relic/agent/datastores/metric_helper.rb#32
    def product_rollup(product); end

    # source://newrelic_rpm//lib/new_relic/agent/datastores/metric_helper.rb#28
    def product_suffixed_rollup(product, suffix); end

    # source://newrelic_rpm//lib/new_relic/agent/datastores/metric_helper.rb#48
    def scoped_metric_for(product, operation, collection = T.unsafe(nil)); end

    # If the override declared a product affiliation, abide by that
    # ActiveRecord has database-specific product names, so we recognize
    # it by the generic_product it passes.
    #
    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/datastores/metric_helper.rb#116
    def should_override?(overrides, product, generic_product); end

    # source://newrelic_rpm//lib/new_relic/agent/datastores/metric_helper.rb#16
    def statement_metric_for(product, collection, operation); end

    # source://newrelic_rpm//lib/new_relic/agent/datastores/metric_helper.rb#36
    def suffixed_rollup(suffix); end

    # source://newrelic_rpm//lib/new_relic/agent/datastores/metric_helper.rb#56
    def unscoped_metrics_for(product, operation, collection = T.unsafe(nil), host = T.unsafe(nil), port_path_or_id = T.unsafe(nil)); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/datastores/metric_helper.rb#12
NewRelic::Agent::Datastores::MetricHelper::ALL = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/datastores/metric_helper.rb#14
NewRelic::Agent::Datastores::MetricHelper::ALL_OTHER = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/datastores/metric_helper.rb#13
NewRelic::Agent::Datastores::MetricHelper::ALL_WEB = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/datastores/metric_helper.rb#10
NewRelic::Agent::Datastores::MetricHelper::OTHER = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/datastores/metric_helper.rb#9
NewRelic::Agent::Datastores::MetricHelper::ROLLUP_METRIC = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/deprecator.rb#7
module NewRelic::Agent::Deprecator
  class << self
    # source://newrelic_rpm//lib/new_relic/agent/deprecator.rb#8
    def deprecate(method_name, new_method_name = T.unsafe(nil), version = T.unsafe(nil)); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_attributes.rb#7
module NewRelic::Agent::DistributedTraceAttributes
  extend ::NewRelic::Agent::DistributedTraceAttributes

  # This method takes all distributed tracing intrinsics from the transaction
  # and the trace_payload, and populates them into the destination
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_attributes.rb#49
  def copy_from_transaction(transaction, trace_payload, destination); end

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_attributes.rb#61
  def copy_parent_attributes(transaction, trace_payload, destination); end

  # This method extracts intrinsics from the transaction_payload and
  # inserts them as intrinsics in the specified transaction_attributes
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_attributes.rb#37
  def copy_to_attributes(transaction_payload, destination); end

  # This method extracts intrinsics from the transaction_payload and
  # inserts them into the specified destination.
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_attributes.rb#26
  def copy_to_hash(transaction_payload, destination); end

  private

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_attributes.rb#79
  def enabled?; end
end

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_attributes.rb#17
NewRelic::Agent::DistributedTraceAttributes::GUID_KEY = T.let(T.unsafe(nil), String)

# Intrinsic Keys
#
# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_attributes.rb#11
NewRelic::Agent::DistributedTraceAttributes::INTRINSIC_KEYS = T.let(T.unsafe(nil), Array)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_attributes.rb#14
NewRelic::Agent::DistributedTraceAttributes::PARENT_ACCOUNT_ID_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_attributes.rb#13
NewRelic::Agent::DistributedTraceAttributes::PARENT_APP_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_attributes.rb#20
NewRelic::Agent::DistributedTraceAttributes::PARENT_SPAN_ID_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_attributes.rb#19
NewRelic::Agent::DistributedTraceAttributes::PARENT_TRANSACTION_ID_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_attributes.rb#16
NewRelic::Agent::DistributedTraceAttributes::PARENT_TRANSPORT_DURATION_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_attributes.rb#15
NewRelic::Agent::DistributedTraceAttributes::PARENT_TRANSPORT_TYPE_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_attributes.rb#12
NewRelic::Agent::DistributedTraceAttributes::PARENT_TYPE_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_attributes.rb#21
NewRelic::Agent::DistributedTraceAttributes::SAMPLED_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_attributes.rb#18
NewRelic::Agent::DistributedTraceAttributes::TRACE_ID_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_metrics.rb#7
module NewRelic::Agent::DistributedTraceMetrics
  extend ::NewRelic::Agent::DistributedTraceMetrics

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_metrics.rb#35
  def prefix_for_metric(name, transaction, payload); end

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_metrics.rb#47
  def record_caller_by_duration_metrics(transaction, payload); end

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_metrics.rb#60
  def record_errors_by_caller_metrics(transaction, payload); end

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_metrics.rb#24
  def record_metrics_for_transaction(transaction); end

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_metrics.rb#52
  def record_transport_duration_metrics(transaction, payload); end

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_metrics.rb#16
  def transaction_type_suffix; end

  private

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_metrics.rb#69
  def record_unscoped_metric(transaction, prefix, duration); end
end

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_metrics.rb#12
NewRelic::Agent::DistributedTraceMetrics::ALL_OTHER_SUFFIX = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_metrics.rb#10
NewRelic::Agent::DistributedTraceMetrics::ALL_SUFFIX = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_metrics.rb#11
NewRelic::Agent::DistributedTraceMetrics::ALL_WEB_SUFFIX = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_metrics.rb#14
NewRelic::Agent::DistributedTraceMetrics::UNKNOWN_CALLER_PREFIX = T.let(T.unsafe(nil), String)

# This class contains properties related to distributed traces.
# To obtain an instance, call
# {DistributedTracing#create_distributed_trace_payload}
#
# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#16
class NewRelic::Agent::DistributedTracePayload
  extend ::NewRelic::Coerce

  # Encode this payload as a string suitable for passing via an
  # HTTP header.
  #
  # @api public
  # @return [String] Payload translated to JSON and encoded for
  #   inclusion in headers
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#158
  def http_safe; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#110
  def id; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#110
  def id=(_arg0); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#110
  def parent_account_id; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#110
  def parent_account_id=(_arg0); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#110
  def parent_app_id; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#110
  def parent_app_id=(_arg0); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#110
  def parent_type; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#110
  def parent_type=(_arg0); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#110
  def priority; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#110
  def priority=(_arg0); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#110
  def sampled; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#110
  def sampled=(_arg0); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#110
  def sampled?; end

  # Represent this payload as a raw JSON string.
  #
  # @api public
  # @return [String] Payload translated to JSON
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#129
  def text; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#110
  def timestamp; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#110
  def timestamp=(_arg0); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#110
  def trace_id; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#110
  def trace_id=(_arg0); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#110
  def transaction_id; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#110
  def transaction_id=(_arg0); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#110
  def trusted_account_key; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#110
  def trusted_account_key=(_arg0); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#110
  def version; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#110
  def version=(_arg0); end

  class << self
    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#37
    def for_transaction(transaction); end

    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#80
    def from_http_safe(http_safe_payload); end

    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#58
    def from_json(serialized_payload); end

    # @api public
    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#85
    def major_version_matches?(payload); end

    private

    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#91
    def assign_trusted_account_key(payload, account_id); end

    # @api public
    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#105
    def connected?; end

    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#99
    def current_segment_id(transaction); end
  end
end

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#24
NewRelic::Agent::DistributedTracePayload::DATA_KEY = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#29
NewRelic::Agent::DistributedTracePayload::ID_KEY = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#26
NewRelic::Agent::DistributedTracePayload::PARENT_ACCOUNT_ID_KEY = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#27
NewRelic::Agent::DistributedTracePayload::PARENT_APP_KEY = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#20
NewRelic::Agent::DistributedTracePayload::PARENT_TYPE = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#25
NewRelic::Agent::DistributedTracePayload::PARENT_TYPE_KEY = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#34
NewRelic::Agent::DistributedTracePayload::PRIORITY_KEY = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#32
NewRelic::Agent::DistributedTracePayload::SAMPLED_KEY = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#33
NewRelic::Agent::DistributedTracePayload::TIMESTAMP_KEY = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#31
NewRelic::Agent::DistributedTracePayload::TRACE_ID_KEY = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#28
NewRelic::Agent::DistributedTracePayload::TRUSTED_ACCOUNT_KEY = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#30
NewRelic::Agent::DistributedTracePayload::TX_KEY = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#19
NewRelic::Agent::DistributedTracePayload::VERSION = T.let(T.unsafe(nil), Array)

# Key names for serialization
#
# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_payload.rb#23
NewRelic::Agent::DistributedTracePayload::VERSION_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_transport_type.rb#7
module NewRelic::Agent::DistributedTraceTransportType
  extend ::NewRelic::Agent::DistributedTraceTransportType

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_transport_type.rb#33
  def for_rack_request(request); end

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_transport_type.rb#29
  def from(value); end
end

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_transport_type.rb#10
NewRelic::Agent::DistributedTraceTransportType::ALLOWABLE_TRANSPORT_TYPES = T.let(T.unsafe(nil), Array)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_transport_type.rb#27
NewRelic::Agent::DistributedTraceTransportType::RACK_URL_SCHEME = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/distributed_trace_transport_type.rb#22
NewRelic::Agent::DistributedTraceTransportType::URL_SCHEMES = T.let(T.unsafe(nil), Hash)

# This module contains helper methods related to Distributed
# Tracing, an APM feature that ties together traces from multiple
# apps in one view.  Use it to add distributed tracing to protocols
# not already supported by the agent.
#
# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#9
module NewRelic::Agent::DistributedTracing
  extend ::NewRelic::SupportabilityHelper
  extend ::NewRelic::Agent::DistributedTracing

  # Accepts distributed tracing headers from any source that has been packaged
  # as a Ruby Hash, thereby allowing the user to manually inject distributed
  # tracing headers.  It is optimized to process +HTTP_TRACEPARENT+, +HTTP_TRACESTATE+,
  # and +HTTP_NEWRELIC+ as the given Hash keys.  which is the most common scenario
  # from Rack middleware in most Ruby applications.  However, the Hash keys are
  # case-insensitive and the "HTTP_" prefixes may also be omitted.
  #
  # Calling this method is not necessary in a typical HTTP trace as
  # distributed tracing is already handled by the agent.
  #
  # When used, invoke this method as early as possible in a transaction's life-cycle
  # as calling after the headers are already created will have no effect.
  #
  # This method accepts both W3C trace context and New Relic distributed tracing headers.
  # When both are present, only the W3C headers are utilized.  When W3C trace context
  # headers are present, New Relic headers are ignored regardless if W3C trace context
  # headers are valid and parsable.
  #
  # @api public
  # @param headers [Hash] Incoming distributed trace headers as a Ruby
  #   Hash object.  Hash keys are expected to be one of
  #   +TRACEPARENT+, +TRACESTATE+, +NEWRELIC+ and are
  #   case-insensitive, with or without "HTTP_" prefixes.
  #
  #   either as a JSON string or as a
  #   header-friendly string returned from
  #   {DistributedTracePayload#http_safe}
  # @param transport_type [String] May be one of:  +HTTP+, +HTTPS+, +Kafka+, +JMS+,
  #   +IronMQ+, +AMQP+, +Queue+, +Other+.  Values are
  #   case sensitive.  All other values result in +Unknown+
  # @return [Transaction] if successful, +nil+ otherwise
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing.rb#98
  def accept_distributed_trace_headers(headers, transport_type = T.unsafe(nil)); end

  # Adds the Distributed Trace headers so that the downstream service can participate in a
  # distributed trace. This method should be called every time an outbound call is made
  # since the header payload contains a timestamp.
  #
  # Distributed Tracing must be enabled to use this method.
  #
  # +insert_distributed_trace_headers+ always inserts W3C trace context headers and inserts
  # New Relic distributed tracing header by default. New Relic headers may be suppressed by
  # setting +exclude_new_relic_header+ to +true+ in your configuration file.
  #
  # @api public
  # @param headers [Hash] Is a Hash to which the distributed trace headers
  #   will be inserted.
  # @return [Transaction] The transaction the headers were inserted from,
  #   or +nil+ if headers were not inserted.
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing.rb#44
  def insert_distributed_trace_headers(headers = T.unsafe(nil)); end

  private

  # @api public
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing.rb#139
  def has_variant_key?(key, variants); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing.rb#143
  def variant_key_value(headers, variants); end
end

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/monitors/cross_app_monitor.rb#14
class NewRelic::Agent::DistributedTracing::CrossAppMonitor < ::NewRelic::Agent::InboundRequestMonitor
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/monitors/cross_app_monitor.rb#22
  def on_finished_configuring(events); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/monitors/cross_app_monitor.rb#33
  def path_hash(txn_name, seed); end

  private

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/monitors/cross_app_monitor.rb#107
  def content_length_from_request(request); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/monitors/cross_app_monitor.rb#100
  def decoded_id(request); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/monitors/cross_app_monitor.rb#111
  def hash_transaction_name(identifier); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/monitors/cross_app_monitor.rb#76
  def insert_response_header(state, request_headers, response_headers); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/monitors/cross_app_monitor.rb#71
  def referring_transaction_info(state, request_headers); end

  # Expected sequence of events:
  #   :before_call will save our cross application request id to the thread
  #   :after_call will write our response headers/metrics and clean up the thread
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/monitors/cross_app_monitor.rb#45
  def register_event_listeners(events); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/monitors/cross_app_monitor.rb#90
  def set_response_headers(transaction, response_headers, content_length); end

  # @api public
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/monitors/cross_app_monitor.rb#86
  def should_process_request?(id); end
end

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/monitors/cross_app_monitor.rb#20
NewRelic::Agent::DistributedTracing::CrossAppMonitor::CONTENT_LENGTH_HEADER_KEY = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/monitors/cross_app_monitor.rb#16
NewRelic::Agent::DistributedTracing::CrossAppMonitor::NEWRELIC_APPDATA_HEADER = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/monitors/cross_app_monitor.rb#18
NewRelic::Agent::DistributedTracing::CrossAppMonitor::NEWRELIC_ID_HEADER_KEY = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/monitors/cross_app_monitor.rb#15
NewRelic::Agent::DistributedTracing::CrossAppMonitor::NEWRELIC_TXN_HEADER = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/monitors/cross_app_monitor.rb#19
NewRelic::Agent::DistributedTracing::CrossAppMonitor::NEWRELIC_TXN_HEADER_KEY = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/monitors/distributed_tracing_monitor.rb#8
class NewRelic::Agent::DistributedTracing::Monitor < ::NewRelic::Agent::InboundRequestMonitor
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/monitors/distributed_tracing_monitor.rb#15
  def on_before_call(request); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/monitors/distributed_tracing_monitor.rb#9
  def on_finished_configuring(events); end
end

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#10
class NewRelic::Agent::DistributedTracing::TraceContext
  class << self
    # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#80
    def create_trace_state_entry(entry_key, payload); end

    # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#42
    def insert(format: T.unsafe(nil), carrier: T.unsafe(nil), parent_id: T.unsafe(nil), trace_id: T.unsafe(nil), trace_flags: T.unsafe(nil), trace_state: T.unsafe(nil)); end

    # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#60
    def parse(format: T.unsafe(nil), carrier: T.unsafe(nil), trace_state_entry_key: T.unsafe(nil)); end

    private

    # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#167
    def decode_payload(payload); end

    # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#96
    def extract_traceparent(format, carrier); end

    # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#134
    def extract_tracestate(format, carrier, trace_state_entry_key); end

    # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#86
    def format_trace_parent(trace_id: T.unsafe(nil), parent_id: T.unsafe(nil), trace_flags: T.unsafe(nil)); end

    # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#118
    def trace_parent_header_for_format(format); end

    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#108
    def trace_parent_valid?(trace_parent); end

    # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#126
    def trace_state_header_for_format(format); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#13
NewRelic::Agent::DistributedTracing::TraceContext::COMMA = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#14
NewRelic::Agent::DistributedTracing::TraceContext::EQUALS = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#177
class NewRelic::Agent::DistributedTracing::TraceContext::HeaderData
  # @return [HeaderData] a new instance of HeaderData
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#192
  def initialize(trace_parent, trace_state_payload, trace_state_entries, trace_state_size, trace_state_vendors); end

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#214
  def parent_id; end

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#210
  def trace_id; end

  # Returns the value of attribute trace_parent.
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#201
  def trace_parent; end

  # Sets the attribute trace_parent
  #
  # @param value the value to set the attribute trace_parent to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#201
  def trace_parent=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#203
  def trace_state(trace_state_entry); end

  # Returns the value of attribute trace_state_payload.
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#201
  def trace_state_payload; end

  # Sets the attribute trace_state_payload
  #
  # @param value the value to set the attribute trace_state_payload to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#201
  def trace_state_payload=(_arg0); end

  # Returns the value of attribute trace_state_vendors.
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#201
  def trace_state_vendors; end

  # Sets the attribute trace_state_vendors
  #
  # @param value the value to set the attribute trace_state_vendors to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#201
  def trace_state_vendors=(_arg0); end

  private

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#220
  def join_trace_state(trace_state_entry_size); end

  class << self
    # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#179
    def create(trace_parent: T.unsafe(nil), trace_state_payload: T.unsafe(nil), trace_state_entries: T.unsafe(nil), trace_state_size: T.unsafe(nil), trace_state_vendors: T.unsafe(nil)); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#16
NewRelic::Agent::DistributedTracing::TraceContext::INVALID_PARENT_ID = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#15
NewRelic::Agent::DistributedTracing::TraceContext::INVALID_TRACE_ID = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#17
NewRelic::Agent::DistributedTracing::TraceContext::INVALID_VERSION = T.let(T.unsafe(nil), String)

# bytes
#
# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#35
NewRelic::Agent::DistributedTracing::TraceContext::MAX_TRACE_STATE_ENTRY_SIZE = T.let(T.unsafe(nil), Integer)

# bytes
#
# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#34
NewRelic::Agent::DistributedTracing::TraceContext::MAX_TRACE_STATE_SIZE = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#21
NewRelic::Agent::DistributedTracing::TraceContext::PARENT_ID_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#37
NewRelic::Agent::DistributedTracing::TraceContext::SUPPORTABILITY_TRACE_PARENT_PARSE_EXCEPTION = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#39
NewRelic::Agent::DistributedTracing::TraceContext::SUPPORTABILITY_TRACE_STATE_INVALID_NR_ENTRY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#38
NewRelic::Agent::DistributedTracing::TraceContext::SUPPORTABILITY_TRACE_STATE_PARSE_EXCEPTION = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#27
NewRelic::Agent::DistributedTracing::TraceContext::TP_PARENT_ID = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#28
NewRelic::Agent::DistributedTracing::TraceContext::TP_TRACE_FLAGS = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#26
NewRelic::Agent::DistributedTracing::TraceContext::TP_TRACE_ID = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#29
NewRelic::Agent::DistributedTracing::TraceContext::TP_UNDEFINED_FIELDS = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#25
NewRelic::Agent::DistributedTracing::TraceContext::TP_VERSION = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#20
NewRelic::Agent::DistributedTracing::TraceContext::TRACE_FLAGS_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#19
NewRelic::Agent::DistributedTracing::TraceContext::TRACE_ID_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#32
NewRelic::Agent::DistributedTracing::TraceContext::TRACE_PARENT_FORMAT_STRING = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#30
NewRelic::Agent::DistributedTracing::TraceContext::TRACE_PARENT_REGEX = T.let(T.unsafe(nil), Regexp)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#23
NewRelic::Agent::DistributedTracing::TraceContext::UNDEFINED_FIELDS_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#11
NewRelic::Agent::DistributedTracing::TraceContext::VERSION = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context.rb#22
NewRelic::Agent::DistributedTracing::TraceContext::VERSION_KEY = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent.rb#813
NewRelic::Agent::ENTITY_GUID_KEY = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent.rb#811
NewRelic::Agent::ENTITY_NAME_KEY = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent.rb#816
NewRelic::Agent::ENTITY_TYPE = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent.rb#812
NewRelic::Agent::ENTITY_TYPE_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/encoding_normalizer.rb#9
module NewRelic::Agent::EncodingNormalizer
  class << self
    # source://newrelic_rpm//lib/new_relic/agent/encoding_normalizer.rb#14
    def normalize_object(object); end

    # source://newrelic_rpm//lib/new_relic/agent/encoding_normalizer.rb#10
    def normalize_string(raw_string); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/encoding_normalizer.rb#41
module NewRelic::Agent::EncodingNormalizer::EncodingNormalizer
  class << self
    # source://newrelic_rpm//lib/new_relic/agent/encoding_normalizer.rb#42
    def normalize(raw_string); end
  end
end

# This class collects errors from the parent application, storing
# them until they are harvested and transmitted to the server
#
# source://newrelic_rpm//lib/new_relic/agent/error_collector.rb#12
class NewRelic::Agent::ErrorCollector
  # Returns a new error collector
  #
  # @return [ErrorCollector] a new instance of ErrorCollector
  #
  # source://newrelic_rpm//lib/new_relic/agent/error_collector.rb#22
  def initialize(events); end

  # source://newrelic_rpm//lib/new_relic/agent/error_collector.rb#158
  def aggregated_metric_names(txn); end

  # source://newrelic_rpm//lib/new_relic/agent/error_collector.rb#150
  def blamed_metric_name(txn, options); end

  # source://newrelic_rpm//lib/new_relic/agent/error_collector.rb#268
  def create_noticed_error(exception, options); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/error_collector.rb#42
  def disabled?; end

  # source://newrelic_rpm//lib/new_relic/agent/error_collector.rb#306
  def drop_buffered_data; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/error_collector.rb#38
  def enabled?; end

  # Returns the value of attribute error_event_aggregator.
  #
  # source://newrelic_rpm//lib/new_relic/agent/error_collector.rb#19
  def error_event_aggregator; end

  # an error is ignored if it is nil or if it is filtered
  #
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/error_collector.rb#106
  def error_is_ignored?(error, status_code = T.unsafe(nil)); end

  # Returns the value of attribute error_trace_aggregator.
  #
  # source://newrelic_rpm//lib/new_relic/agent/error_collector.rb#19
  def error_trace_aggregator; end

  # Calling instance_variable_set on a wrapped Java object in JRuby will
  # generate a warning unless that object's class has already been marked
  # as persistent, so we skip tagging of exception objects that are actually
  # wrapped Java objects on JRuby.
  #
  # See https://github.com/jruby/jruby/wiki/Persistence
  #
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/error_collector.rb#120
  def exception_is_java_object?(exception); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/error_collector.rb#124
  def exception_tagged_with?(ivar, exception); end

  # source://newrelic_rpm//lib/new_relic/agent/error_collector.rb#83
  def expect(errors); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/error_collector.rb#87
  def expected?(ex, status_code = T.unsafe(nil)); end

  # extracts a stack trace from the exception for debugging purposes
  #
  # source://newrelic_rpm//lib/new_relic/agent/error_collector.rb#207
  def extract_stack_trace(exception); end

  # source://newrelic_rpm//lib/new_relic/agent/error_collector.rb#75
  def ignore(errors); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/error_collector.rb#79
  def ignore?(ex, status_code = T.unsafe(nil)); end

  # Checks the provided error against the error filter, if there
  # is an error filter
  #
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/error_collector.rb#101
  def ignored_by_filter_proc?(error); end

  # Increments a statistic that tracks total error rate
  #
  # source://newrelic_rpm//lib/new_relic/agent/error_collector.rb#172
  def increment_error_count!(state, exception, options = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/error_collector.rb#185
  def increment_expected_error_count!(state, exception); end

  # source://newrelic_rpm//lib/new_relic/agent/error_collector.rb#91
  def load_error_filters; end

  # *Use sparingly for difficult to track bugs.*
  #
  # Track internal agent errors for communication back to New Relic.
  # To use, make a specific subclass of NewRelic::Agent::InternalAgentError,
  # then pass an instance of it to this method when your problem occurs.
  #
  # Limits are treated differently for these errors. We only gather one per
  # class per harvest, disregarding (and not impacting) the app error queue
  # limit.
  #
  # source://newrelic_rpm//lib/new_relic/agent/error_collector.rb#302
  def notice_agent_error(exception); end

  # See NewRelic::Agent.notice_error for options and commentary
  #
  # source://newrelic_rpm//lib/new_relic/agent/error_collector.rb#227
  def notice_error(exception, options = T.unsafe(nil), span_id = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/error_collector.rb#216
  def notice_segment_error(segment, exception, options = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/error_collector.rb#95
  def reset_error_filters; end

  # calls a method on an object, if it responds to it - used for
  # detection and soft fail-safe. Returns nil if the method does
  # not exist
  #
  # source://newrelic_rpm//lib/new_relic/agent/error_collector.rb#202
  def sense_method(object, method); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/error_collector.rb#192
  def skip_notice_error?(exception, status_code = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/error_collector.rb#140
  def tag_exception(exception); end

  # source://newrelic_rpm//lib/new_relic/agent/error_collector.rb#130
  def tag_exception_using(ivar, exception); end

  # source://newrelic_rpm//lib/new_relic/agent/error_collector.rb#254
  def truncate_trace(trace, keep_frames = T.unsafe(nil)); end

  private

  # source://newrelic_rpm//lib/new_relic/agent/error_collector.rb#324
  def build_customer_callback_hash(noticed_error, exception, options); end

  # source://newrelic_rpm//lib/new_relic/agent/error_collector.rb#334
  def error_group_callback; end

  # source://newrelic_rpm//lib/new_relic/agent/error_collector.rb#314
  def update_error_group_name(noticed_error, exception, options); end

  class << self
    # source://newrelic_rpm//lib/new_relic/agent/error_collector.rb#71
    def ignore_error_filter; end

    # We store the passed block in both an ivar on the class, and implicitly
    # within the body of the ignore_filter_proc method intentionally here.
    # The define_method trick is needed to get around the fact that users may
    # call 'return' from within their filter blocks, which would otherwise
    # result in a LocalJumpError.
    #
    # The raw block is also stored in an instance variable so that we can
    # return it later in its original form.
    #
    # This is all done at the class level in order to avoid the case where
    # the user sets up an ignore filter on one instance of the ErrorCollector,
    # and then that instance subsequently gets discarded during agent startup.
    # (For example, if the agent is initially disabled, and then gets enabled
    # via a call to manual_start later on.)
    #
    # source://newrelic_rpm//lib/new_relic/agent/error_collector.rb#61
    def ignore_error_filter=(block); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/error_collector.rb#17
NewRelic::Agent::ErrorCollector::EXCEPTION_TAG_IVAR = T.let(T.unsafe(nil), Symbol)

# Maximum possible length of the queue - defaults to 20, may be
# made configurable in the future. This is a tradeoff between
# memory and data retention
#
# source://newrelic_rpm//lib/new_relic/agent/error_collector.rb#16
NewRelic::Agent::ErrorCollector::MAX_ERROR_QUEUE_LENGTH = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/agent/error_event_aggregator.rb#12
class NewRelic::Agent::ErrorEventAggregator < ::NewRelic::Agent::EventAggregator
  include ::NewRelic::Coerce

  # source://newrelic_rpm//lib/new_relic/agent/error_event_aggregator.rb#21
  def record(noticed_error, transaction_payload = T.unsafe(nil), span_id = T.unsafe(nil)); end

  private

  # source://newrelic_rpm//lib/new_relic/agent/error_event_aggregator.rb#36
  def create_event(noticed_error, transaction_payload, span_id); end
end

# Handles loading of ignored and expected errors from the agent configuration, and
# determining at runtime whether an exception is ignored or expected.
#
# source://newrelic_rpm//lib/new_relic/agent/error_filter.rb#9
class NewRelic::Agent::ErrorFilter
  # @return [ErrorFilter] a new instance of ErrorFilter
  #
  # source://newrelic_rpm//lib/new_relic/agent/error_filter.rb#10
  def initialize; end

  # See #ignore above.
  #
  # source://newrelic_rpm//lib/new_relic/agent/error_filter.rb#96
  def expect(*args); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/error_filter.rb#58
  def expected?(ex, status_code = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/error_filter.rb#65
  def fetch_agent_config(cfg); end

  # A generic method for adding ignore filters manually. This is kept for compatibility
  # with the previous ErrorCollector#ignore method, and adds some flexibility for adding
  # different ignore/expected error types by examining each argument.
  #
  # source://newrelic_rpm//lib/new_relic/agent/error_filter.rb#72
  def ignore(*args); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/error_filter.rb#51
  def ignore?(ex, status_code = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/error_filter.rb#20
  def load_all; end

  # source://newrelic_rpm//lib/new_relic/agent/error_filter.rb#27
  def load_from_config(setting, value = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/error_filter.rb#14
  def reset; end

  private

  # source://newrelic_rpm//lib/new_relic/agent/error_filter.rb#121
  def log_filter(setting, errors); end

  # source://newrelic_rpm//lib/new_relic/agent/error_filter.rb#146
  def parse_status_codes(codes); end
end

# source://newrelic_rpm//lib/new_relic/agent/error_trace_aggregator.rb#8
class NewRelic::Agent::ErrorTraceAggregator
  # @return [ErrorTraceAggregator] a new instance of ErrorTraceAggregator
  #
  # source://newrelic_rpm//lib/new_relic/agent/error_trace_aggregator.rb#9
  def initialize(capacity); end

  # Synchronizes adding an error to the error queue, and checks if
  # the error queue is too long - if so, we drop the error on the
  # floor after logging a warning.
  #
  # source://newrelic_rpm//lib/new_relic/agent/error_trace_aggregator.rb#45
  def add_to_error_queue(noticed_error); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/error_trace_aggregator.rb#16
  def enabled?; end

  # Get the errors currently queued up.  Unsent errors are left
  # over from a previous unsuccessful attempt to send them to the server.
  #
  # source://newrelic_rpm//lib/new_relic/agent/error_trace_aggregator.rb#28
  def harvest!; end

  # source://newrelic_rpm//lib/new_relic/agent/error_trace_aggregator.rb#20
  def merge!(errors); end

  # *Use sparingly for difficult to track bugs.*
  #
  # Track internal agent errors for communication back to New Relic.
  # To use, make a specific subclass of NewRelic::Agent::InternalAgentError,
  # then pass an instance of it to this method when your problem occurs.
  #
  # Limits are treated differently for these errors. We only gather one per
  # class per harvest, disregarding (and not impacting) the app error queue
  # limit.
  #
  # source://newrelic_rpm//lib/new_relic/agent/error_trace_aggregator.rb#74
  def notice_agent_error(exception); end

  # checks the size of the error queue to make sure we are under
  # the maximum limit, and logs a warning if we are over the limit.
  #
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/error_trace_aggregator.rb#57
  def over_queue_limit?(message); end

  # source://newrelic_rpm//lib/new_relic/agent/error_trace_aggregator.rb#94
  def register_config_callbacks; end

  # source://newrelic_rpm//lib/new_relic/agent/error_trace_aggregator.rb#36
  def reset!; end
end

# source://newrelic_rpm//lib/new_relic/agent/event_aggregator.rb#9
class NewRelic::Agent::EventAggregator
  # @return [EventAggregator] a new instance of EventAggregator
  #
  # source://newrelic_rpm//lib/new_relic/agent/event_aggregator.rb#51
  def initialize(events); end

  # interface method for subclasses to override to provide post harvest functionality
  #
  # source://newrelic_rpm//lib/new_relic/agent/event_aggregator.rb#66
  def after_harvest(metadata); end

  # interface method for subclasses to override to provide post-initialization setup
  #
  # source://newrelic_rpm//lib/new_relic/agent/event_aggregator.rb#62
  def after_initialize; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/event_aggregator.rb#69
  def enabled?; end

  # source://newrelic_rpm//lib/new_relic/agent/event_aggregator.rb#77
  def harvest!; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/event_aggregator.rb#73
  def has_metadata?; end

  # Merges samples from payload back into buffer and optionally adjusts the count of
  # the buffer to ensure accuracy of buffer of metadata. We want to make sure not to
  # double count samples being merged back in from a failed harvest, yet we do not
  # want to under-count samples being merged from the PipeService.
  #
  # source://newrelic_rpm//lib/new_relic/agent/event_aggregator.rb#93
  def merge!(payload, adjust_count = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/event_aggregator.rb#105
  def reset!; end

  private

  # source://newrelic_rpm//lib/new_relic/agent/event_aggregator.rb#137
  def notify_if_full; end

  # source://newrelic_rpm//lib/new_relic/agent/event_aggregator.rb#120
  def register_capacity_callback; end

  # source://newrelic_rpm//lib/new_relic/agent/event_aggregator.rb#129
  def register_enabled_callback(events); end

  # source://newrelic_rpm//lib/new_relic/agent/event_aggregator.rb#113
  def reservoir_metadata(metadata); end

  # source://newrelic_rpm//lib/new_relic/agent/event_aggregator.rb#144
  def reset_buffer!; end

  class << self
    # source://newrelic_rpm//lib/new_relic/agent/event_aggregator.rb#42
    def buffer_class(klass = T.unsafe(nil)); end

    # source://newrelic_rpm//lib/new_relic/agent/event_aggregator.rb#15
    def capacity_key(key = T.unsafe(nil)); end

    # This can be used instead of `enabled_key(s)` for more fine grained
    # control over whether an aggregator should be enabled. The enabled fn
    # will be reevaluated after configuration changes
    #
    # source://newrelic_rpm//lib/new_relic/agent/event_aggregator.rb#38
    def enabled_fn(fn = T.unsafe(nil)); end

    # An aggregator can specify one or more keys to check to see if it is
    # enabled. Multiple keys will be &&'d and the enabled status of the
    # aggregator will be reset when agent configuration changes.
    #
    # source://newrelic_rpm//lib/new_relic/agent/event_aggregator.rb#23
    def enabled_key(*keys); end

    # An aggregator can specify one or more keys to check to see if it is
    # enabled. Multiple keys will be &&'d and the enabled status of the
    # aggregator will be reset when agent configuration changes.
    #
    # source://newrelic_rpm//lib/new_relic/agent/event_aggregator.rb#23
    def enabled_keys(*keys); end

    # source://newrelic_rpm//lib/new_relic/agent/event_aggregator.rb#11
    def named(named = T.unsafe(nil)); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/event_buffer.rb#20
class NewRelic::Agent::EventBuffer
  # @return [EventBuffer] a new instance of EventBuffer
  #
  # source://newrelic_rpm//lib/new_relic/agent/event_buffer.rb#23
  def initialize(capacity); end

  # source://newrelic_rpm//lib/new_relic/agent/event_buffer.rb#48
  def <<(x); end

  # source://newrelic_rpm//lib/new_relic/agent/event_buffer.rb#43
  def append(x); end

  # Returns the value of attribute capacity.
  #
  # source://newrelic_rpm//lib/new_relic/agent/event_buffer.rb#21
  def capacity; end

  # source://newrelic_rpm//lib/new_relic/agent/event_buffer.rb#34
  def capacity=(new_capacity); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/event_buffer.rb#53
  def full?; end

  # source://newrelic_rpm//lib/new_relic/agent/event_buffer.rb#81
  def metadata; end

  # source://newrelic_rpm//lib/new_relic/agent/event_buffer.rb#61
  def note_dropped; end

  # source://newrelic_rpm//lib/new_relic/agent/event_buffer.rb#69
  def num_dropped; end

  # source://newrelic_rpm//lib/new_relic/agent/event_buffer.rb#65
  def num_seen; end

  # source://newrelic_rpm//lib/new_relic/agent/event_buffer.rb#29
  def reset!; end

  # source://newrelic_rpm//lib/new_relic/agent/event_buffer.rb#73
  def sample_rate; end

  # source://newrelic_rpm//lib/new_relic/agent/event_buffer.rb#57
  def size; end

  # source://newrelic_rpm//lib/new_relic/agent/event_buffer.rb#77
  def to_a; end
end

# Basic mechanism for the agent instance to provide agent-wide eventing.
# It is intended to keep different pieces of the app decoupled from each other.
#
# While an EventListener could be used elsewhere, it's strongly expected
# your eventing needs should be met by the agent's instance.
#
# source://newrelic_rpm//lib/new_relic/agent/event_listener.rb#11
class NewRelic::Agent::EventListener
  # @return [EventListener] a new instance of EventListener
  #
  # source://newrelic_rpm//lib/new_relic/agent/event_listener.rb#14
  def initialize; end

  # source://newrelic_rpm//lib/new_relic/agent/event_listener.rb#25
  def check_for_runaway_subscriptions(event); end

  # source://newrelic_rpm//lib/new_relic/agent/event_listener.rb#30
  def clear; end

  # source://newrelic_rpm//lib/new_relic/agent/event_listener.rb#34
  def notify(event, *args); end

  # Returns the value of attribute runaway_threshold.
  #
  # source://newrelic_rpm//lib/new_relic/agent/event_listener.rb#12
  def runaway_threshold; end

  # Sets the attribute runaway_threshold
  #
  # @param value the value to set the attribute runaway_threshold to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/event_listener.rb#12
  def runaway_threshold=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/agent/event_listener.rb#19
  def subscribe(event, &handler); end
end

# source://newrelic_rpm//lib/new_relic/agent/event_loop.rb#9
class NewRelic::Agent::EventLoop
  # @return [EventLoop] a new instance of EventLoop
  #
  # source://newrelic_rpm//lib/new_relic/agent/event_loop.rb#58
  def initialize; end

  # source://newrelic_rpm//lib/new_relic/agent/event_loop.rb#144
  def dispatch_event(event, args); end

  # source://newrelic_rpm//lib/new_relic/agent/event_loop.rb#171
  def fire(event, *args); end

  # source://newrelic_rpm//lib/new_relic/agent/event_loop.rb#181
  def fire_after(interval, event); end

  # source://newrelic_rpm//lib/new_relic/agent/event_loop.rb#176
  def fire_every(interval, event); end

  # source://newrelic_rpm//lib/new_relic/agent/event_loop.rb#133
  def fire_timer(timer); end

  # source://newrelic_rpm//lib/new_relic/agent/event_loop.rb#127
  def fire_timers; end

  # source://newrelic_rpm//lib/new_relic/agent/event_loop.rb#82
  def next_timeout; end

  # source://newrelic_rpm//lib/new_relic/agent/event_loop.rb#167
  def on(event, &blk); end

  # source://newrelic_rpm//lib/new_relic/agent/event_loop.rb#140
  def prune_timers; end

  # source://newrelic_rpm//lib/new_relic/agent/event_loop.rb#163
  def reschedule_timer_for_event(e); end

  # source://newrelic_rpm//lib/new_relic/agent/event_loop.rb#98
  def run; end

  # source://newrelic_rpm//lib/new_relic/agent/event_loop.rb#105
  def run_once(nonblock = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/event_loop.rb#69
  def set_timer(timer); end

  # source://newrelic_rpm//lib/new_relic/agent/event_loop.rb#93
  def stop; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/event_loop.rb#89
  def stopped?; end

  # source://newrelic_rpm//lib/new_relic/agent/event_loop.rb#118
  def wait_to_run(nonblock); end

  # source://newrelic_rpm//lib/new_relic/agent/event_loop.rb#186
  def wakeup; end
end

# source://newrelic_rpm//lib/new_relic/agent/event_loop.rb#10
class NewRelic::Agent::EventLoop::Timer
  # @return [Timer] a new instance of Timer
  #
  # source://newrelic_rpm//lib/new_relic/agent/event_loop.rb#13
  def initialize(interval, event, repeat = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/event_loop.rb#26
  def advance(amount); end

  # source://newrelic_rpm//lib/new_relic/agent/event_loop.rb#34
  def calculate_next_fire_time; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/event_loop.rb#49
  def due?(now = T.unsafe(nil)); end

  # Returns the value of attribute event.
  #
  # source://newrelic_rpm//lib/new_relic/agent/event_loop.rb#11
  def event; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/event_loop.rb#53
  def finished?; end

  # Returns the value of attribute interval.
  #
  # source://newrelic_rpm//lib/new_relic/agent/event_loop.rb#11
  def interval; end

  # Returns the value of attribute last_fired_at.
  #
  # source://newrelic_rpm//lib/new_relic/agent/event_loop.rb#11
  def last_fired_at; end

  # source://newrelic_rpm//lib/new_relic/agent/event_loop.rb#30
  def last_interval_start; end

  # Returns the value of attribute next_fire_time.
  #
  # source://newrelic_rpm//lib/new_relic/agent/event_loop.rb#11
  def next_fire_time; end

  # source://newrelic_rpm//lib/new_relic/agent/event_loop.rb#22
  def reschedule; end

  # source://newrelic_rpm//lib/new_relic/agent/event_loop.rb#45
  def set_fired_time; end
end

# This module contains helper methods to facilitate
# instrumentation of external requests not directly supported by
# the Ruby agent. It is intended to be primarily used by authors
# of 3rd-party instrumentation.
#
# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/external.rb#18
module NewRelic::Agent::External
  extend ::NewRelic::Agent::External

  # Obtain an obfuscated +String+ suitable for delivery across public networks that carries transaction
  # information from this application to a calling application which is also running a New Relic agent.
  # This +String+ can be processed by +process_response_metadata+ on the calling application.
  #
  # @api public
  # @return [String] obfuscated response metadata to send
  #
  # source://newrelic_rpm//lib/new_relic/agent/external.rb#79
  def get_response_metadata; end

  # Process obfuscated +String+ identifying a calling application and transaction that is also running a
  # New Relic agent and save information in current transaction for inclusion in a trace. The +String+ is
  # generated by +get_request_metadata+ on the calling application.
  #
  # @api public
  # @param request_metadata [String] received obfuscated request metadata
  #
  # source://newrelic_rpm//lib/new_relic/agent/external.rb#34
  def process_request_metadata(request_metadata); end

  private

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/external.rb#105
  def obfuscator; end
end

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/external.rb#24
NewRelic::Agent::External::NON_HTTP_CAT_CONTENT_LENGTH = T.let(T.unsafe(nil), Integer)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/external.rb#21
NewRelic::Agent::External::NON_HTTP_CAT_ID_HEADER = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/external.rb#23
NewRelic::Agent::External::NON_HTTP_CAT_SYNTHETICS_HEADER = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/external.rb#22
NewRelic::Agent::External::NON_HTTP_CAT_TXN_HEADER = T.let(T.unsafe(nil), String)

# An exception that forces an agent to stop reporting until its mongrel is restarted.
#
# @api public
#
# source://newrelic_rpm//lib/new_relic/agent.rb#83
class NewRelic::Agent::ForceDisconnectException < ::StandardError; end

# An exception that forces an agent to restart.
#
# @api public
#
# source://newrelic_rpm//lib/new_relic/agent.rb#86
class NewRelic::Agent::ForceRestartException < ::StandardError
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent.rb#87
  def message; end
end

# source://newrelic_rpm//lib/new_relic/agent/guid_generator.rb#7
module NewRelic::Agent::GuidGenerator
  private

  # This method intentionally does not use SecureRandom, because it relies
  # on urandom, which raises an exception in MRI when the interpreter runs
  # out of allocated file descriptors.
  # The guids generated by this method may not be _secure_, but they are
  # random enough for our purposes.
  #
  # source://newrelic_rpm//lib/new_relic/agent/guid_generator.rb#17
  def generate_guid(length = T.unsafe(nil)); end

  class << self
    # This method intentionally does not use SecureRandom, because it relies
    # on urandom, which raises an exception in MRI when the interpreter runs
    # out of allocated file descriptors.
    # The guids generated by this method may not be _secure_, but they are
    # random enough for our purposes.
    #
    # source://newrelic_rpm//lib/new_relic/agent/guid_generator.rb#17
    def generate_guid(length = T.unsafe(nil)); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/guid_generator.rb#10
NewRelic::Agent::GuidGenerator::MAX_RAND_16 = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/agent/guid_generator.rb#11
NewRelic::Agent::GuidGenerator::MAX_RAND_32 = T.let(T.unsafe(nil), Integer)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent.rb#814
NewRelic::Agent::HOSTNAME_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/http_clients/uri_util.rb#14
module NewRelic::Agent::HTTPClients; end

# source://newrelic_rpm//lib/new_relic/agent/http_clients/uri_util.rb#15
module NewRelic::Agent::HTTPClients::URIUtil
  class << self
    # source://newrelic_rpm//lib/new_relic/agent/http_clients/uri_util.rb#16
    def obfuscated_uri(url); end

    # There are valid URI strings that some HTTP client libraries will
    # accept that the stdlib URI module doesn't handle. If we find that
    # Addressable is around, use that to normalize out our URL's.
    #
    # source://newrelic_rpm//lib/new_relic/agent/http_clients/uri_util.rb#28
    def parse_and_normalize_url(url); end

    # source://newrelic_rpm//lib/new_relic/agent/http_clients/uri_util.rb#45
    def strip_query_string(fragment); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/http_clients/uri_util.rb#43
NewRelic::Agent::HTTPClients::URIUtil::QUESTION_MARK = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/harvester.rb#7
class NewRelic::Agent::Harvester
  # Inject target for after_fork call to avoid spawning thread in tests
  #
  # @return [Harvester] a new instance of Harvester
  #
  # source://newrelic_rpm//lib/new_relic/agent/harvester.rb#11
  def initialize(events, after_forker = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/harvester.rb#40
  def harvest_thread_enabled?; end

  # source://newrelic_rpm//lib/new_relic/agent/harvester.rb#28
  def mark_started(pid = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/harvester.rb#32
  def needs_restart?(pid = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/harvester.rb#20
  def on_transaction(*_); end

  # source://newrelic_rpm//lib/new_relic/agent/harvester.rb#44
  def restart_harvest_thread; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/harvester.rb#36
  def restart_in_children_enabled?; end

  # Returns the value of attribute starting_pid.
  #
  # source://newrelic_rpm//lib/new_relic/agent/harvester.rb#8
  def starting_pid; end

  # Sets the attribute starting_pid
  #
  # @param value the value to set the attribute starting_pid to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/harvester.rb#8
  def starting_pid=(_arg0); end
end

# This class implements a min Heap. The first element is always the one with the
# lowest priority. It is a tree structure that is represented as an array. The
# relationship between nodes in the tree and indices in the array are as
# follows:
#
# parent_index      = (child_index -  1) / 2
# left_child_index  = parent_index * 2 + 1
# right_child_index = parent_index * 2 + 2
#
# the root node is at index 0
# a node is a leaf node when its index >= length / 2
#
# source://newrelic_rpm//lib/new_relic/agent/heap.rb#20
class NewRelic::Agent::Heap
  # @param items [Array] an optional array of items to initialize the heap
  # @param priority_fn [Callable] an optional priority function used to
  #   to compute the priority for an item. If it's not supplied priority
  #   will be computed using Comparable.
  # @return [Heap] a new instance of Heap
  #
  # source://newrelic_rpm//lib/new_relic/agent/heap.rb#26
  def initialize(items = T.unsafe(nil), &priority_fn); end

  # source://newrelic_rpm//lib/new_relic/agent/heap.rb#61
  def <<(item); end

  # source://newrelic_rpm//lib/new_relic/agent/heap.rb#33
  def [](index); end

  # source://newrelic_rpm//lib/new_relic/agent/heap.rb#37
  def []=(index, value); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/heap.rb#79
  def empty?; end

  # source://newrelic_rpm//lib/new_relic/agent/heap.rb#41
  def fix(index); end

  # source://newrelic_rpm//lib/new_relic/agent/heap.rb#68
  def pop; end

  # source://newrelic_rpm//lib/new_relic/agent/heap.rb#61
  def push(item); end

  # source://newrelic_rpm//lib/new_relic/agent/heap.rb#75
  def size; end

  # source://newrelic_rpm//lib/new_relic/agent/heap.rb#83
  def to_a; end

  private

  # source://newrelic_rpm//lib/new_relic/agent/heap.rb#120
  def heapify_down(parent_index); end

  # source://newrelic_rpm//lib/new_relic/agent/heap.rb#109
  def heapify_up(child_index); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/heap.rb#105
  def in_range?(index); end

  # source://newrelic_rpm//lib/new_relic/agent/heap.rb#97
  def left_child_index_for(parent_index); end

  # source://newrelic_rpm//lib/new_relic/agent/heap.rb#93
  def parent_index_for(child_index); end

  # source://newrelic_rpm//lib/new_relic/agent/heap.rb#89
  def priority(index); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/heap.rb#101
  def right_sibling_smaller?(lchild_index); end

  # source://newrelic_rpm//lib/new_relic/agent/heap.rb#134
  def swap(i, j); end
end

# source://newrelic_rpm//lib/new_relic/agent/hostname.rb#10
module NewRelic::Agent::Hostname
  class << self
    # source://newrelic_rpm//lib/new_relic/agent/hostname.rb#11
    def get; end

    # source://newrelic_rpm//lib/new_relic/agent/hostname.rb#46
    def get_dyno_prefixes; end

    # source://newrelic_rpm//lib/new_relic/agent/hostname.rb#64
    def get_external(host_or_ip); end

    # Pass '-f' to the external executable 'hostname' to request the fully
    # qualified domain name (fqdn). For implementations of 'hostname' that
    # do not support '-f' (such as the one OpenBSD ships with), fall back
    # to calling 'hostname' without the '-f'. If both ways of calling
    # 'hostname' fail, or in a context where 'hostname' is not even
    # available (within an AWS Lambda function, for example), call the
    # 'get' method which uses Socket instead of an external executable.
    #
    # source://newrelic_rpm//lib/new_relic/agent/hostname.rb#29
    def get_fqdn; end

    # source://newrelic_rpm//lib/new_relic/agent/hostname.rb#40
    def heroku_dyno_name_prefix(dyno_name); end

    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/hostname.rb#60
    def local?(host_or_ip); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/hostname.rb#50
NewRelic::Agent::Hostname::LOCALHOST = T.let(T.unsafe(nil), Array)

# source://newrelic_rpm//lib/new_relic/agent/monitors/inbound_request_monitor.rb#18
class NewRelic::Agent::InboundRequestMonitor
  # @return [InboundRequestMonitor] a new instance of InboundRequestMonitor
  #
  # source://newrelic_rpm//lib/new_relic/agent/monitors/inbound_request_monitor.rb#21
  def initialize(events); end

  # source://newrelic_rpm//lib/new_relic/agent/monitors/inbound_request_monitor.rb#33
  def deserialize_header(encoded_header, key); end

  # Returns the value of attribute obfuscator.
  #
  # source://newrelic_rpm//lib/new_relic/agent/monitors/inbound_request_monitor.rb#19
  def obfuscator; end

  # source://newrelic_rpm//lib/new_relic/agent/monitors/inbound_request_monitor.rb#29
  def setup_obfuscator; end
end

# stub module that contains instrumentation defined in the
# instrumentation directory
#
# source://newrelic_rpm//lib/new_relic/agent/instrumentation/logger/instrumentation.rb#7
module NewRelic::Agent::Instrumentation; end

# == NewRelic instrumentation for controller actions and tasks
#
# This module can also be used to capture performance information for
# background tasks and other non-web transactions, including
# detailed transaction traces and traced errors.
#
# For details on how to instrument background tasks see
# {ClassMethods#add_transaction_tracer} and
# {#perform_action_with_newrelic_trace}
#
# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#25
module NewRelic::Agent::Instrumentation::ControllerInstrumentation
  mixes_in_class_methods ::NewRelic::Agent::Instrumentation::ControllerInstrumentation::ClassMethods

  # Yield to the given block with NewRelic tracing.  Used by
  # default instrumentation on controller actions in Rails.
  # But it can also be used in custom instrumentation of controller
  # methods and background tasks.
  #
  # This is the method invoked by instrumentation added by the
  # <tt>ClassMethods#add_transaction_tracer</tt>.
  #
  # Here's a more verbose version of the example shown in
  # <tt>ClassMethods#add_transaction_tracer</tt> using this method instead of
  # #add_transaction_tracer.
  #
  # Below is a controller with an +invoke_operation+ action which
  # dispatches to more specific operation methods based on a
  # parameter (very dangerous, btw!).  With this instrumentation,
  # the +invoke_operation+ action is ignored but the operation
  # methods show up in New Relic as if they were first class controller
  # actions
  #
  #   MyController < ActionController::Base
  #     include NewRelic::Agent::Instrumentation::ControllerInstrumentation
  #     # dispatch the given op to the method given by the service parameter.
  #     def invoke_operation
  #       op = params['operation']
  #       perform_action_with_newrelic_trace(:name => op) do
  #         send op, params['message']
  #       end
  #     end
  #     # Ignore the invoker to avoid double counting
  #     newrelic_ignore :only => 'invoke_operation'
  #   end
  #
  #
  # When invoking this method explicitly as in the example above, pass in a
  # block to measure with some combination of options:
  #
  # * <tt>:category => :controller</tt> indicates that this is a
  #   controller action and will appear with all the other actions.  This
  #   is the default.
  # * <tt>:category => :task</tt> indicates that this is a
  #   background task and will show up in New Relic with other background
  #   tasks instead of in the controllers list
  # * <tt>:category => :middleware</tt> if you are instrumenting a rack
  #   middleware call.  The <tt>:name</tt> is optional, useful if you
  #   have more than one potential transaction in the #call.
  # * <tt>:category => :uri</tt> indicates that this is a
  #   web transaction whose name is a normalized URI, where  'normalized'
  #   means the URI does not have any elements with data in them such
  #   as in many REST URIs.
  # * <tt>:name => action_name</tt> is used to specify the action
  #   name used as part of the metric name
  # * <tt>:params => {...}</tt> to provide information about the context
  #   of the call, used in transaction trace display, for example:
  #   <tt>:params => { :account => @account.name, :file => file.name }</tt>
  #   These are treated similarly to request parameters in web transactions.
  #
  # Seldomly used options:
  #
  # * <tt>:class_name => Class.name</tt> is used to override the name
  #   of the class when used inside the metric name.  Default is the
  #   current class.
  # * <tt>:path => metric_path</tt> is *deprecated* in the public API.  It
  #   allows you to set the entire metric after the category part.  Overrides
  #   all the other options.
  # * <tt>:request => Rack::Request#new(env)</tt> is used to pass in a
  #   request object that may respond to path and referer.
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#354
  def perform_action_with_newrelic_trace(*args, &block); end

  protected

  # overridable method to determine whether to trace an action
  # or not - you may override this in your controller and supply
  # your own logic for ignoring transactions.
  #
  # @api public
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#423
  def do_not_trace?; end

  # overridable method to determine whether to trace an action
  # for purposes of apdex measurement - you can use this to
  # ignore things like api calls or other fast non-user-facing
  # actions
  #
  # @api public
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#431
  def ignore_apdex?; end

  # @api public
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#435
  def ignore_enduser?; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#396
  def newrelic_request(args); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#410
  def newrelic_request_headers(request); end

  # Should be implemented in the dispatcher class
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#408
  def newrelic_response_code; end

  private

  # Filter out a request if it matches one of our parameters for
  # ignoring it - the key is either NR_DO_NOT_TRACE_KEY or NR_IGNORE_APDEX_KEY
  #
  # @api public
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#459
  def _is_filtered?(key); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#441
  def create_transaction_options(trace_options, category, state, queue_start_time); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#473
  def detect_queue_start_time(request); end

  class << self
    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#26
    def included(clazz); end
  end
end

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#53
module NewRelic::Agent::Instrumentation::ControllerInstrumentation::ClassMethods
  # Add transaction tracing to the given method.  This will treat
  # the given method as a main entrypoint for instrumentation, just
  # like controller actions are treated by default.  Useful especially
  # for background tasks.
  #
  # Example for background job:
  #   class Job
  #     include NewRelic::Agent::Instrumentation::ControllerInstrumentation
  #     def run(task)
  #        ...
  #     end
  #     # Instrument run so tasks show up under task.name.  Note single
  #     # quoting to defer eval to runtime.
  #     add_transaction_tracer :run, :name => '#{args[0].name}'
  #   end
  #
  # Here's an example of a controller that uses a dispatcher
  # action to invoke operations which you want treated as top
  # level actions, so they aren't all lumped into the invoker
  # action.
  #
  #   MyController < ActionController::Base
  #     include NewRelic::Agent::Instrumentation::ControllerInstrumentation
  #     # dispatch the given op to the method given by the service parameter.
  #     def invoke_operation
  #       op = params['operation']
  #       send op
  #     end
  #     # Ignore the invoker to avoid double counting
  #     newrelic_ignore :only => 'invoke_operation'
  #     # Instrument the operations:
  #     add_transaction_tracer :print
  #     add_transaction_tracer :show
  #     add_transaction_tracer :forward
  #   end
  #
  # Here's an example of how to pass contextual information into the transaction
  # so it will appear in transaction traces:
  #
  #   class Job
  #     include NewRelic::Agent::Instrumentation::ControllerInstrumentation
  #     def process(account)
  #        ...
  #     end
  #     # Include the account name in the transaction details.  Note the single
  #     # quotes to defer eval until call time.
  #     add_transaction_tracer :process, :params => '{ :account_name => args[0].name }'
  #   end
  #
  # See NewRelic::Agent::Instrumentation::ControllerInstrumentation#perform_action_with_newrelic_trace
  # for the full list of available options.
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#164
  def add_transaction_tracer(method, options = T.unsafe(nil)); end

  # @api public
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#222
  def already_added_transaction_tracer?(target, with_method_name); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#217
  def build_method_names(traced_method, punctuation); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#203
  def generate_argument_list(options); end

  # Have NewRelic ignore actions in this controller.  Specify the actions as hash options
  # using :except and :only.  If no actions are specified, all actions are ignored.
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#59
  def newrelic_ignore(specifiers = T.unsafe(nil)); end

  # Have NewRelic omit apdex measurements on the given actions.  Typically used for
  # actions that are not user facing or that skew your overall apdex measurement.
  # Accepts :except and :only options, as with #newrelic_ignore.
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#70
  def newrelic_ignore_apdex(specifiers = T.unsafe(nil)); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#81
  def newrelic_ignore_aspect(property, specifiers = T.unsafe(nil)); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#76
  def newrelic_ignore_enduser(specifiers = T.unsafe(nil)); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#106
  def newrelic_read_attr(attr_name); end

  # Should be monkey patched into the controller class implemented
  # with the inheritable attribute mechanism.
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#102
  def newrelic_write_attr(attr_name, value); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#199
  def parse_punctuation(method); end
end

# This module is for importing stubs when the agent is disabled
#
# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#31
module NewRelic::Agent::Instrumentation::ControllerInstrumentation::ClassMethodsShim
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#32
  def newrelic_ignore(*args); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#34
  def newrelic_ignore_apdex(*args); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#36
  def newrelic_ignore_enduser(*args); end
end

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#50
NewRelic::Agent::Instrumentation::ControllerInstrumentation::NR_DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#47
NewRelic::Agent::Instrumentation::ControllerInstrumentation::NR_DO_NOT_TRACE_KEY = T.let(T.unsafe(nil), Symbol)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#48
NewRelic::Agent::Instrumentation::ControllerInstrumentation::NR_IGNORE_APDEX_KEY = T.let(T.unsafe(nil), Symbol)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#49
NewRelic::Agent::Instrumentation::ControllerInstrumentation::NR_IGNORE_ENDUSER_KEY = T.let(T.unsafe(nil), Symbol)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#39
module NewRelic::Agent::Instrumentation::ControllerInstrumentation::Shim
  mixes_in_class_methods ::NewRelic::Agent::Instrumentation::ControllerInstrumentation::ClassMethodsShim

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#44
  def perform_action_with_newrelic_trace(*args); end

  class << self
    # @api public
    # @private
    #
    # source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#40
    def included(clazz); end
  end
end

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#229
class NewRelic::Agent::Instrumentation::ControllerInstrumentation::TransactionNamer
  class << self
    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#274
    def class_name(traced_obj, options = T.unsafe(nil)); end

    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#230
    def name_for(txn, traced_obj, category, options = T.unsafe(nil)); end

    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#257
    def path_name(traced_obj, options = T.unsafe(nil)); end

    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/instrumentation/controller_instrumentation.rb#236
    def prefix_for_category(txn, category = T.unsafe(nil)); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/instrumentation/ignore_actions.rb#8
module NewRelic::Agent::Instrumentation::IgnoreActions
  class << self
    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/instrumentation/ignore_actions.rb#9
    def is_filtered?(key, klass, action_name); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/instrumentation/logger/instrumentation.rb#8
module NewRelic::Agent::Instrumentation::Logger
  # source://newrelic_rpm//lib/new_relic/agent/instrumentation/logger/instrumentation.rb#36
  def clear_skip_instrumenting; end

  # source://newrelic_rpm//lib/new_relic/agent/instrumentation/logger/instrumentation.rb#46
  def format_message_with_tracing(severity, datetime, progname, msg); end

  # source://newrelic_rpm//lib/new_relic/agent/instrumentation/logger/instrumentation.rb#30
  def mark_skip_instrumenting; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/instrumentation/logger/instrumentation.rb#11
  def skip_instrumenting?; end

  class << self
    # source://newrelic_rpm//lib/new_relic/agent/instrumentation/logger/instrumentation.rb#24
    def clear_skip_instrumenting(logger); end

    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/instrumentation/logger/instrumentation.rb#42
    def enabled?; end

    # We support setting this on loggers which might not have
    # instrumentation installed yet. This lets us disable in AgentLogger
    # and AuditLogger without them having to know the inner details.
    #
    # source://newrelic_rpm//lib/new_relic/agent/instrumentation/logger/instrumentation.rb#18
    def mark_skip_instrumenting(logger); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/instrumentation/logger/instrumentation.rb#9
NewRelic::Agent::Instrumentation::Logger::INSTRUMENTATION_NAME = T.let(T.unsafe(nil), String)

# https://docs.newrelic.com/docs/features/tracking-front-end-time
# Record queue time metrics based on any of three headers
# which can be set on the request.
#
# source://newrelic_rpm//lib/new_relic/agent/instrumentation/queue_time.rb#11
module NewRelic::Agent::Instrumentation::QueueTime
  private

  # source://newrelic_rpm//lib/new_relic/agent/instrumentation/queue_time.rb#29
  def parse_frontend_timestamp(headers, now = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/instrumentation/queue_time.rb#58
  def parse_timestamp(string); end

  # source://newrelic_rpm//lib/new_relic/agent/instrumentation/queue_time.rb#49
  def timestamp_string_from_header_value(value); end

  class << self
    # source://newrelic_rpm//lib/new_relic/agent/instrumentation/queue_time.rb#29
    def parse_frontend_timestamp(headers, now = T.unsafe(nil)); end

    # source://newrelic_rpm//lib/new_relic/agent/instrumentation/queue_time.rb#58
    def parse_timestamp(string); end

    # source://newrelic_rpm//lib/new_relic/agent/instrumentation/queue_time.rb#49
    def timestamp_string_from_header_value(value); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/instrumentation/queue_time.rb#19
NewRelic::Agent::Instrumentation::QueueTime::CANDIDATE_HEADERS = T.let(T.unsafe(nil), Array)

# source://newrelic_rpm//lib/new_relic/agent/instrumentation/queue_time.rb#25
NewRelic::Agent::Instrumentation::QueueTime::DIVISORS = T.let(T.unsafe(nil), Array)

# any timestamps before this are thrown out and the parser
# will try again with a larger unit (2000/1/1 UTC)
#
# source://newrelic_rpm//lib/new_relic/agent/instrumentation/queue_time.rb#17
NewRelic::Agent::Instrumentation::QueueTime::EARLIEST_ACCEPTABLE_TIME = T.let(T.unsafe(nil), Float)

# source://newrelic_rpm//lib/new_relic/agent/instrumentation/queue_time.rb#14
NewRelic::Agent::Instrumentation::QueueTime::MIDDLEWARE_START_HEADER = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/instrumentation/queue_time.rb#13
NewRelic::Agent::Instrumentation::QueueTime::QUEUE_START_HEADER = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/instrumentation/queue_time.rb#12
NewRelic::Agent::Instrumentation::QueueTime::REQUEST_START_HEADER = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/instrumentation/resque/helper.rb#8
module NewRelic::Agent::Instrumentation::Resque; end

# source://newrelic_rpm//lib/new_relic/agent/instrumentation/resque/helper.rb#9
module NewRelic::Agent::Instrumentation::Resque::Helper
  extend ::NewRelic::Agent::Instrumentation::Resque::Helper

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/instrumentation/resque/helper.rb#12
  def resque_fork_per_job?; end
end

# source://newrelic_rpm//lib/new_relic/agent/internal_agent_error.rb#12
class NewRelic::Agent::InternalAgentError < ::StandardError
  # @return [InternalAgentError] a new instance of InternalAgentError
  #
  # source://newrelic_rpm//lib/new_relic/agent/internal_agent_error.rb#13
  def initialize(msg = T.unsafe(nil)); end
end

# source://newrelic_rpm//lib/new_relic/agent/javascript_instrumentor.rb#10
class NewRelic::Agent::JavaScriptInstrumentor
  include ::NewRelic::Coerce

  # @return [JavaScriptInstrumentor] a new instance of JavaScriptInstrumentor
  #
  # source://newrelic_rpm//lib/new_relic/agent/javascript_instrumentor.rb#15
  def initialize(event_listener); end

  # source://newrelic_rpm//lib/new_relic/agent/javascript_instrumentor.rb#172
  def add_attributes(data, txn); end

  # source://newrelic_rpm//lib/new_relic/agent/javascript_instrumentor.rb#165
  def add_ssl_for_http(data); end

  # source://newrelic_rpm//lib/new_relic/agent/javascript_instrumentor.rb#197
  def append_agent_attributes!(txn, atts); end

  # source://newrelic_rpm//lib/new_relic/agent/javascript_instrumentor.rb#185
  def append_custom_attributes!(txn, atts); end

  # source://newrelic_rpm//lib/new_relic/agent/javascript_instrumentor.rb#105
  def browser_timing_config(state, nonce = T.unsafe(nil)); end

  # THREAD_LOCAL_ACCESS
  #
  # source://newrelic_rpm//lib/new_relic/agent/javascript_instrumentor.rb#85
  def browser_timing_header(nonce = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/javascript_instrumentor.rb#101
  def browser_timing_loader(nonce = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/javascript_instrumentor.rb#118
  def create_nonce(nonce = T.unsafe(nil)); end

  # NOTE: Internal prototyping may override this, so leave name stable!
  #
  # source://newrelic_rpm//lib/new_relic/agent/javascript_instrumentor.rb#138
  def data_for_js_agent(transaction); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/javascript_instrumentor.rb#29
  def enabled?; end

  # source://newrelic_rpm//lib/new_relic/agent/javascript_instrumentor.rb#204
  def html_safe_if_needed(string); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/javascript_instrumentor.rb#62
  def insert_js?(state); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/javascript_instrumentor.rb#37
  def js_enabled_and_ready?; end

  # source://newrelic_rpm//lib/new_relic/agent/javascript_instrumentor.rb#19
  def log_configuration; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/javascript_instrumentor.rb#80
  def missing_config?(key); end

  # source://newrelic_rpm//lib/new_relic/agent/javascript_instrumentor.rb#33
  def obfuscator; end
end

# source://newrelic_rpm//lib/new_relic/agent/javascript_instrumentor.rb#131
NewRelic::Agent::JavaScriptInstrumentor::AGENT_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/javascript_instrumentor.rb#127
NewRelic::Agent::JavaScriptInstrumentor::APPLICATIONID_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/javascript_instrumentor.rb#130
NewRelic::Agent::JavaScriptInstrumentor::APPLICATION_TIME_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/javascript_instrumentor.rb#135
NewRelic::Agent::JavaScriptInstrumentor::ATTS_AGENT_SUBKEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/javascript_instrumentor.rb#133
NewRelic::Agent::JavaScriptInstrumentor::ATTS_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/javascript_instrumentor.rb#134
NewRelic::Agent::JavaScriptInstrumentor::ATTS_USER_SUBKEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/javascript_instrumentor.rb#124
NewRelic::Agent::JavaScriptInstrumentor::BEACON_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/javascript_instrumentor.rb#125
NewRelic::Agent::JavaScriptInstrumentor::ERROR_BEACON_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/javascript_instrumentor.rb#126
NewRelic::Agent::JavaScriptInstrumentor::LICENSE_KEY_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/javascript_instrumentor.rb#129
NewRelic::Agent::JavaScriptInstrumentor::QUEUE_TIME_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/javascript_instrumentor.rb#13
NewRelic::Agent::JavaScriptInstrumentor::RUM_KEY_LENGTH = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/agent/javascript_instrumentor.rb#132
NewRelic::Agent::JavaScriptInstrumentor::SSL_FOR_HTTP_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/javascript_instrumentor.rb#128
NewRelic::Agent::JavaScriptInstrumentor::TRANSACTION_NAME_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent.rb#80
class NewRelic::Agent::LicenseException < ::StandardError; end

# This module contains helper methods related to gathering linking
# metadata for use with logs in context.
#
# source://newrelic_rpm//lib/new_relic/agent/linking_metadata.rb#10
module NewRelic::Agent::LinkingMetadata
  extend ::NewRelic::Agent::LinkingMetadata

  # @raise [ArgumentError]
  #
  # source://newrelic_rpm//lib/new_relic/agent/linking_metadata.rb#13
  def append_service_linking_metadata(metadata); end

  # @raise [ArgumentError]
  #
  # source://newrelic_rpm//lib/new_relic/agent/linking_metadata.rb#29
  def append_trace_linking_metadata(metadata); end
end

# This module contains helper methods related to decorating log messages
#
# source://newrelic_rpm//lib/new_relic/agent/local_log_decorator.rb#8
module NewRelic::Agent::LocalLogDecorator
  extend ::NewRelic::Agent::LocalLogDecorator

  # source://newrelic_rpm//lib/new_relic/agent/local_log_decorator.rb#11
  def decorate(message); end

  private

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/local_log_decorator.rb#24
  def decorating_enabled?; end

  # source://newrelic_rpm//lib/new_relic/agent/local_log_decorator.rb#30
  def escape_entity_name(entity_name); end
end

# source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#11
class NewRelic::Agent::LogEventAggregator < ::NewRelic::Agent::EventAggregator
  # @return [LogEventAggregator] a new instance of LogEventAggregator
  #
  # source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#45
  def initialize(events); end

  # source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#124
  def add_custom_attributes(custom_attributes); end

  # Returns the value of attribute attributes.
  #
  # source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#43
  def attributes; end

  # source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#56
  def capacity; end

  # source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#107
  def create_event(priority, formatted_message, severity); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#169
  def enabled?; end

  # source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#155
  def harvest!; end

  # source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#60
  def record(formatted_message, severity); end

  # source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#93
  def record_batch(txn, logs); end

  # source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#160
  def reset!; end

  private

  # source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#200
  def after_harvest(metadata); end

  # source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#265
  def configured_log_level_constant; end

  # source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#269
  def format_log_level_constant(log_level); end

  # source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#225
  def line_metric_name_by_severity(severity); end

  # source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#250
  def minimum_log_level; end

  # source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#230
  def note_dropped_events(total_count, dropped_count); end

  # source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#190
  def record_configuration_metric(format, key); end

  # To avoid paying the cost of metric recording on every line, we hold
  # these until harvest before recording them
  #
  # source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#208
  def record_customer_metrics; end

  # source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#236
  def record_supportability_metrics(total_count, captured_count, dropped_count); end

  # We record once-per-connect metrics for enabled/disabled state at the
  # point we consider the configuration stable (i.e. once we've gotten SSC)
  #
  # source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#177
  def register_for_done_configuring(events); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#273
  def severity_too_low?(severity); end

  # source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#244
  def truncate_message(message); end

  class << self
    # Because our transmission format (MELT) is different than historical
    # agent payloads, extract the munging here to keep the service focused
    # on the general harvest + transmit instead of the format.
    #
    # Payload shape matches the publicly documented MELT format.
    # https://docs.newrelic.com/docs/logs/log-api/introduction-log-api
    #
    # We have to keep the aggregated payloads in a separate shape, though, to
    # work with the priority sampling buffers
    #
    # source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#137
    def payload_to_melt_format(data); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#41
NewRelic::Agent::LogEventAggregator::CUSTOM_ATTRIBUTES_KEY = T.let(T.unsafe(nil), Symbol)

# source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#39
NewRelic::Agent::LogEventAggregator::DECORATING_ENABLED_KEY = T.let(T.unsafe(nil), Symbol)

# source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#26
NewRelic::Agent::LogEventAggregator::DECORATING_SUPPORTABILITY_FORMAT = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#20
NewRelic::Agent::LogEventAggregator::DROPPED_METRIC = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#38
NewRelic::Agent::LogEventAggregator::FORWARDING_ENABLED_KEY = T.let(T.unsafe(nil), Symbol)

# source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#25
NewRelic::Agent::LogEventAggregator::FORWARDING_SUPPORTABILITY_FORMAT = T.let(T.unsafe(nil), String)

# Per-message keys
#
# source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#13
NewRelic::Agent::LogEventAggregator::LEVEL_KEY = T.let(T.unsafe(nil), String)

# Metric keys
#
# source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#19
NewRelic::Agent::LogEventAggregator::LINES = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#40
NewRelic::Agent::LogEventAggregator::LOG_LEVEL_KEY = T.let(T.unsafe(nil), Symbol)

# 32 * 1024 bytes (32 kibibytes)
#
# source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#27
NewRelic::Agent::LogEventAggregator::MAX_BYTES = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#14
NewRelic::Agent::LogEventAggregator::MESSAGE_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#37
NewRelic::Agent::LogEventAggregator::METRICS_ENABLED_KEY = T.let(T.unsafe(nil), Symbol)

# source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#24
NewRelic::Agent::LogEventAggregator::METRICS_SUPPORTABILITY_FORMAT = T.let(T.unsafe(nil), String)

# Config keys
#
# source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#36
NewRelic::Agent::LogEventAggregator::OVERALL_ENABLED_KEY = T.let(T.unsafe(nil), Symbol)

# source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#23
NewRelic::Agent::LogEventAggregator::OVERALL_SUPPORTABILITY_FORMAT = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#16
NewRelic::Agent::LogEventAggregator::PRIORITY_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#21
NewRelic::Agent::LogEventAggregator::SEEN_METRIC = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#22
NewRelic::Agent::LogEventAggregator::SENT_METRIC = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/log_event_aggregator.rb#15
NewRelic::Agent::LogEventAggregator::TIMESTAMP_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/log_event_attributes.rb#7
class NewRelic::Agent::LogEventAttributes
  # source://newrelic_rpm//lib/new_relic/agent/log_event_attributes.rb#12
  def add_custom_attributes(attributes); end

  # source://newrelic_rpm//lib/new_relic/agent/log_event_attributes.rb#22
  def custom_attributes; end

  private

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/log_event_attributes.rb#47
  def absent?(value); end

  # source://newrelic_rpm//lib/new_relic/agent/log_event_attributes.rb#51
  def add_custom_attribute(key, value); end

  # source://newrelic_rpm//lib/new_relic/agent/log_event_attributes.rb#64
  def key_to_string(key); end

  # source://newrelic_rpm//lib/new_relic/agent/log_event_attributes.rb#68
  def truncate_attribute(attribute, limit); end

  # source://newrelic_rpm//lib/new_relic/agent/log_event_attributes.rb#91
  def truncate_attributes(key, value); end
end

# source://newrelic_rpm//lib/new_relic/agent/log_event_attributes.rb#9
NewRelic::Agent::LogEventAttributes::ATTRIBUTE_KEY_CHARACTER_LIMIT = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/agent/log_event_attributes.rb#10
NewRelic::Agent::LogEventAttributes::ATTRIBUTE_VALUE_CHARACTER_LIMIT = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/agent/log_event_attributes.rb#38
class NewRelic::Agent::LogEventAttributes::InvalidTypeError < ::StandardError
  # @return [InvalidTypeError] a new instance of InvalidTypeError
  #
  # source://newrelic_rpm//lib/new_relic/agent/log_event_attributes.rb#41
  def initialize(attribute, msg = T.unsafe(nil)); end

  # Returns the value of attribute attribute.
  #
  # source://newrelic_rpm//lib/new_relic/agent/log_event_attributes.rb#39
  def attribute; end
end

# limit is 255, assume we send 15
#
# source://newrelic_rpm//lib/new_relic/agent/log_event_attributes.rb#8
NewRelic::Agent::LogEventAttributes::MAX_ATTRIBUTE_COUNT = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/agent/log_event_attributes.rb#28
class NewRelic::Agent::LogEventAttributes::TruncationError < ::StandardError
  # @return [TruncationError] a new instance of TruncationError
  #
  # source://newrelic_rpm//lib/new_relic/agent/log_event_attributes.rb#31
  def initialize(attribute, limit, msg = T.unsafe(nil)); end

  # Returns the value of attribute attribute.
  #
  # source://newrelic_rpm//lib/new_relic/agent/log_event_attributes.rb#29
  def attribute; end

  # Returns the value of attribute limit.
  #
  # source://newrelic_rpm//lib/new_relic/agent/log_event_attributes.rb#29
  def limit; end
end

# source://newrelic_rpm//lib/new_relic/agent/log_once.rb#7
module NewRelic::Agent::LogOnce
  # source://newrelic_rpm//lib/new_relic/agent/log_once.rb#32
  def clear_already_logged; end

  # source://newrelic_rpm//lib/new_relic/agent/log_once.rb#10
  def log_once(level, key, *msgs); end
end

# source://newrelic_rpm//lib/new_relic/agent/log_once.rb#8
NewRelic::Agent::LogOnce::NUM_LOG_ONCE_KEYS = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/agent/log_priority.rb#10
module NewRelic::Agent::LogPriority
  extend ::NewRelic::Agent::LogPriority

  # source://newrelic_rpm//lib/new_relic/agent/log_priority.rb#13
  def priority_for(txn); end
end

# source://newrelic_rpm//lib/new_relic/agent/logging.rb#10
module NewRelic::Agent::Logging; end

# This class can be used as the formatter for an existing logger.  It
# decorates log messages with trace and entity metadata, and formats each
# log messages as a JSON object.
#
# It can be added to a Rails application like this:
#
#   require 'newrelic_rpm'
#
#   Rails.application.configure do
#     config.log_formatter = ::NewRelic::Agent::Logging::DecoratingFormatter.new
#   end
#
# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/logging.rb#24
class NewRelic::Agent::Logging::DecoratingFormatter < ::Logger::Formatter
  # @api public
  # @return [DecoratingFormatter] a new instance of DecoratingFormatter
  #
  # source://newrelic_rpm//lib/new_relic/agent/logging.rb#42
  def initialize; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/logging.rb#48
  def call(severity, time, progname, msg); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/logging.rb#65
  def clear_tags!; end

  private

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/logging.rb#71
  def add_app_name(message); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/logging.rb#87
  def add_entity_guid(message); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/logging.rb#78
  def add_entity_type(message); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/logging.rb#83
  def add_hostname(message); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/logging.rb#129
  def add_key_value(message, key, value); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/logging.rb#114
  def add_log_level(message, severity); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/logging.rb#108
  def add_message(message, msg); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/logging.rb#118
  def add_prog_name(message, progname); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/logging.rb#101
  def add_span_id(message); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/logging.rb#94
  def add_trace_id(message); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/logging.rb#125
  def app_name; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/logging.rb#133
  def escape(message); end
end

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/logging.rb#39
NewRelic::Agent::Logging::DecoratingFormatter::CLOSING_BRACE = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/logging.rb#37
NewRelic::Agent::Logging::DecoratingFormatter::COLON = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/logging.rb#38
NewRelic::Agent::Logging::DecoratingFormatter::COMMA = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/logging.rb#28
NewRelic::Agent::Logging::DecoratingFormatter::ELEMENTS = T.let(T.unsafe(nil), Array)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/logging.rb#26
NewRelic::Agent::Logging::DecoratingFormatter::LOG_LEVEL_ELEMENT = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/logging.rb#32
NewRelic::Agent::Logging::DecoratingFormatter::LOG_LEVEL_KEY = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/logging.rb#33
NewRelic::Agent::Logging::DecoratingFormatter::LOG_NAME_KEY = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/logging.rb#25
NewRelic::Agent::Logging::DecoratingFormatter::MESSAGE_ELEMENT = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/logging.rb#31
NewRelic::Agent::Logging::DecoratingFormatter::MESSAGE_KEY = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/logging.rb#34
NewRelic::Agent::Logging::DecoratingFormatter::NEWLINE = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/logging.rb#27
NewRelic::Agent::Logging::DecoratingFormatter::PROG_NAME_ELEMENT = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/logging.rb#36
NewRelic::Agent::Logging::DecoratingFormatter::QUOTE = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/logging.rb#40
NewRelic::Agent::Logging::DecoratingFormatter::REPLACEMENT_CHAR = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/logging.rb#30
NewRelic::Agent::Logging::DecoratingFormatter::TIMESTAMP_KEY = T.let(T.unsafe(nil), String)

# This logger decorates logs with trace and entity metadata, and emits log
# messages formatted as JSON objects.  It extends the Logger class from
# the Ruby standard library, and accepts the same constructor parameters.
#
# It aliases the `:info` message to overwrite the `:write` method, so it
# can be used in Rack applications that expect the logger to be a file-like
# object.
#
# It can be added to an application like this:
#
#   require 'newrelic_rpm'
#
#   config.logger = NewRelic::Agent::Logging::DecoratingLogger.new "log/application.log"
#
# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/logging.rb#162
class NewRelic::Agent::Logging::DecoratingLogger < ::ActiveSupport::Logger
  # @api public
  # @return [DecoratingLogger] a new instance of DecoratingLogger
  #
  # source://newrelic_rpm//lib/new_relic/agent/logging.rb#174
  def initialize(*args, **kwargs); end

  # @api public
  #
  # source://logger/1.6.1/lib/logger.rb#701
  def write(progname = T.unsafe(nil), &block); end
end

# source://newrelic_rpm//lib/new_relic/agent/memory_logger.rb#11
class NewRelic::Agent::MemoryLogger
  include ::NewRelic::Agent::LogOnce

  # @return [MemoryLogger] a new instance of MemoryLogger
  #
  # source://newrelic_rpm//lib/new_relic/agent/memory_logger.rb#14
  def initialize; end

  # source://newrelic_rpm//lib/new_relic/agent/memory_logger.rb#43
  def debug(*msgs, &blk); end

  # source://newrelic_rpm//lib/new_relic/agent/memory_logger.rb#51
  def dump(logger); end

  # source://newrelic_rpm//lib/new_relic/agent/memory_logger.rb#31
  def error(*msgs, &blk); end

  # source://newrelic_rpm//lib/new_relic/agent/memory_logger.rb#27
  def fatal(*msgs, &blk); end

  # source://newrelic_rpm//lib/new_relic/agent/memory_logger.rb#39
  def info(*msgs, &blk); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/memory_logger.rb#21
  def is_startup_logger?; end

  # Returns the value of attribute level.
  #
  # source://newrelic_rpm//lib/new_relic/agent/memory_logger.rb#25
  def level; end

  # Sets the attribute level
  #
  # @param value the value to set the attribute level to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/memory_logger.rb#25
  def level=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/agent/memory_logger.rb#47
  def log_exception(level, e, backtrace_level = T.unsafe(nil)); end

  # Returns the value of attribute log_formatter.
  #
  # source://newrelic_rpm//lib/new_relic/agent/memory_logger.rb#25
  def log_formatter; end

  # Sets the attribute log_formatter
  #
  # @param value the value to set the attribute log_formatter to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/memory_logger.rb#25
  def log_formatter=(_arg0); end

  # Returns the value of attribute messages.
  #
  # source://newrelic_rpm//lib/new_relic/agent/memory_logger.rb#25
  def messages; end

  # Sets the attribute messages
  #
  # @param value the value to set the attribute messages to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/memory_logger.rb#25
  def messages=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/agent/memory_logger.rb#35
  def warn(*msgs, &blk); end
end

# This module contains class methods added to support installing custom
# metric tracers and executing for individual metrics.
#
# == Examples
#
# When the agent initializes, it extends Module with these methods.
# However if you want to use the API in code that might get loaded
# before the agent is initialized you will need to require
# this file:
#
#     require 'new_relic/agent/method_tracer'
#     class A
#       include NewRelic::Agent::MethodTracer
#       def process
#         ...
#       end
#       add_method_tracer :process
#     end
#
# To instrument a class method:
#
#     require 'new_relic/agent/method_tracer'
#     class An
#       def self.process
#         ...
#       end
#       class << self
#         include NewRelic::Agent::MethodTracer
#         add_method_tracer :process
#       end
#     end
#
# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/method_tracer.rb#49
module NewRelic::Agent::MethodTracer
  mixes_in_class_methods ::NewRelic::Agent::MethodTracer::ClassMethods

  # Trace a given block with stats and keep track of the caller.
  # See NewRelic::Agent::MethodTracer::ClassMethods#add_method_tracer for a description of the arguments.
  # +metric_names+ is either a single name or an array of metric names.
  # If more than one metric is passed, the +produce_metric+ option only applies to the first.  The
  # others are always recorded.  Only the first metric is pushed onto the scope stack.
  #
  # Generally you pass an array of metric names if you want to record the metric under additional
  # categories, but generally this *should never ever be done*.  Most of the time you can aggregate
  # on the server.
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/method_tracer.rb#70
  def trace_execution_scoped(metric_names, options = T.unsafe(nil)); end

  # Trace a given block with stats assigned to the given metric_name.  It does not
  # provide scoped measurements, meaning whatever is being traced will not 'blame the
  # Controller'--that is to say appear in the breakdown chart.
  #
  # * <tt>metric_names</tt> is a single name or an array of names of metrics
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/method_tracer.rb#86
  def trace_execution_unscoped(metric_names, options = T.unsafe(nil)); end

  class << self
    # @api public
    # @private
    #
    # source://newrelic_rpm//lib/new_relic/agent/method_tracer.rb#54
    def extended(klass); end

    # @api public
    # @private
    #
    # source://newrelic_rpm//lib/new_relic/agent/method_tracer.rb#50
    def included(klass); end
  end
end

# Defines methods used at the class level, for adding instrumentation
#
# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/method_tracer.rb#101
module NewRelic::Agent::MethodTracer::ClassMethods
  include ::NewRelic::Agent::MethodTracer::ClassMethods::AddMethodTracer

  # Add a method tracer to the specified method.
  #
  # By default, this will cause invocations of the traced method to be
  # recorded in transaction traces, and in a metric named after the class
  # and method. It will also make the method show up in transaction-level
  # breakdown charts and tables.
  #
  # === Overriding the metric name
  #
  # +metric_name+ is a String or Proc. If a Proc is given, it is bound to
  # the object that called the traced method. For example:
  #
  #     add_method_tracer :foo, -> { "Custom/#{self.class.name}/foo" }
  #
  # This would name the metric according to the class of the runtime
  # instance, as opposed to the class where +foo+ is defined.
  #
  # If not provided, the metric name will be <tt>Custom/ClassName/method_name</tt>.
  #
  # @api public
  # @example
  #   add_method_tracer :foo
  #
  #   # With a custom metric name
  #   add_method_tracer :foo, "Custom/MyClass/foo"
  #   add_method_tracer :bar, -> { "Custom/#{self.class.name}/bar" }
  #
  #   # Instrument foo only for custom dashboards (not in transaction
  #   # traces or breakdown charts)
  #   add_method_tracer :foo, 'Custom/foo', :push_scope => false
  #
  #   # Instrument foo in transaction traces only
  #   add_method_tracer :foo, 'Custom/foo', :metric => false
  # @option options
  # @option options
  # @option options
  # @option options
  # @param method_name [Symbol] the name of the method to trace
  # @param metric_name [String, Proc, Array] the metric name to record calls to
  #   the traced method under. This may be either a String, or a Proc
  #   to be evaluated at call-time in order to determine the metric
  #   name dynamically.
  #   This method also accepts an array of Strings/Procs, in which case the
  #   first metric given will be scoped, while the remaining metrics will be
  #   recorded as though passed with :push_scope => false. If an Array of
  #   metric names is given with :push_scope => false, all metrics will be
  #   unscoped.
  # @param options [Hash] additional options controlling how the method is
  #   traced.
  #
  # source://newrelic_rpm//lib/new_relic/agent/method_tracer.rb#246
  def add_method_tracer(method_name, metric_name = T.unsafe(nil), options = T.unsafe(nil)); end

  # For tests only because tracers must be removed in reverse-order
  # from when they were added, or else other tracers that were added to the same method
  # may get removed as well.
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/method_tracer.rb#253
  def remove_method_tracer(method_name); end

  private

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/method_tracer.rb#266
  def _nr_add_method_tracer_now(method_name, metric_name, options); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/method_tracer.rb#303
  def _nr_define_traced_method(method_name, scoped_metric: T.unsafe(nil), unscoped_metrics: T.unsafe(nil), code_header: T.unsafe(nil), code_footer: T.unsafe(nil), record_metrics: T.unsafe(nil), visibility: T.unsafe(nil), code_information: T.unsafe(nil)); end

  # See #add_method_tracer; if multiple metric names are given, the first is
  # treated as scoped, the rest unscoped. If options[:push_scope] is false,
  # all given metrics are unscoped.
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/method_tracer.rb#293
  def _nr_scoped_unscoped_metrics(metric_name, method_name, push_scope: T.unsafe(nil)); end
end

# contains methods refactored out of the #add_method_tracer method
#
# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/method_tracer.rb#103
module NewRelic::Agent::MethodTracer::ClassMethods::AddMethodTracer
  # for testing only
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/method_tracer.rb#165
  def _nr_clear_traced_methods!; end

  # Default to the class where the method is defined.
  #
  # Example:
  #  Foo._nr_default_metric_name_code('bar') #=> "Custom/#{Foo.name}/bar"
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/method_tracer.rb#135
  def _nr_default_metric_name(method_name); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/method_tracer.rb#171
  def _nr_derived_class_name; end

  # Returns an anonymous module that stores prepended trace methods.
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/method_tracer.rb#160
  def _nr_traced_method_module; end

  # Checks the provided options to make sure that they make
  # sense. Raises an error if the options are incorrect to
  # assist with debugging, so that errors occur at class
  # construction time rather than instrumentation run time
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/method_tracer.rb#112
  def _nr_validate_method_tracer_options(method_name, options); end

  # Checks to see if we have already traced a method with a
  # given metric by checking to see if the traced method
  # exists. Warns the user if methods are being double-traced
  # to help with debugging custom instrumentation.
  #
  # @api public
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/method_tracer.rb#153
  def method_traced?(method_name); end

  # Checks to see if the method we are attempting to trace
  # actually exists or not. #add_method_tracer can't do
  # anything if the method doesn't exist.
  #
  # @api public
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/method_tracer.rb#143
  def newrelic_method_exists?(method_name); end
end

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/method_tracer.rb#104
NewRelic::Agent::MethodTracer::ClassMethods::AddMethodTracer::ALLOWED_KEYS = T.let(T.unsafe(nil), Array)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/method_tracer.rb#106
NewRelic::Agent::MethodTracer::ClassMethods::AddMethodTracer::DEFAULT_SETTINGS = T.let(T.unsafe(nil), Hash)

# source://newrelic_rpm//lib/new_relic/agent/method_tracer_helpers.rb#7
module NewRelic::Agent::MethodTracerHelpers
  extend ::NewRelic::Agent::MethodTracerHelpers

  # source://newrelic_rpm//lib/new_relic/agent/method_tracer_helpers.rb#42
  def code_information(object, method_name); end

  # THREAD_LOCAL_ACCESS
  #
  # source://newrelic_rpm//lib/new_relic/agent/method_tracer_helpers.rb#19
  def trace_execution_scoped(metric_names, options = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/method_tracer_helpers.rb#66
  def clm_enabled?; end

  # source://newrelic_rpm//lib/new_relic/agent/method_tracer_helpers.rb#128
  def controller_info(klass, name, is_class_method); end

  # Rails controllers can be a special case because by default, controllers in Rails
  # automatically render views with names that correspond to valid routes. This means
  # that a controller method may not have a corresponding method in the controller class.
  #
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/method_tracer_helpers.rb#121
  def controller_without_method?(klass, method_name); end

  # The string representation of a singleton class looks like
  # '#<Class:MyModule::MyClass>', or '#<Class:MyModule::MyClass(id: integer, attribute: string)>'
  # Return the 'MyModule::MyClass' part of that string
  #
  # source://newrelic_rpm//lib/new_relic/agent/method_tracer_helpers.rb#73
  def klass_name(object); end

  # get at the underlying class from the singleton class
  #
  # note: even with the regex hit from klass_name(), `Object.const_get`
  # is more performant than iterating through `ObjectSpace`
  #
  # source://newrelic_rpm//lib/new_relic/agent/method_tracer_helpers.rb#84
  def klassify_singleton(object); end

  # determine the namespace (class name including all module names in scope)
  # and source code location (file path and line number) for the given
  # object and method name
  #
  # traced class methods:
  #     * object is a singleton class, `#<Class::MyClass>`
  #     * get at the underlying non-singleton class
  #
  # traced instance methods and Rails controller methods:
  #     * object is a class, `MyClass`
  #
  # anonymous class based methods (`c = Class.new { def method; end; }`:
  #     * `#name` returns `nil`, so use '(Anonymous)' instead
  #
  # source://newrelic_rpm//lib/new_relic/agent/method_tracer_helpers.rb#102
  def namespace_and_location(object, method_name); end
end

# roughly 31 years
#
# source://newrelic_rpm//lib/new_relic/agent/method_tracer_helpers.rb#15
NewRelic::Agent::MethodTracerHelpers::MAX_ALLOWED_METRIC_DURATION = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/agent/method_tracer_helpers.rb#14
NewRelic::Agent::MethodTracerHelpers::SOURCE_CODE_INFORMATION_FAILURE_METRIC = T.let(T.unsafe(nil), String)

# These are code level metrics (CLM) attributes. For Ruby, they map like so:
#   filepath: full path to an .rb file on disk
#   lineno: the line number a Ruby method is defined on within a given .rb file
#   function: the name of the Ruby method
#   namespace: the Ruby class' namespace as a string, ex: 'MyModule::MyClass'
#
# source://newrelic_rpm//lib/new_relic/agent/method_tracer_helpers.rb#13
NewRelic::Agent::MethodTracerHelpers::SOURCE_CODE_INFORMATION_PARAMETERS = T.let(T.unsafe(nil), Array)

# source://newrelic_rpm//lib/new_relic/agent/monitors.rb#14
class NewRelic::Agent::Monitors
  # @return [Monitors] a new instance of Monitors
  #
  # source://newrelic_rpm//lib/new_relic/agent/monitors.rb#19
  def initialize(events); end

  # Returns the value of attribute cross_app_monitor.
  #
  # source://newrelic_rpm//lib/new_relic/agent/monitors.rb#15
  def cross_app_monitor; end

  # Returns the value of attribute distributed_tracing_monitor.
  #
  # source://newrelic_rpm//lib/new_relic/agent/monitors.rb#17
  def distributed_tracing_monitor; end

  # Returns the value of attribute synthetics_monitor.
  #
  # source://newrelic_rpm//lib/new_relic/agent/monitors.rb#16
  def synthetics_monitor; end
end

# source://newrelic_rpm//lib/new_relic/agent/new_relic_service/encoders.rb#12
class NewRelic::Agent::NewRelicService
  # @return [NewRelicService] a new instance of NewRelicService
  #
  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#46
  def initialize(license_key = T.unsafe(nil), collector = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#179
  def agent_command_results(results); end

  # Returns the value of attribute agent_id.
  #
  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#44
  def agent_id; end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#80
  def agent_id=(id); end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#183
  def analytic_event_data(data); end

  # The collector wants to receive metric data in a format that's different
  # from how we store it internally, so this method handles the translation.
  #
  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#134
  def build_metric_data_array(stats_hash); end

  # The path to the certificate file used to verify the SSL
  # connection if verify_peer is enabled
  #
  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#379
  def cert_file_path; end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#271
  def close_shared_connection; end

  # Returns the value of attribute collector.
  #
  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#44
  def collector; end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#216
  def compress_request_if_needed(data, endpoint); end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#88
  def connect(settings = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#368
  def create_and_start_http_connection; end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#342
  def create_http_connection; end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#189
  def custom_event_data(data); end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#156
  def error_data(unsent_errors); end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#200
  def error_event_data(data); end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#266
  def establish_shared_connection; end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#128
  def force_restart; end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#175
  def get_agent_commands; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#279
  def has_shared_connection?; end

  # Return a Net::HTTP connection object to make a call to the collector.
  # We'll reuse the same handle for cases where we're using keep-alive, or
  # otherwise create a new one.
  #
  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#297
  def http_connection; end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#195
  def log_event_data(data); end

  # Returns the value of attribute marshaller.
  #
  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#44
  def marshaller; end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#145
  def metric_data(stats_hash); end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#107
  def preconnect; end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#62
  def prep_audit_logger; end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#351
  def prep_connection; end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#69
  def prep_marshaller; end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#358
  def prep_proxy_connection; end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#171
  def profile_data(profile); end

  # Returns the value of attribute request_timeout.
  #
  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#43
  def request_timeout; end

  # Sets the attribute request_timeout
  #
  # @param value the value to set the attribute request_timeout to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#43
  def request_timeout=(_arg0); end

  # One session with the service's endpoint.  In this case the session
  # represents 1 tcp connection which may transmit multiple HTTP requests
  # via keep-alive.
  #
  # @raise [ArgumentError]
  #
  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#233
  def session(&block); end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#252
  def session_with_keepalive(&block); end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#257
  def session_without_keepalive(&block); end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#317
  def set_cert_store(conn); end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#305
  def setup_connection_for_ssl(conn); end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#330
  def setup_connection_timeouts(conn); end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#124
  def shutdown(time); end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#208
  def span_event_data(data); end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#166
  def sql_trace_data(sql_traces); end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#283
  def ssl_cert_store; end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#325
  def start_connection(conn); end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#161
  def transaction_sample_data(traces); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#386
  def valid_to_marshal?(data); end

  private

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#445
  def attempt_request(request, opts); end

  # Raises an UnrecoverableServerException if the post_string is longer
  # than the limit configured in the control object
  #
  # @raise [UnrecoverableServerException]
  #
  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#609
  def check_post_size(post_string, endpoint); end

  # A shorthand for NewRelic::Control.instance
  #
  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#397
  def control; end

  # Decompresses the response from the server, if it is gzip
  # encoded, otherwise returns it verbatim
  #
  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#651
  def decompress_response(response); end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#702
  def filtered_uri(uri); end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#529
  def generate_remote_method_uri(method); end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#451
  def handle_error_response(response, endpoint); end

  # @raise [ForceDisconnectException]
  #
  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#513
  def handle_gone_response(response, endpoint); end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#568
  def handle_serialization_error(method, e); end

  # @raise [ServerConnectionException]
  #
  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#497
  def handle_server_connection_exception(response, endpoint); end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#508
  def handle_unauthorized_error_response(response, endpoint); end

  # @raise [UnrecoverableServerException]
  #
  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#502
  def handle_unrecoverable_server_exception(response, endpoint); end

  # send a message via post to the actual server. This attempts
  # to automatically compress the data via zlib if it is large
  # enough to be worth compressing, and handles any errors the
  # server may return
  #
  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#556
  def invoke_remote(method, payload = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#690
  def invoke_remote_send_request(method, payload, data, encoding); end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#548
  def license_key; end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#635
  def log_response(response); end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#669
  def marshal_payload(method, payload, options); end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#683
  def prep_collector(method); end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#401
  def prep_headers(opts); end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#410
  def prep_request(opts); end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#645
  def record_endpoint_attempts_supportability_metrics(endpoint); end

  # Per protocol 17, this metric should be recorded for all error response codes
  # that cause data to be discarded.
  #
  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#641
  def record_error_response_supportability_metrics(response_code); end

  # For these metrics, we use the following fields:
  # call_count           => number of times this remote method was invoked
  # total_call_time      => total size in bytes of payloads across all invocations
  # total_exclusive_time => total size in items (e.g. unique metrics, traces, events, etc) across all invocations
  #
  # The last field doesn't make sense for all methods (e.g. get_agent_commands),
  # so we omit it for those methods that don't really take collections
  # of items as arguments.
  #
  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#597
  def record_size_supportability_metrics(method, size_bytes, item_count); end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#577
  def record_timing_supportability_metrics(method, start_ts, serialize_finish_ts, request_send_ts, response_check_ts); end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#424
  def relay_request(request, opts); end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#519
  def remote_method_uri(method); end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#523
  def reset_remote_method_uris; end

  # Posts to the specified server
  #
  # Options:
  #  - :uri => the path to request on the server (a misnomer of
  #              course)
  #  - :encoding => the encoding to pass to the server
  #  - :collector => a URI object that responds to the 'name' method
  #                    and returns the name of the collector to
  #                    contact
  #  - :data => the data to send as the body of the request
  #
  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#627
  def send_request(opts); end

  # Sets the user agent for connections to the server, to
  # conform with the HTTP spec and allow for debugging. Includes
  # the ruby version and also zlib version if available since
  # that may cause corrupt compression if there is a problem.
  #
  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#661
  def user_agent; end
end

# These include Errno connection errors, and all indicate that the
# underlying TCP connection may be in a bad state.
#
# source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#21
NewRelic::Agent::NewRelicService::CONNECTION_ERRORS = T.let(T.unsafe(nil), Array)

# source://newrelic_rpm//lib/new_relic/agent/new_relic_service/encoders.rb#13
module NewRelic::Agent::NewRelicService::Encoders; end

# source://newrelic_rpm//lib/new_relic/agent/new_relic_service/encoders.rb#42
module NewRelic::Agent::NewRelicService::Encoders::Base64CompressedJSON
  class << self
    # source://newrelic_rpm//lib/new_relic/agent/new_relic_service/encoders.rb#43
    def encode(data, opts = T.unsafe(nil)); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/new_relic_service/encoders.rb#20
module NewRelic::Agent::NewRelicService::Encoders::Compressed; end

# source://newrelic_rpm//lib/new_relic/agent/new_relic_service/encoders.rb#21
module NewRelic::Agent::NewRelicService::Encoders::Compressed::Deflate
  class << self
    # source://newrelic_rpm//lib/new_relic/agent/new_relic_service/encoders.rb#22
    def encode(data, opts = T.unsafe(nil)); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/new_relic_service/encoders.rb#27
module NewRelic::Agent::NewRelicService::Encoders::Compressed::Gzip
  class << self
    # source://newrelic_rpm//lib/new_relic/agent/new_relic_service/encoders.rb#30
    def encode(data, opts = T.unsafe(nil)); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/new_relic_service/encoders.rb#28
NewRelic::Agent::NewRelicService::Encoders::Compressed::Gzip::BINARY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/new_relic_service/encoders.rb#14
module NewRelic::Agent::NewRelicService::Encoders::Identity
  class << self
    # source://newrelic_rpm//lib/new_relic/agent/new_relic_service/encoders.rb#15
    def encode(data, opts = T.unsafe(nil)); end
  end
end

# Marshal collector protocol with JSON when available
#
# source://newrelic_rpm//lib/new_relic/agent/new_relic_service/json_marshaller.rb#12
class NewRelic::Agent::NewRelicService::JsonMarshaller < ::NewRelic::Agent::NewRelicService::Marshaller
  # @return [JsonMarshaller] a new instance of JsonMarshaller
  #
  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service/json_marshaller.rb#13
  def initialize; end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service/json_marshaller.rb#51
  def default_encoder; end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service/json_marshaller.rb#30
  def dump(ruby, opts = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service/json_marshaller.rb#59
  def format; end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service/json_marshaller.rb#40
  def load(data); end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service/json_marshaller.rb#19
  def warn_for_yajl; end

  class << self
    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/new_relic_service/json_marshaller.rb#63
    def human_readable?; end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/new_relic_service/json_marshaller.rb#17
NewRelic::Agent::NewRelicService::JsonMarshaller::OK_YAJL_VERSION = T.let(T.unsafe(nil), Gem::Version)

# The maximum number of times to attempt an HTTP request
#
# source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#30
NewRelic::Agent::NewRelicService::MAX_ATTEMPTS = T.let(T.unsafe(nil), Integer)

# Don't perform compression on the payload unless its uncompressed size is
# greater than or equal to this number of bytes. In testing with
# Ruby 2.2 - 3.1, we determined an absolute minimum value for ASCII to be
# 535 bytes to obtain at least a 10% savings in size. It is recommended
# that this value be kept above that 535 number. It is also important to
# consider the CPU cost involved with performing compression and to find
# a balance between CPU cycles spent and bandwidth saved. A good
# reasonable default here is 2048 bytes, which is a tried and true Apache
# Tomcat default (as of v8.5.78)
#
# source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#41
NewRelic::Agent::NewRelicService::MIN_BYTE_SIZE_TO_COMPRESS = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/agent/new_relic_service/marshaller.rb#8
class NewRelic::Agent::NewRelicService::Marshaller
  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service/marshaller.rb#20
  def default_encoder; end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service/marshaller.rb#9
  def prepare(data, options = T.unsafe(nil)); end

  protected

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service/marshaller.rb#30
  def return_value(data); end

  class << self
    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/new_relic_service/marshaller.rb#24
    def human_readable?; end
  end
end

# Specifies the version of the agent's communication protocol with
# the NewRelic hosted site.
#
# source://newrelic_rpm//lib/new_relic/agent/new_relic_service.rb#17
NewRelic::Agent::NewRelicService::PROTOCOL_VERSION = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/agent/new_relic_service/security_policy_settings.rb#8
module NewRelic::Agent::NewRelicService::SecurityPolicySettings
  class << self
    # source://newrelic_rpm//lib/new_relic/agent/new_relic_service/security_policy_settings.rb#19
    def preliminary_settings(security_policies); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/new_relic_service/security_policy_settings.rb#9
NewRelic::Agent::NewRelicService::SecurityPolicySettings::EXPECTED_SECURITY_POLICIES = T.let(T.unsafe(nil), Array)

# source://newrelic_rpm//lib/new_relic/agent/new_relic_service/security_policy_settings.rb#28
class NewRelic::Agent::NewRelicService::SecurityPolicySettings::Validator
  # @return [Validator] a new instance of Validator
  #
  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service/security_policy_settings.rb#29
  def initialize(preconnect_response); end

  # source://newrelic_rpm//lib/new_relic/agent/new_relic_service/security_policy_settings.rb#33
  def validate_matching_agent_config!; end
end

# This class is used for instrumentations that have exceptions or error classes
# not derived from Ruby's usual Exception or StandardError or in situations
# where we do not have such Exception object to work with.
#
# source://newrelic_rpm//lib/new_relic/agent/noticeable_error.rb#10
class NewRelic::Agent::NoticeableError
  # @return [NoticeableError] a new instance of NoticeableError
  #
  # source://newrelic_rpm//lib/new_relic/agent/noticeable_error.rb#13
  def initialize(class_name, message); end

  # Returns the value of attribute class_name.
  #
  # source://newrelic_rpm//lib/new_relic/agent/noticeable_error.rb#11
  def class_name; end

  # Returns the value of attribute message.
  #
  # source://newrelic_rpm//lib/new_relic/agent/noticeable_error.rb#11
  def message; end
end

# source://newrelic_rpm//lib/new_relic/agent/null_logger.rb#9
class NewRelic::Agent::NullLogger
  # source://newrelic_rpm//lib/new_relic/agent/null_logger.rb#18
  def debug(*args); end

  # source://newrelic_rpm//lib/new_relic/agent/null_logger.rb#12
  def error(*args); end

  # source://newrelic_rpm//lib/new_relic/agent/null_logger.rb#10
  def fatal(*args); end

  # source://newrelic_rpm//lib/new_relic/agent/null_logger.rb#16
  def info(*args); end

  # source://newrelic_rpm//lib/new_relic/agent/null_logger.rb#20
  def method_missing(method, *args, &blk); end

  # source://newrelic_rpm//lib/new_relic/agent/null_logger.rb#14
  def warn(*args); end
end

# source://newrelic_rpm//lib/new_relic/agent/obfuscator.rb#7
class NewRelic::Agent::Obfuscator
  # RUM uses a shortened key, so just trim it up front
  #
  # @return [Obfuscator] a new instance of Obfuscator
  #
  # source://newrelic_rpm//lib/new_relic/agent/obfuscator.rb#14
  def initialize(key, length = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/obfuscator.rb#27
  def deobfuscate(text); end

  # source://newrelic_rpm//lib/new_relic/agent/obfuscator.rb#31
  def encode(text); end

  # Returns the value of attribute key_bytes.
  #
  # source://newrelic_rpm//lib/new_relic/agent/obfuscator.rb#8
  def key_bytes; end

  # source://newrelic_rpm//lib/new_relic/agent/obfuscator.rb#23
  def obfuscate(text); end
end

# source://newrelic_rpm//lib/new_relic/agent/obfuscator.rb#10
NewRelic::Agent::Obfuscator::EMPTY_KEY_BYTES = T.let(T.unsafe(nil), Array)

# source://newrelic_rpm//lib/new_relic/agent/obfuscator.rb#11
NewRelic::Agent::Obfuscator::PACK_FORMAT = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/payload_metric_mapping.rb#8
module NewRelic::Agent::PayloadMetricMapping
  class << self
    # source://newrelic_rpm//lib/new_relic/agent/payload_metric_mapping.rb#15
    def append_mapped_metrics(txn_metrics, sample); end

    private

    # source://newrelic_rpm//lib/new_relic/agent/payload_metric_mapping.rb#30
    def map_metric(metric_name, to_add = T.unsafe(nil)); end
  end
end

# this logic was extracted from TransactionEventAggregator for reuse by
# the ErrorEventAggregator
#
# source://newrelic_rpm//lib/new_relic/agent/payload_metric_mapping.rb#12
NewRelic::Agent::PayloadMetricMapping::SPEC_MAPPINGS = T.let(T.unsafe(nil), Hash)

# --
# Manages the registering and servicing of pipes used by child
# processes to report data to their parent, rather than directly
# to the collector.
#
# source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#13
module NewRelic::Agent::PipeChannelManager
  extend ::NewRelic::Agent::PipeChannelManager

  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#20
  def channels; end

  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#24
  def listener; end

  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#16
  def register_report_channel(id); end
end

# source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#129
class NewRelic::Agent::PipeChannelManager::Listener
  # @return [Listener] a new instance of Listener
  #
  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#140
  def initialize; end

  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#218
  def close_all_pipes; end

  # This attr_accessor intentionally provides unsynchronized access to the
  # within the Resque child process, and must be unsynchronized in order
  # to avoid a potential deadlock in which the PipeChannelManager::Listener
  # thread in the parent process is holding the @pipes_lock at the time of
  # the fork.
  #
  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#138
  def pipes; end

  # This attr_accessor intentionally provides unsynchronized access to the
  # within the Resque child process, and must be unsynchronized in order
  # to avoid a potential deadlock in which the PipeChannelManager::Listener
  # thread in the parent process is holding the @pipes_lock at the time of
  # the fork.
  #
  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#138
  def pipes=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#153
  def register_pipe(id); end

  # This attr_accessor intentionally provides unsynchronized access to the
  # within the Resque child process, and must be unsynchronized in order
  # to avoid a potential deadlock in which the PipeChannelManager::Listener
  # thread in the parent process is holding the @pipes_lock at the time of
  # the fork.
  #
  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#138
  def select_timeout; end

  # This attr_accessor intentionally provides unsynchronized access to the
  # within the Resque child process, and must be unsynchronized in order
  # to avoid a potential deadlock in which the PipeChannelManager::Listener
  # thread in the parent process is holding the @pipes_lock at the time of
  # the fork.
  #
  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#138
  def select_timeout=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#161
  def start; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#232
  def started?; end

  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#209
  def stop; end

  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#203
  def stop_listener_thread; end

  # Returns the value of attribute thread.
  #
  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#130
  def thread; end

  # This attr_accessor intentionally provides unsynchronized access to the
  # within the Resque child process, and must be unsynchronized in order
  # to avoid a potential deadlock in which the PipeChannelManager::Listener
  # thread in the parent process is holding the @pipes_lock at the time of
  # the fork.
  #
  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#138
  def timeout; end

  # This attr_accessor intentionally provides unsynchronized access to the
  # within the Resque child process, and must be unsynchronized in order
  # to avoid a potential deadlock in which the PipeChannelManager::Listener
  # thread in the parent process is holding the @pipes_lock at the time of
  # the fork.
  #
  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#138
  def timeout=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#228
  def wake; end

  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#149
  def wakeup; end

  protected

  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#268
  def clean_up_pipes; end

  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#279
  def find_pipe_for_handle(out_handle); end

  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#238
  def merge_data_from_pipe(pipe_handle); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#264
  def should_keep_listening?; end

  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#256
  def unmarshal(data); end
end

# Expected initial sequence of events for Pipe usage:
#
# 1. Pipe is created in parent process (read and write ends open)
# 2. Parent process forks
# 3. An after_fork hook is invoked in the child
# 4. From after_fork hook, child closes read end of pipe, and
#    writes a ready marker on the pipe (after_fork_in_child).
# 5. The parent receives the ready marker, and closes the write end of the
#    pipe in response (after_fork_in_parent).
#
# After this sequence of steps, an exit (whether clean or not) of the
# child will result in the pipe being marked readable again, and giving an
# EOF marker (nil) when read. Note that closing of the unused ends of the
# pipe in the parent and child processes is essential in order for the EOF
# to be correctly triggered. The ready marker mechanism is used because
# there's no easy hook for after_fork in the parent process.
#
# This class provides message framing (separation of individual messages),
# but not serialization. Serialization / deserialization is the
# responsibility of clients.
#
# Message framing works like this:
#
# Each message sent across the pipe is preceded by a length tag that
# specifies the length of the message that immediately follows, in bytes.
# The length tags are serialized as unsigned big-endian long values, (4
# bytes each). This means that the maximum theoretical message size is
# 4 GB - much larger than we'd ever need or want for this application.
#
# source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#57
class NewRelic::Agent::PipeChannelManager::Pipe
  # @return [Pipe] a new instance of Pipe
  #
  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#64
  def initialize; end

  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#115
  def after_fork_in_child; end

  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#120
  def after_fork_in_parent; end

  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#73
  def close; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#124
  def closed?; end

  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#82
  def deserialize_message_length(data); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#111
  def eof?; end

  # Returns the value of attribute in.
  #
  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#61
  def in; end

  # Sets the attribute in
  #
  # @param value the value to set the attribute in to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#61
  def in=(_arg0); end

  # Returns the value of attribute last_read.
  #
  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#62
  def last_read; end

  # Returns the value of attribute out.
  #
  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#61
  def out; end

  # Sets the attribute out
  #
  # @param value the value to set the attribute out to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#61
  def out=(_arg0); end

  # Returns the value of attribute parent_pid.
  #
  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#62
  def parent_pid; end

  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#92
  def read; end

  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#78
  def serialize_message_length(data); end

  # source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#86
  def write(data); end
end

# source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#59
NewRelic::Agent::PipeChannelManager::Pipe::NUM_LENGTH_BYTES = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/agent/pipe_channel_manager.rb#58
NewRelic::Agent::PipeChannelManager::Pipe::READY_MARKER = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/pipe_service.rb#7
class NewRelic::Agent::PipeService
  # @return [PipeService] a new instance of PipeService
  #
  # source://newrelic_rpm//lib/new_relic/agent/pipe_service.rb#11
  def initialize(channel_id); end

  # Returns the value of attribute agent_id.
  #
  # source://newrelic_rpm//lib/new_relic/agent/pipe_service.rb#9
  def agent_id; end

  # Sets the attribute agent_id
  #
  # @param value the value to set the attribute agent_id to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/pipe_service.rb#9
  def agent_id=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/agent/pipe_service.rb#30
  def analytic_event_data(events); end

  # Returns the value of attribute buffer.
  #
  # source://newrelic_rpm//lib/new_relic/agent/pipe_service.rb#8
  def buffer; end

  # Returns the value of attribute channel_id.
  #
  # source://newrelic_rpm//lib/new_relic/agent/pipe_service.rb#8
  def channel_id; end

  # Returns the value of attribute collector.
  #
  # source://newrelic_rpm//lib/new_relic/agent/pipe_service.rb#9
  def collector; end

  # Sets the attribute collector
  #
  # @param value the value to set the attribute collector to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/pipe_service.rb#9
  def collector=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/agent/pipe_service.rb#22
  def connect(config); end

  # source://newrelic_rpm//lib/new_relic/agent/pipe_service.rb#34
  def custom_event_data(events); end

  # source://newrelic_rpm//lib/new_relic/agent/pipe_service.rb#47
  def error_data(errors); end

  # source://newrelic_rpm//lib/new_relic/agent/pipe_service.rb#51
  def error_event_data(events); end

  # source://newrelic_rpm//lib/new_relic/agent/pipe_service.rb#26
  def get_agent_commands; end

  # source://newrelic_rpm//lib/new_relic/agent/pipe_service.rb#63
  def log_event_data(logs); end

  # source://newrelic_rpm//lib/new_relic/agent/pipe_service.rb#38
  def metric_data(unsent_timeslice_data); end

  # Returns the value of attribute pipe.
  #
  # source://newrelic_rpm//lib/new_relic/agent/pipe_service.rb#8
  def pipe; end

  # Returns the value of attribute request_timeout.
  #
  # source://newrelic_rpm//lib/new_relic/agent/pipe_service.rb#9
  def request_timeout; end

  # Sets the attribute request_timeout
  #
  # @param value the value to set the attribute request_timeout to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/pipe_service.rb#9
  def request_timeout=(_arg0); end

  # Invokes the block it is passed.  This is used to implement HTTP
  # keep-alive in the NewRelicService, and is a required interface for any
  # Service class.
  #
  # source://newrelic_rpm//lib/new_relic/agent/pipe_service.rb#75
  def session; end

  # source://newrelic_rpm//lib/new_relic/agent/pipe_service.rb#67
  def shutdown; end

  # source://newrelic_rpm//lib/new_relic/agent/pipe_service.rb#55
  def span_event_data(events); end

  # source://newrelic_rpm//lib/new_relic/agent/pipe_service.rb#59
  def sql_trace_data(sql); end

  # source://newrelic_rpm//lib/new_relic/agent/pipe_service.rb#43
  def transaction_sample_data(transactions); end

  private

  # source://newrelic_rpm//lib/new_relic/agent/pipe_service.rb#81
  def marshal_payload(data); end

  # source://newrelic_rpm//lib/new_relic/agent/pipe_service.rb#85
  def write_to_pipe(endpoint, data); end
end

# source://newrelic_rpm//lib/new_relic/agent/priority_sampled_buffer.rb#10
class NewRelic::Agent::PrioritySampledBuffer < ::NewRelic::Agent::EventBuffer
  # @return [PrioritySampledBuffer] a new instance of PrioritySampledBuffer
  #
  # source://newrelic_rpm//lib/new_relic/agent/priority_sampled_buffer.rb#15
  def initialize(capacity); end

  # expects priority and a block, or an event as a hash with a `priority` key.
  #
  # source://newrelic_rpm//lib/new_relic/agent/priority_sampled_buffer.rb#28
  def append(priority: T.unsafe(nil), event: T.unsafe(nil), &blk); end

  # expects priority and a block, or an event as a hash with a `priority` key.
  #
  # source://newrelic_rpm//lib/new_relic/agent/priority_sampled_buffer.rb#28
  def append_event(priority: T.unsafe(nil), event: T.unsafe(nil), &blk); end

  # source://newrelic_rpm//lib/new_relic/agent/priority_sampled_buffer.rb#51
  def capacity=(new_capacity); end

  # Returns the value of attribute captured_lifetime.
  #
  # source://newrelic_rpm//lib/new_relic/agent/priority_sampled_buffer.rb#13
  def captured_lifetime; end

  # source://newrelic_rpm//lib/new_relic/agent/priority_sampled_buffer.rb#64
  def decrement_lifetime_counts_by(n); end

  # source://newrelic_rpm//lib/new_relic/agent/priority_sampled_buffer.rb#21
  def heapify_items_array; end

  # source://newrelic_rpm//lib/new_relic/agent/priority_sampled_buffer.rb#73
  def metadata; end

  # source://newrelic_rpm//lib/new_relic/agent/priority_sampled_buffer.rb#69
  def sample_rate_lifetime; end

  # Returns the value of attribute seen_lifetime.
  #
  # source://newrelic_rpm//lib/new_relic/agent/priority_sampled_buffer.rb#13
  def seen_lifetime; end

  # source://newrelic_rpm//lib/new_relic/agent/priority_sampled_buffer.rb#60
  def to_a; end

  private

  # source://newrelic_rpm//lib/new_relic/agent/priority_sampled_buffer.rb#82
  def increment_seen; end

  # source://newrelic_rpm//lib/new_relic/agent/priority_sampled_buffer.rb#87
  def priority_for(event); end
end

# source://newrelic_rpm//lib/new_relic/agent/priority_sampled_buffer.rb#11
NewRelic::Agent::PrioritySampledBuffer::PRIORITY_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/rules_engine/replacement_rule.rb#7
class NewRelic::Agent::RulesEngine
  include ::Enumerable
  extend ::Forwardable

  # @return [RulesEngine] a new instance of RulesEngine
  #
  # source://newrelic_rpm//lib/new_relic/agent/rules_engine.rb#57
  def initialize(rules = T.unsafe(nil), segment_term_rules = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/rules_engine.rb#62
  def apply_rules(rules, string); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def clear(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def each(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def inspect(*args, **_arg1, &block); end

  # source://newrelic_rpm//lib/new_relic/agent/rules_engine.rb#72
  def rename(original_string); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def size(*args, **_arg1, &block); end

  class << self
    # source://newrelic_rpm//lib/new_relic/agent/rules_engine.rb#20
    def create_metric_rules(connect_response); end

    # source://newrelic_rpm//lib/new_relic/agent/rules_engine.rb#26
    def create_transaction_rules(connect_response); end

    # When multiple rules share the same prefix,
    # only apply the rule with the last instance of the prefix.
    # Note that the incoming rules are in reverse order to facilitate this.
    #
    # source://newrelic_rpm//lib/new_relic/agent/rules_engine.rb#53
    def reject_rules_with_duplicate_prefixes!(rules); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/rules_engine.rb#13
NewRelic::Agent::RulesEngine::LEADING_SLASH_REGEX = T.let(T.unsafe(nil), Regexp)

# source://newrelic_rpm//lib/new_relic/agent/rules_engine/replacement_rule.rb#8
class NewRelic::Agent::RulesEngine::ReplacementRule
  # @return [ReplacementRule] a new instance of ReplacementRule
  #
  # source://newrelic_rpm//lib/new_relic/agent/rules_engine/replacement_rule.rb#12
  def initialize(options); end

  # source://newrelic_rpm//lib/new_relic/agent/rules_engine/replacement_rule.rb#70
  def <=>(other); end

  # source://newrelic_rpm//lib/new_relic/agent/rules_engine/replacement_rule.rb#43
  def apply(string); end

  # source://newrelic_rpm//lib/new_relic/agent/rules_engine/replacement_rule.rb#53
  def apply_replacement(string); end

  # source://newrelic_rpm//lib/new_relic/agent/rules_engine/replacement_rule.rb#58
  def apply_to_each_segment(string); end

  # Returns the value of attribute each_segment.
  #
  # source://newrelic_rpm//lib/new_relic/agent/rules_engine/replacement_rule.rb#9
  def each_segment; end

  # Returns the value of attribute eval_order.
  #
  # source://newrelic_rpm//lib/new_relic/agent/rules_engine/replacement_rule.rb#9
  def eval_order; end

  # Returns the value of attribute ignore.
  #
  # source://newrelic_rpm//lib/new_relic/agent/rules_engine/replacement_rule.rb#9
  def ignore; end

  # Returns the value of attribute match_expression.
  #
  # source://newrelic_rpm//lib/new_relic/agent/rules_engine/replacement_rule.rb#9
  def match_expression; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/rules_engine/replacement_rule.rb#33
  def matches?(string); end

  # Returns the value of attribute replace_all.
  #
  # source://newrelic_rpm//lib/new_relic/agent/rules_engine/replacement_rule.rb#9
  def replace_all; end

  # Returns the value of attribute replacement.
  #
  # source://newrelic_rpm//lib/new_relic/agent/rules_engine/replacement_rule.rb#9
  def replacement; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/rules_engine/replacement_rule.rb#29
  def terminal?; end

  # Returns the value of attribute terminate_chain.
  #
  # source://newrelic_rpm//lib/new_relic/agent/rules_engine/replacement_rule.rb#9
  def terminate_chain; end
end

# source://newrelic_rpm//lib/new_relic/agent/rules_engine.rb#12
NewRelic::Agent::RulesEngine::SEGMENT_SEPARATOR = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/rules_engine/segment_terms_rule.rb#8
class NewRelic::Agent::RulesEngine::SegmentTermsRule
  # @return [SegmentTermsRule] a new instance of SegmentTermsRule
  #
  # source://newrelic_rpm//lib/new_relic/agent/rules_engine/segment_terms_rule.rb#30
  def initialize(options); end

  # source://newrelic_rpm//lib/new_relic/agent/rules_engine/segment_terms_rule.rb#50
  def apply(string); end

  # source://newrelic_rpm//lib/new_relic/agent/rules_engine/segment_terms_rule.rb#60
  def collapse_adjacent_placeholder_segments(segments); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/rules_engine/segment_terms_rule.rb#40
  def matches?(string); end

  # Returns the value of attribute prefix.
  #
  # source://newrelic_rpm//lib/new_relic/agent/rules_engine/segment_terms_rule.rb#14
  def prefix; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/rules_engine/segment_terms_rule.rb#45
  def prefix_matches_on_segment_boundary?(string); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/rules_engine/segment_terms_rule.rb#36
  def terminal?; end

  # Returns the value of attribute terms.
  #
  # source://newrelic_rpm//lib/new_relic/agent/rules_engine/segment_terms_rule.rb#14
  def terms; end

  class << self
    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/rules_engine/segment_terms_rule.rb#16
    def valid?(rule_spec); end

    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/rules_engine/segment_terms_rule.rb#22
    def valid_prefix_segment_count?(prefix); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/rules_engine/segment_terms_rule.rb#11
NewRelic::Agent::RulesEngine::SegmentTermsRule::ADJACENT_PLACEHOLDERS_REGEX = T.let(T.unsafe(nil), Regexp)

# source://newrelic_rpm//lib/new_relic/agent/rules_engine/segment_terms_rule.rb#12
NewRelic::Agent::RulesEngine::SegmentTermsRule::ADJACENT_PLACEHOLDERS_REPLACEMENT = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/rules_engine/segment_terms_rule.rb#9
NewRelic::Agent::RulesEngine::SegmentTermsRule::PREFIX_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/rules_engine/segment_terms_rule.rb#10
NewRelic::Agent::RulesEngine::SegmentTermsRule::TERMS_KEY = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent.rb#810
NewRelic::Agent::SPAN_ID_KEY = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent.rb#228
NewRelic::Agent::SUPPORTABILITY_INCREMENT_METRIC = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/sampler.rb#15
class NewRelic::Agent::Sampler
  # The ID passed in here is unused by our code, but is preserved in case
  # we have clients who are defining their own subclasses of this class, and
  # expecting to be able to call super with an ID.
  #
  # @return [Sampler] a new instance of Sampler
  #
  # source://newrelic_rpm//lib/new_relic/agent/sampler.rb#55
  def initialize(id = T.unsafe(nil)); end

  # Returns the value of attribute id.
  #
  # source://newrelic_rpm//lib/new_relic/agent/sampler.rb#19
  def id; end

  # source://newrelic_rpm//lib/new_relic/agent/sampler.rb#59
  def poll; end

  class << self
    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/sampler.rb#39
    def enabled?; end

    # @private
    #
    # source://newrelic_rpm//lib/new_relic/agent/sampler.rb#30
    def inherited(subclass); end

    # source://newrelic_rpm//lib/new_relic/agent/sampler.rb#26
    def named(new_name); end

    # source://newrelic_rpm//lib/new_relic/agent/sampler.rb#48
    def sampler_classes; end

    # Returns the value of attribute shorthand_name.
    #
    # source://newrelic_rpm//lib/new_relic/agent/sampler.rb#23
    def shorthand_name; end

    # Override with check.  Called before instantiating.
    #
    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/sampler.rb#35
    def supported_on_this_platform?; end
  end
end

# Exception denotes a sampler is not available and it will not be registered.
#
# source://newrelic_rpm//lib/new_relic/agent/sampler.rb#17
class NewRelic::Agent::Sampler::Unsupported < ::StandardError; end

# source://newrelic_rpm//lib/new_relic/agent/sampler_collection.rb#7
class NewRelic::Agent::SamplerCollection
  include ::Enumerable

  # @return [SamplerCollection] a new instance of SamplerCollection
  #
  # source://newrelic_rpm//lib/new_relic/agent/sampler_collection.rb#10
  def initialize(event_listener); end

  # source://newrelic_rpm//lib/new_relic/agent/sampler_collection.rb#49
  def add_sampler(sampler_class); end

  # source://newrelic_rpm//lib/new_relic/agent/sampler_collection.rb#20
  def clear; end

  # source://newrelic_rpm//lib/new_relic/agent/sampler_collection.rb#16
  def each(&blk); end

  # adds samplers to the sampler collection so that they run every
  # minute. This is dynamically recognized by any class that
  # subclasses NewRelic::Agent::Sampler
  #
  # source://newrelic_rpm//lib/new_relic/agent/sampler_collection.rb#31
  def load_samplers; end

  # source://newrelic_rpm//lib/new_relic/agent/sampler_collection.rb#37
  def poll_samplers; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/sampler_collection.rb#24
  def sampler_class_registered?(sampler_class); end
end

# source://newrelic_rpm//lib/new_relic/agent/samplers/cpu_sampler.rb#9
module NewRelic::Agent::Samplers; end

# source://newrelic_rpm//lib/new_relic/agent/samplers/cpu_sampler.rb#10
class NewRelic::Agent::Samplers::CpuSampler < ::NewRelic::Agent::Sampler
  # @return [CpuSampler] a new instance of CpuSampler
  #
  # source://newrelic_rpm//lib/new_relic/agent/samplers/cpu_sampler.rb#15
  def initialize; end

  # Returns the value of attribute last_time.
  #
  # source://newrelic_rpm//lib/new_relic/agent/samplers/cpu_sampler.rb#11
  def last_time; end

  # source://newrelic_rpm//lib/new_relic/agent/samplers/cpu_sampler.rb#51
  def poll; end

  # source://newrelic_rpm//lib/new_relic/agent/samplers/cpu_sampler.rb#29
  def record_system_util(value); end

  # source://newrelic_rpm//lib/new_relic/agent/samplers/cpu_sampler.rb#37
  def record_systemtime(value); end

  # source://newrelic_rpm//lib/new_relic/agent/samplers/cpu_sampler.rb#25
  def record_user_util(value); end

  # source://newrelic_rpm//lib/new_relic/agent/samplers/cpu_sampler.rb#33
  def record_usertime(value); end

  class << self
    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/samplers/cpu_sampler.rb#41
    def supported_on_this_platform?; end
  end
end

# This sampler records the status of your delayed job table once a minute.
# It assumes jobs are cleared after being run, and failed jobs are not (otherwise
# the failed job metric is useless).
#
# In earlier versions it will break out the queue length by priority.  In later
# versions of DJ where distinct queues are supported, it breaks it out by queue name.
#
# source://newrelic_rpm//lib/new_relic/agent/samplers/delayed_job_sampler.rb#18
class NewRelic::Agent::Samplers::DelayedJobSampler < ::NewRelic::Agent::Sampler
  # @raise [Unsupported]
  # @return [DelayedJobSampler] a new instance of DelayedJobSampler
  #
  # source://newrelic_rpm//lib/new_relic/agent/samplers/delayed_job_sampler.rb#27
  def initialize; end

  # source://newrelic_rpm//lib/new_relic/agent/samplers/delayed_job_sampler.rb#52
  def count(query); end

  # source://newrelic_rpm//lib/new_relic/agent/samplers/delayed_job_sampler.rb#44
  def failed_jobs; end

  # source://newrelic_rpm//lib/new_relic/agent/samplers/delayed_job_sampler.rb#48
  def locked_jobs; end

  # source://newrelic_rpm//lib/new_relic/agent/samplers/delayed_job_sampler.rb#64
  def poll; end

  # source://newrelic_rpm//lib/new_relic/agent/samplers/delayed_job_sampler.rb#33
  def record_failed_jobs(value); end

  # source://newrelic_rpm//lib/new_relic/agent/samplers/delayed_job_sampler.rb#37
  def record_locked_jobs(value); end

  private

  # source://newrelic_rpm//lib/new_relic/agent/samplers/delayed_job_sampler.rb#97
  def queue_counts(column_name); end

  # source://newrelic_rpm//lib/new_relic/agent/samplers/delayed_job_sampler.rb#86
  def record_counts_by(column_name, metric_node = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/samplers/delayed_job_sampler.rb#75
  def record_queue_length_metrics; end

  class << self
    # DelayedJob supports multiple backends, only some of which we can
    # handle. Check whether we think we've got what we need here.
    #
    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/samplers/delayed_job_sampler.rb#23
    def supported_backend?; end

    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/samplers/delayed_job_sampler.rb#60
    def supported_on_this_platform?; end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/samplers/delayed_job_sampler.rb#41
NewRelic::Agent::Samplers::DelayedJobSampler::FAILED_QUERY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/samplers/delayed_job_sampler.rb#42
NewRelic::Agent::Samplers::DelayedJobSampler::LOCKED_QUERY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/samplers/delayed_job_sampler.rb#84
NewRelic::Agent::Samplers::DelayedJobSampler::QUEUE_QUERY_CONDITION = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/samplers/memory_sampler.rb#11
class NewRelic::Agent::Samplers::MemorySampler < ::NewRelic::Agent::Sampler
  # @raise [Unsupported]
  # @return [MemorySampler] a new instance of MemorySampler
  #
  # source://newrelic_rpm//lib/new_relic/agent/samplers/memory_sampler.rb#16
  def initialize; end

  # source://newrelic_rpm//lib/new_relic/agent/samplers/memory_sampler.rb#60
  def platform; end

  # source://newrelic_rpm//lib/new_relic/agent/samplers/memory_sampler.rb#64
  def poll; end

  # Returns the value of attribute sampler.
  #
  # source://newrelic_rpm//lib/new_relic/agent/samplers/memory_sampler.rb#14
  def sampler; end

  # Sets the attribute sampler
  #
  # @param value the value to set the attribute sampler to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/samplers/memory_sampler.rb#14
  def sampler=(_arg0); end

  class << self
    # source://newrelic_rpm//lib/new_relic/agent/samplers/memory_sampler.rb#48
    def platform; end

    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/samplers/memory_sampler.rb#44
    def supported_on_this_platform?; end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/samplers/memory_sampler.rb#71
class NewRelic::Agent::Samplers::MemorySampler::Base
  # @return [Base] a new instance of Base
  #
  # source://newrelic_rpm//lib/new_relic/agent/samplers/memory_sampler.rb#72
  def initialize; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/samplers/memory_sampler.rb#76
  def can_run?; end

  # source://newrelic_rpm//lib/new_relic/agent/samplers/memory_sampler.rb#83
  def get_sample; end
end

# source://newrelic_rpm//lib/new_relic/agent/samplers/memory_sampler.rb#101
class NewRelic::Agent::Samplers::MemorySampler::JavaHeapSampler < ::NewRelic::Agent::Samplers::MemorySampler::Base
  # source://newrelic_rpm//lib/new_relic/agent/samplers/memory_sampler.rb#102
  def get_memory; end

  # source://newrelic_rpm//lib/new_relic/agent/samplers/memory_sampler.rb#108
  def to_s; end
end

# ProcStatus
#
# A class that samples memory by reading the file /proc/$$/status, which is specific to linux
#
# source://newrelic_rpm//lib/new_relic/agent/samplers/memory_sampler.rb#140
class NewRelic::Agent::Samplers::MemorySampler::ProcStatus < ::NewRelic::Agent::Samplers::MemorySampler::Base
  # Returns the amount of resident memory this process is using in MB
  #
  # source://newrelic_rpm//lib/new_relic/agent/samplers/memory_sampler.rb#142
  def get_memory; end

  # source://newrelic_rpm//lib/new_relic/agent/samplers/memory_sampler.rb#151
  def proc_status_file; end

  # source://newrelic_rpm//lib/new_relic/agent/samplers/memory_sampler.rb#155
  def to_s; end
end

# source://newrelic_rpm//lib/new_relic/agent/samplers/memory_sampler.rb#113
class NewRelic::Agent::Samplers::MemorySampler::ShellPS < ::NewRelic::Agent::Samplers::MemorySampler::Base
  # @return [ShellPS] a new instance of ShellPS
  #
  # source://newrelic_rpm//lib/new_relic/agent/samplers/memory_sampler.rb#114
  def initialize(command); end

  # Returns the amount of resident memory this process is using in MB
  #
  # source://newrelic_rpm//lib/new_relic/agent/samplers/memory_sampler.rb#121
  def get_memory; end

  # source://newrelic_rpm//lib/new_relic/agent/samplers/memory_sampler.rb#131
  def to_s; end
end

# source://newrelic_rpm//lib/new_relic/agent/samplers/object_sampler.rb#10
class NewRelic::Agent::Samplers::ObjectSampler < ::NewRelic::Agent::Sampler
  # source://newrelic_rpm//lib/new_relic/agent/samplers/object_sampler.rb#17
  def poll; end

  class << self
    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/samplers/object_sampler.rb#13
    def supported_on_this_platform?; end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/samplers/vm_sampler.rb#11
class NewRelic::Agent::Samplers::VMSampler < ::NewRelic::Agent::Sampler
  # @return [VMSampler] a new instance of VMSampler
  #
  # source://newrelic_rpm//lib/new_relic/agent/samplers/vm_sampler.rb#27
  def initialize; end

  # source://newrelic_rpm//lib/new_relic/agent/samplers/vm_sampler.rb#41
  def on_transaction_finished(*_); end

  # source://newrelic_rpm//lib/new_relic/agent/samplers/vm_sampler.rb#108
  def poll; end

  # THREAD_LOCAL_ACCESS
  #
  # source://newrelic_rpm//lib/new_relic/agent/samplers/vm_sampler.rb#72
  def record_delta(snapshot, key, metric, txn_count); end

  # THREAD_LOCAL_ACCESS
  #
  # source://newrelic_rpm//lib/new_relic/agent/samplers/vm_sampler.rb#83
  def record_gauge_metric(metric_name, value); end

  # THREAD_LOCAL_ACCESS
  #
  # source://newrelic_rpm//lib/new_relic/agent/samplers/vm_sampler.rb#53
  def record_gc_runs_metric(snapshot, txn_count); end

  # source://newrelic_rpm//lib/new_relic/agent/samplers/vm_sampler.rb#96
  def record_heap_free_metric(snapshot); end

  # source://newrelic_rpm//lib/new_relic/agent/samplers/vm_sampler.rb#90
  def record_heap_live_metric(snapshot); end

  # source://newrelic_rpm//lib/new_relic/agent/samplers/vm_sampler.rb#102
  def record_thread_count_metric(snapshot); end

  # source://newrelic_rpm//lib/new_relic/agent/samplers/vm_sampler.rb#45
  def reset_transaction_count; end

  # source://newrelic_rpm//lib/new_relic/agent/samplers/vm_sampler.rb#37
  def setup_events(event_listener); end

  # source://newrelic_rpm//lib/new_relic/agent/samplers/vm_sampler.rb#33
  def take_snapshot; end

  # Returns the value of attribute transaction_count.
  #
  # source://newrelic_rpm//lib/new_relic/agent/samplers/vm_sampler.rb#23
  def transaction_count; end
end

# source://newrelic_rpm//lib/new_relic/agent/samplers/vm_sampler.rb#20
NewRelic::Agent::Samplers::VMSampler::CONSTANT_INVALIDATIONS_METRIC = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/samplers/vm_sampler.rb#21
NewRelic::Agent::Samplers::VMSampler::CONSTANT_MISSES_METRIC = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/samplers/vm_sampler.rb#12
NewRelic::Agent::Samplers::VMSampler::GC_RUNS_METRIC = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/samplers/vm_sampler.rb#14
NewRelic::Agent::Samplers::VMSampler::HEAP_FREE_METRIC = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/samplers/vm_sampler.rb#13
NewRelic::Agent::Samplers::VMSampler::HEAP_LIVE_METRIC = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/samplers/vm_sampler.rb#17
NewRelic::Agent::Samplers::VMSampler::MAJOR_GC_METRIC = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/samplers/vm_sampler.rb#19
NewRelic::Agent::Samplers::VMSampler::METHOD_INVALIDATIONS_METRIC = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/samplers/vm_sampler.rb#18
NewRelic::Agent::Samplers::VMSampler::MINOR_GC_METRIC = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/samplers/vm_sampler.rb#16
NewRelic::Agent::Samplers::VMSampler::OBJECT_ALLOCATIONS_METRIC = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/samplers/vm_sampler.rb#15
NewRelic::Agent::Samplers::VMSampler::THREAD_COUNT_METRIC = T.let(T.unsafe(nil), String)

# An error while serializing data for the collector
#
# @api public
#
# source://newrelic_rpm//lib/new_relic/agent.rb#104
class NewRelic::Agent::SerializationError < ::StandardError; end

# Used to blow out of a periodic task without logging a an error, such as for routine
# failures.
#
# @api public
#
# source://newrelic_rpm//lib/new_relic/agent.rb#94
class NewRelic::Agent::ServerConnectionException < ::StandardError; end

# source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#236
class NewRelic::Agent::SlowSql
  # @return [SlowSql] a new instance of SlowSql
  #
  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#242
  def initialize(statement, metric_name, duration, backtrace = T.unsafe(nil), params = T.unsafe(nil)); end

  # Returns the value of attribute backtrace.
  #
  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#240
  def backtrace; end

  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#254
  def base_params; end

  # Returns the value of attribute duration.
  #
  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#239
  def duration; end

  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#277
  def explain; end

  # Returns the value of attribute metric_name.
  #
  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#238
  def metric_name; end

  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#272
  def normalize; end

  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#268
  def obfuscate; end

  # We can't serialize the explainer, so clear it before we transmit
  #
  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#284
  def prepare_to_send; end

  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#250
  def sql; end

  # Returns the value of attribute statement.
  #
  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#237
  def statement; end
end

# source://newrelic_rpm//lib/new_relic/agent/span_event_aggregator.rb#12
class NewRelic::Agent::SpanEventAggregator < ::NewRelic::Agent::EventAggregator
  # source://newrelic_rpm//lib/new_relic/agent/span_event_aggregator.rb#36
  def after_harvest(metadata); end

  # source://newrelic_rpm//lib/new_relic/agent/span_event_aggregator.rb#19
  def record(priority: T.unsafe(nil), event: T.unsafe(nil), &blk); end
end

# source://newrelic_rpm//lib/new_relic/agent/span_event_aggregator.rb#34
NewRelic::Agent::SpanEventAggregator::SUPPORTABILITY_DISCARDED = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/span_event_aggregator.rb#32
NewRelic::Agent::SpanEventAggregator::SUPPORTABILITY_TOTAL_SEEN = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/span_event_aggregator.rb#33
NewRelic::Agent::SpanEventAggregator::SUPPORTABILITY_TOTAL_SENT = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#13
module NewRelic::Agent::SpanEventPrimitive
  include ::NewRelic::Coerce
  extend ::NewRelic::Coerce
  extend ::NewRelic::Agent::SpanEventPrimitive

  # Builds a Hash of error attributes as well as the Span ID when
  # an error is present.  Otherwise, returns nil when no error present.
  #
  # source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#57
  def error_attributes(segment); end

  # source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#95
  def for_datastore_segment(segment); end

  # source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#71
  def for_external_request_segment(segment); end

  # source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#64
  def for_segment(segment); end

  private

  # source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#190
  def agent_attributes(segment); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#221
  def allowed?(key); end

  # source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#173
  def custom_attributes(segment); end

  # source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#131
  def intrinsics_for(segment); end

  # source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#183
  def merge_hashes(hash1, hash2); end

  # source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#208
  def milliseconds_since_epoch(segment); end

  # source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#200
  def parent_guid(segment); end

  # source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#212
  def truncate(value, max_size = T.unsafe(nil)); end
end

# source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#29
NewRelic::Agent::SpanEventPrimitive::CATEGORY_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#53
NewRelic::Agent::SpanEventPrimitive::CLIENT = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#34
NewRelic::Agent::SpanEventPrimitive::COMPONENT_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#52
NewRelic::Agent::SpanEventPrimitive::DATASTORE_CATEGORY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#35
NewRelic::Agent::SpanEventPrimitive::DB_INSTANCE_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#36
NewRelic::Agent::SpanEventPrimitive::DB_STATEMENT_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#37
NewRelic::Agent::SpanEventPrimitive::DB_SYSTEM_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#27
NewRelic::Agent::SpanEventPrimitive::DURATION_KEY = T.let(T.unsafe(nil), String)

# Strings for static keys of the event structure
#
# source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#18
NewRelic::Agent::SpanEventPrimitive::ELLIPSIS = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#43
NewRelic::Agent::SpanEventPrimitive::ENTRY_POINT_KEY = T.let(T.unsafe(nil), String)

# Strings for static values of the event structure
#
# source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#49
NewRelic::Agent::SpanEventPrimitive::EVENT_TYPE = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#50
NewRelic::Agent::SpanEventPrimitive::GENERIC_CATEGORY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#21
NewRelic::Agent::SpanEventPrimitive::GUID_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#51
NewRelic::Agent::SpanEventPrimitive::HTTP_CATEGORY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#31
NewRelic::Agent::SpanEventPrimitive::HTTP_METHOD_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#32
NewRelic::Agent::SpanEventPrimitive::HTTP_REQUEST_METHOD_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#33
NewRelic::Agent::SpanEventPrimitive::HTTP_STATUS_CODE_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#30
NewRelic::Agent::SpanEventPrimitive::HTTP_URL_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#28
NewRelic::Agent::SpanEventPrimitive::NAME_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#22
NewRelic::Agent::SpanEventPrimitive::PARENT_ID_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#38
NewRelic::Agent::SpanEventPrimitive::PEER_ADDRESS_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#39
NewRelic::Agent::SpanEventPrimitive::PEER_HOSTNAME_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#25
NewRelic::Agent::SpanEventPrimitive::PRIORITY_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#24
NewRelic::Agent::SpanEventPrimitive::SAMPLED_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#40
NewRelic::Agent::SpanEventPrimitive::SERVER_ADDRESS_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#41
NewRelic::Agent::SpanEventPrimitive::SERVER_PORT_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#42
NewRelic::Agent::SpanEventPrimitive::SPAN_KIND_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#26
NewRelic::Agent::SpanEventPrimitive::TIMESTAMP_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#20
NewRelic::Agent::SpanEventPrimitive::TRACE_ID_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#45
NewRelic::Agent::SpanEventPrimitive::TRACING_VENDORS_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#23
NewRelic::Agent::SpanEventPrimitive::TRANSACTION_ID_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#46
NewRelic::Agent::SpanEventPrimitive::TRANSACTION_NAME_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#44
NewRelic::Agent::SpanEventPrimitive::TRUSTED_PARENT_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/span_event_primitive.rb#19
NewRelic::Agent::SpanEventPrimitive::TYPE_KEY = T.let(T.unsafe(nil), String)

# This class contains the logic of recording slow SQL traces, which may
# represent multiple aggregated SQL queries.
#
# A slow SQL trace consists of a collection of SQL instrumented SQL queries
# that all normalize to the same text. For example, the following two
# queries would be aggregated together into a single slow SQL trace:
#
#   SELECT * FROM table WHERE id=42
#   SELECT * FROM table WHERE id=1234
#
# Each slow SQL trace keeps track of the number of times the same normalized
# query was seen, the min, max, and total time spent executing those
# queries, and an example backtrace from one of the aggregated queries.
#
# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#25
class NewRelic::Agent::SqlSampler
  # @api public
  # @return [SqlSampler] a new instance of SqlSampler
  #
  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#33
  def initialize; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#26
  def disabled; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#158
  def distributed_trace_attributes(state); end

  # @api public
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#42
  def enabled?; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#197
  def harvest!; end

  # this should always be called under the @samples_lock
  #
  # @api public
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#115
  def has_room?; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#184
  def merge!(sql_traces); end

  # Records an SQL query, potentially creating a new slow SQL trace, or
  # aggregating the query into an existing slow SQL trace.
  #
  # This method should be used only by gem authors wishing to extend
  # the Ruby agent to instrument new database interfaces - it should
  # generally not be called directly from application code.
  #
  # @api public
  # @deprecated Use {Datastores.notice_sql} instead.
  # @param sql [String] the SQL query being recorded
  # @param metric_name [String] is the metric name under which this query will be recorded
  # @param config [Object] is the driver configuration for the connection
  # @param duration [Float] number of seconds the query took to execute
  # @param explainer [Proc] for internal use only - 3rd-party clients must
  #   not pass this parameter.
  #
  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#142
  def notice_sql(sql, metric_name, config, duration, state = T.unsafe(nil), explainer = T.unsafe(nil), binds = T.unsafe(nil), name = T.unsafe(nil)); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#170
  def notice_sql_statement(statement, metric_name, duration); end

  # This is called when we are done with the transaction.
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#67
  def on_finishing_transaction(state, name); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#48
  def on_start_transaction(state, uri = T.unsafe(nil)); end

  # this should always be called under the @samples_lock
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#120
  def remove_shortest_trace; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#209
  def reset!; end

  # this should always be called under the @samples_lock
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#83
  def save_slow_sql(transaction_sql_data); end

  # this should always be called under the @samples_lock
  #
  # @api public
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#108
  def should_add_trace?(sql_item); end

  # this is for unit tests only
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#29
  def sql_traces; end

  # only used for testing
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#62
  def tl_transaction_data; end
end

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#31
NewRelic::Agent::SqlSampler::MAX_SAMPLES = T.let(T.unsafe(nil), Integer)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#156
NewRelic::Agent::SqlSampler::PRIORITY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#289
class NewRelic::Agent::SqlTrace < ::NewRelic::Agent::Stats
  include ::NewRelic::Coerce

  # @return [SqlTrace] a new instance of SqlTrace
  #
  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#298
  def initialize(normalized_query, slow_sql, path, uri); end

  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#315
  def aggregate(slow_sql, path, uri); end

  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#323
  def aggregate_trace(trace); end

  # Returns the value of attribute database_metric_name.
  #
  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#294
  def database_metric_name; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#337
  def need_to_explain?; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#333
  def need_to_obfuscate?; end

  # Returns the value of attribute params.
  #
  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#295
  def params; end

  # Returns the value of attribute path.
  #
  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#290
  def path; end

  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#327
  def prepare_to_send; end

  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#306
  def set_primary(slow_sql, path, uri); end

  # Returns the value of attribute slow_sql.
  #
  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#296
  def slow_sql; end

  # Returns the value of attribute sql.
  #
  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#293
  def sql; end

  # Returns the value of attribute sql_id.
  #
  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#292
  def sql_id; end

  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#343
  def to_collector_array(encoder); end

  # Returns the value of attribute url.
  #
  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#291
  def url; end

  private

  # need to hash the same way in every process, to be able to aggregate slow SQL traces
  #
  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#359
  def consistent_hash(string); end
end

# In an effort to not lose messages during startup, we trap them in memory
# The real logger will then dump its contents out when it arrives.
#
# source://newrelic_rpm//lib/new_relic/agent/agent_logger.rb#188
class NewRelic::Agent::StartupLogger < ::NewRelic::Agent::MemoryLogger
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  class << self
    private

    def allocate; end
    def new(*_arg0); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/stats.rb#7
class NewRelic::Agent::Stats
  # @return [Stats] a new instance of Stats
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats.rb#17
  def initialize; end

  # source://newrelic_rpm//lib/new_relic/agent/stats.rb#125
  def ==(other); end

  # Returns the value of attribute total_exclusive_time.
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats.rb#14
  def apdex_f; end

  # Returns the value of attribute call_count.
  # Apdex-related accessors
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats.rb#10
  def apdex_s; end

  # Returns the value of attribute total_call_time.
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats.rb#13
  def apdex_t; end

  # Returns the value of attribute call_count.
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats.rb#10
  def call_count; end

  # Sets the attribute call_count
  #
  # @param value the value to set the attribute call_count to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats.rb#10
  def call_count=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/agent/stats.rb#52
  def hash_merge(hash); end

  # increments the call_count by one
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats.rb#112
  def increment_count(value = T.unsafe(nil)); end

  # Concerned about implicit usage of inspect relying on stats format, so
  # putting back a version to get full inspection as separate method
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats.rb#118
  def inspect_full; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats.rb#31
  def is_reset?; end

  # Override marshalling methods to exclude @lock from being included in marshalled data
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats.rb#159
  def marshal_dump; end

  # source://newrelic_rpm//lib/new_relic/agent/stats.rb#167
  def marshal_load(marshalled_data); end

  # Returns the value of attribute max_call_time.
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats.rb#12
  def max_call_time; end

  # Sets the attribute max_call_time
  #
  # @param value the value to set the attribute max_call_time to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats.rb#12
  def max_call_time=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/agent/stats.rb#35
  def merge(other_stats); end

  # source://newrelic_rpm//lib/new_relic/agent/stats.rb#40
  def merge!(other); end

  # Returns the value of attribute min_call_time.
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats.rb#11
  def min_call_time; end

  # Sets the attribute min_call_time
  #
  # @param value the value to set the attribute min_call_time to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats.rb#11
  def min_call_time=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/agent/stats.rb#77
  def record(value = T.unsafe(nil), aux = T.unsafe(nil), &blk); end

  # source://newrelic_rpm//lib/new_relic/agent/stats.rb#142
  def record_apdex(bucket, apdex_t); end

  # record a single data point into the statistical gatherer.  The gatherer
  # will aggregate all data points collected over a specified period and upload
  # its data to the NewRelic server
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats.rb#96
  def record_data_point(value, exclusive_time = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/stats.rb#22
  def reset; end

  # Returns the value of attribute sum_of_squares.
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats.rb#15
  def sum_of_squares; end

  # Sets the attribute sum_of_squares
  #
  # @param value the value to set the attribute sum_of_squares to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats.rb#15
  def sum_of_squares=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/agent/stats.rb#62
  def to_json(*_); end

  # source://newrelic_rpm//lib/new_relic/agent/stats.rb#73
  def to_s; end

  # Returns the value of attribute total_call_time.
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats.rb#13
  def total_call_time; end

  # Sets the attribute total_call_time
  #
  # @param value the value to set the attribute total_call_time to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats.rb#13
  def total_call_time=(_arg0); end

  # Returns the value of attribute total_exclusive_time.
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats.rb#14
  def total_exclusive_time; end

  # Sets the attribute total_exclusive_time
  #
  # @param value the value to set the attribute total_exclusive_time to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats.rb#14
  def total_exclusive_time=(_arg0); end

  # record a single data point into the statistical gatherer.  The gatherer
  # will aggregate all data points collected over a specified period and upload
  # its data to the NewRelic server
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats.rb#96
  def trace_call(value, exclusive_time = T.unsafe(nil)); end

  protected

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats.rb#177
  def min_time_less?(other); end
end

# source://newrelic_rpm//lib/new_relic/agent/stats.rb#8
NewRelic::Agent::Stats::SKIP_MARSHALLING = T.let(T.unsafe(nil), Array)

# This class handles all the statistics gathering for the agent
#
# source://newrelic_rpm//lib/new_relic/agent/stats_engine/gc_profiler.rb#7
class NewRelic::Agent::StatsEngine
  # @return [StatsEngine] a new instance of StatsEngine
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats_engine.rb#15
  def initialize; end

  # source://newrelic_rpm//lib/new_relic/agent/stats_engine.rb#160
  def apply_rules_to_metric_data(rules_engine, stats_hash); end

  # For use by test code only.
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats_engine.rb#187
  def clear_stats; end

  # source://newrelic_rpm//lib/new_relic/agent/stats_engine.rb#172
  def coerce_to_metric_spec_array(metric_names_or_specs, scope); end

  # source://newrelic_rpm//lib/new_relic/agent/stats_engine.rb#152
  def harvest!; end

  # merge data from previous harvests into this stats engine
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats_engine.rb#139
  def merge!(other_stats_hash); end

  # source://newrelic_rpm//lib/new_relic/agent/stats_engine.rb#146
  def merge_transaction_metrics!(txn_metrics, scope); end

  # Returns the value of attribute metric_rules.
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats_engine.rb#13
  def metric_rules; end

  # Sets the attribute metric_rules
  #
  # @param value the value to set the attribute metric_rules to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats_engine.rb#13
  def metric_rules=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/agent/stats_engine.rb#104
  def record_scoped_and_unscoped_metrics(state, scoped_metric, summary_metrics = T.unsafe(nil), value = T.unsafe(nil), aux = T.unsafe(nil), &blk); end

  # source://newrelic_rpm//lib/new_relic/agent/stats_engine.rb#68
  def record_unscoped_metrics(state, metric_names, value = T.unsafe(nil), aux = T.unsafe(nil), &blk); end

  # source://newrelic_rpm//lib/new_relic/agent/stats_engine.rb#130
  def reset!; end

  # Like tl_record_unscoped_metrics, but records a scoped metric as well.
  #
  # This is an internal method, subject to change at any time. Client apps
  # and gems should use the public API (NewRelic::Agent.record_metric)
  # instead.
  #
  # The given scoped_metric will be recoded as both a scoped *and* an
  # unscoped metric. The summary_metrics will be recorded as unscoped
  # metrics only.
  #
  # If called during a transaction, all metrics will be attached to the
  # Transaction, and not merged into the global set of metrics until the
  # end of the transaction.
  #
  # If called outside of a transaction, only the *unscoped* metrics will
  # be recorded, directly into the global set of metrics (under a lock).
  #
  # @api private
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats_engine.rb#99
  def tl_record_scoped_and_unscoped_metrics(scoped_metric, summary_metrics = T.unsafe(nil), value = T.unsafe(nil), aux = T.unsafe(nil), &blk); end

  # Helper for recording a straight value into the count
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats_engine.rb#123
  def tl_record_supportability_metric_count(metric, value); end

  # Update the unscoped metrics given in metric_names.
  # metric_names may be either a single name, or an array of names.
  #
  # This is an internal method, subject to change at any time. Client apps
  # and gems should use the public API (NewRelic::Agent.record_metric)
  # instead.
  #
  # There are four ways to use this method:
  #
  # 1. With a numeric value, it will update the Stats objects associated
  #    with the given metrics by calling record_data_point(value, aux).
  #    aux will be treated in this case as the exclusive time associated
  #    with the call being recorded.
  #
  # 2. With a value of :apdex_s, :apdex_t, or :apdex_f, it will treat the
  #    associated stats as an Apdex metric, updating it to reflect the
  #    occurrence of a transaction falling into the given category.
  #    The aux value in this case should be the apdex threshold used in
  #    bucketing the request.
  #
  # 3. If a block is given, value and aux will be ignored, and instead the
  #    Stats object associated with each named unscoped metric will be
  #    yielded to the block for customized update logic.
  #
  # 4. If value is a Stats instance, it will be merged into the Stats
  #    associated with each named unscoped metric.
  #
  # If this method is called during a transaction, the metrics will be
  # attached to the Transaction, and not merged into the global set until
  # the end of the transaction.
  #
  # Otherwise, the metrics will be recorded directly into the global set
  # of metrics, under a lock.
  #
  # @api private
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats_engine.rb#63
  def tl_record_unscoped_metrics(metric_names, value = T.unsafe(nil), aux = T.unsafe(nil), &blk); end

  # For use by test code only.
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats_engine.rb#193
  def to_h; end

  # All access to the @stats_hash ivar should be funnelled through this
  # method to ensure thread-safety.
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats_engine.rb#23
  def with_stats_lock; end
end

# source://newrelic_rpm//lib/new_relic/agent/stats_engine/gc_profiler.rb#8
module NewRelic::Agent::StatsEngine::GCProfiler
  class << self
    # source://newrelic_rpm//lib/new_relic/agent/stats_engine/gc_profiler.rb#59
    def gc_metric_name; end

    # source://newrelic_rpm//lib/new_relic/agent/stats_engine/gc_profiler.rb#11
    def init; end

    # source://newrelic_rpm//lib/new_relic/agent/stats_engine/gc_profiler.rb#36
    def record_delta(start_snapshot, end_snapshot); end

    # THREAD_LOCAL_ACCESS
    #
    # source://newrelic_rpm//lib/new_relic/agent/stats_engine/gc_profiler.rb#47
    def record_gc_metric(call_count, elapsed); end

    # source://newrelic_rpm//lib/new_relic/agent/stats_engine/gc_profiler.rb#24
    def reset; end

    # source://newrelic_rpm//lib/new_relic/agent/stats_engine/gc_profiler.rb#29
    def take_snapshot; end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/stats_engine/gc_profiler.rb#85
class NewRelic::Agent::StatsEngine::GCProfiler::CoreGCProfiler
  # source://newrelic_rpm//lib/new_relic/agent/stats_engine/gc_profiler.rb#94
  def call_count; end

  # source://newrelic_rpm//lib/new_relic/agent/stats_engine/gc_profiler.rb#90
  def call_time_s; end

  # When using GC::Profiler, it's important to periodically call
  # GC::Profiler.clear in order to avoid unbounded growth in the number
  # of GC records that are stored. However, we actually do this
  # internally within MonotonicGCProfiler on calls to #total_time_s,
  # so the reset here is a no-op.
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats_engine/gc_profiler.rb#103
  def reset; end

  class << self
    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/stats_engine/gc_profiler.rb#86
    def enabled?; end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/stats_engine/gc_profiler.rb#9
class NewRelic::Agent::StatsEngine::GCProfiler::GCSnapshot < ::Struct
  # Returns the value of attribute gc_call_count
  #
  # @return [Object] the current value of gc_call_count
  def gc_call_count; end

  # Sets the attribute gc_call_count
  #
  # @param value [Object] the value to set the attribute gc_call_count to.
  # @return [Object] the newly set value
  def gc_call_count=(_); end

  # Returns the value of attribute gc_time_s
  #
  # @return [Object] the current value of gc_time_s
  def gc_time_s; end

  # Sets the attribute gc_time_s
  #
  # @param value [Object] the value to set the attribute gc_time_s to.
  # @return [Object] the newly set value
  def gc_time_s=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/stats_engine/gc_profiler.rb#56
NewRelic::Agent::StatsEngine::GCProfiler::GC_OTHER = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/stats_engine/gc_profiler.rb#55
NewRelic::Agent::StatsEngine::GCProfiler::GC_ROLLUP = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/stats_engine/gc_profiler.rb#57
NewRelic::Agent::StatsEngine::GCProfiler::GC_WEB = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/stats_engine/gc_profiler.rb#67
class NewRelic::Agent::StatsEngine::GCProfiler::RailsBenchProfiler
  # source://newrelic_rpm//lib/new_relic/agent/stats_engine/gc_profiler.rb#76
  def call_count; end

  # source://newrelic_rpm//lib/new_relic/agent/stats_engine/gc_profiler.rb#72
  def call_time_s; end

  # source://newrelic_rpm//lib/new_relic/agent/stats_engine/gc_profiler.rb#80
  def reset; end

  class << self
    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/stats_engine/gc_profiler.rb#68
    def enabled?; end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/stats_engine/stats_hash.rb#32
class NewRelic::Agent::StatsHash
  # @return [StatsHash] a new instance of StatsHash
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats_engine/stats_hash.rb#35
  def initialize(started_at = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/stats_engine/stats_hash.rb#53
  def ==(other); end

  # source://newrelic_rpm//lib/new_relic/agent/stats_engine/stats_hash.rb#64
  def [](key); end

  # source://newrelic_rpm//lib/new_relic/agent/stats_engine/stats_hash.rb#77
  def each; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats_engine/stats_hash.rb#87
  def empty?; end

  # source://newrelic_rpm//lib/new_relic/agent/stats_engine/stats_hash.rb#121
  def handle_stats_lookup_error(key, hash, error); end

  # Returns the value of attribute harvested_at.
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats_engine/stats_hash.rb#33
  def harvested_at; end

  # Sets the attribute harvested_at
  #
  # @param value the value to set the attribute harvested_at to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats_engine/stats_hash.rb#33
  def harvested_at=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/agent/stats_engine/stats_hash.rb#41
  def marshal_dump; end

  # source://newrelic_rpm//lib/new_relic/agent/stats_engine/stats_hash.rb#45
  def marshal_load(data); end

  # source://newrelic_rpm//lib/new_relic/agent/stats_engine/stats_hash.rb#135
  def merge!(other); end

  # source://newrelic_rpm//lib/new_relic/agent/stats_engine/stats_hash.rb#159
  def merge_or_insert(target, name, stats); end

  # source://newrelic_rpm//lib/new_relic/agent/stats_engine/stats_hash.rb#148
  def merge_transaction_metrics!(txn_metrics, scope); end

  # source://newrelic_rpm//lib/new_relic/agent/stats_engine/stats_hash.rb#101
  def record(metric_specs, value = T.unsafe(nil), aux = T.unsafe(nil), &blk); end

  # source://newrelic_rpm//lib/new_relic/agent/stats_engine/stats_hash.rb#91
  def size; end

  # Returns the value of attribute started_at.
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats_engine/stats_hash.rb#33
  def started_at; end

  # Sets the attribute started_at
  #
  # @param value the value to set the attribute started_at to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats_engine/stats_hash.rb#33
  def started_at=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/agent/stats_engine/stats_hash.rb#57
  def to_h; end
end

# source://newrelic_rpm//lib/new_relic/agent/stats_engine/stats_hash.rb#95
class NewRelic::Agent::StatsHash::StatsHashLookupError < ::NewRelic::Agent::InternalAgentError
  # @return [StatsHashLookupError] a new instance of StatsHashLookupError
  #
  # source://newrelic_rpm//lib/new_relic/agent/stats_engine/stats_hash.rb#96
  def initialize(original_error, hash, metric_spec); end
end

# source://newrelic_rpm//lib/new_relic/agent/synthetics_event_aggregator.rb#11
class NewRelic::Agent::SyntheticsEventAggregator < ::NewRelic::Agent::EventAggregator
  # source://newrelic_rpm//lib/new_relic/agent/synthetics_event_aggregator.rb#19
  def record(event); end

  private

  # source://newrelic_rpm//lib/new_relic/agent/synthetics_event_aggregator.rb#29
  def after_harvest(metadata); end

  # source://newrelic_rpm//lib/new_relic/agent/synthetics_event_aggregator.rb#33
  def record_dropped_synthetics(metadata); end
end

# source://newrelic_rpm//lib/new_relic/agent/synthetics_event_aggregator.rb#12
NewRelic::Agent::SyntheticsEventAggregator::TIMESTAMP = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/monitors/synthetics_monitor.rb#7
class NewRelic::Agent::SyntheticsMonitor < ::NewRelic::Agent::InboundRequestMonitor
  # source://newrelic_rpm//lib/new_relic/agent/monitors/synthetics_monitor.rb#37
  def load_json(header, key); end

  # THREAD_LOCAL_ACCESS
  #
  # source://newrelic_rpm//lib/new_relic/agent/monitors/synthetics_monitor.rb#18
  def on_before_call(request); end

  # source://newrelic_rpm//lib/new_relic/agent/monitors/synthetics_monitor.rb#14
  def on_finished_configuring(events); end

  class << self
    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/monitors/synthetics_monitor.rb#45
    def is_supported_version?(incoming_payload); end

    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/monitors/synthetics_monitor.rb#49
    def is_trusted?(incoming_payload); end

    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/monitors/synthetics_monitor.rb#54
    def is_valid_payload?(incoming_payload); end

    # source://newrelic_rpm//lib/new_relic/agent/monitors/synthetics_monitor.rb#58
    def reject_messaging_synthetics_header(headers); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/monitors/synthetics_monitor.rb#12
NewRelic::Agent::SyntheticsMonitor::EXPECTED_PAYLOAD_LENGTH = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/agent/monitors/synthetics_monitor.rb#11
NewRelic::Agent::SyntheticsMonitor::SUPPORTED_VERSION = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/agent/monitors/synthetics_monitor.rb#8
NewRelic::Agent::SyntheticsMonitor::SYNTHETICS_HEADER_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/monitors/synthetics_monitor.rb#9
NewRelic::Agent::SyntheticsMonitor::SYNTHETICS_INFO_HEADER_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/system_info.rb#15
module NewRelic::Agent::SystemInfo
  class << self
    # source://newrelic_rpm//lib/new_relic/agent/system_info.rb#310
    def boot_id; end

    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/system_info.rb#30
    def bsd?; end

    # source://newrelic_rpm//lib/new_relic/agent/system_info.rb#40
    def clear_processor_info; end

    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/system_info.rb#22
    def darwin?; end

    # When operating within a Docker container, attempt to obtain the
    # container id.
    #
    # First look for `/proc/self/mountinfo` to exist on disk to signify
    # cgroups v2. If that file exists, read it and expect it to contain one
    # or more "/docker/containers/<container_id>/" lines from which the
    # container id can be gleaned.
    #
    # Next look for `/proc/self/cgroup` to exist on disk to signify cgroup v1.
    # If that file exists, read it and parse the "cpu" group info in the hope
    # of finding a 64 character container id value.
    #
    # For non-cgroups based containers, use a `nil` value for the container
    # id without generating any warnings or errors.
    #
    # source://newrelic_rpm//lib/new_relic/agent/system_info.rb#191
    def docker_container_id; end

    # source://newrelic_rpm//lib/new_relic/agent/system_info.rb#203
    def docker_container_id_for_cgroupsv2; end

    # source://newrelic_rpm//lib/new_relic/agent/system_info.rb#36
    def ip_addresses; end

    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/system_info.rb#26
    def linux?; end

    # source://newrelic_rpm//lib/new_relic/agent/system_info.rb#167
    def num_logical_processors; end

    # source://newrelic_rpm//lib/new_relic/agent/system_info.rb#165
    def num_physical_cores; end

    # source://newrelic_rpm//lib/new_relic/agent/system_info.rb#163
    def num_physical_packages; end

    # source://newrelic_rpm//lib/new_relic/agent/system_info.rb#173
    def os_version; end

    # source://newrelic_rpm//lib/new_relic/agent/system_info.rb#247
    def parse_cgroup_ids(cgroup_info); end

    # source://newrelic_rpm//lib/new_relic/agent/system_info.rb#109
    def parse_cpuinfo(cpuinfo); end

    # source://newrelic_rpm//lib/new_relic/agent/system_info.rb#210
    def parse_docker_container_id(cgroup_info); end

    # source://newrelic_rpm//lib/new_relic/agent/system_info.rb#301
    def parse_linux_meminfo_in_mib(meminfo); end

    # A File.read against /(proc|sysfs)/* can hang with some older Linuxes.
    # See https://bugzilla.redhat.com/show_bug.cgi?id=604887, RUBY-736, and
    # https://github.com/opscode/ohai/commit/518d56a6cb7d021b47ed3d691ecf7fba7f74a6a7
    # for details on why we do it this way.
    #
    # source://newrelic_rpm//lib/new_relic/agent/system_info.rb#268
    def proc_try_read(path); end

    # source://newrelic_rpm//lib/new_relic/agent/system_info.rb#169
    def processor_arch; end

    # source://newrelic_rpm//lib/new_relic/agent/system_info.rb#44
    def processor_info; end

    # source://newrelic_rpm//lib/new_relic/agent/system_info.rb#86
    def processor_info_bsd; end

    # source://newrelic_rpm//lib/new_relic/agent/system_info.rb#63
    def processor_info_darwin; end

    # source://newrelic_rpm//lib/new_relic/agent/system_info.rb#81
    def processor_info_linux; end

    # source://newrelic_rpm//lib/new_relic/agent/system_info.rb#287
    def ram_in_mib; end

    # source://newrelic_rpm//lib/new_relic/agent/system_info.rb#94
    def remove_bad_values; end

    # source://newrelic_rpm//lib/new_relic/agent/system_info.rb#18
    def ruby_os_identifier; end

    # source://newrelic_rpm//lib/new_relic/agent/system_info.rb#104
    def sysctl_value(name); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/system_info.rb#16
NewRelic::Agent::SystemInfo::DOCKER_CGROUPS_V2_PATTERN = T.let(T.unsafe(nil), Regexp)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent.rb#809
NewRelic::Agent::TRACE_ID_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#7
module NewRelic::Agent::Threading; end

# source://newrelic_rpm//lib/new_relic/agent/threading/agent_thread.rb#8
class NewRelic::Agent::Threading::AgentThread
  class << self
    # source://newrelic_rpm//lib/new_relic/agent/threading/agent_thread.rb#72
    def backing_thread_class; end

    # source://newrelic_rpm//lib/new_relic/agent/threading/agent_thread.rb#76
    def backing_thread_class=(clazz); end

    # THREAD_LOCAL_ACCESS
    #
    # source://newrelic_rpm//lib/new_relic/agent/threading/agent_thread.rb#39
    def bucket_thread(thread, profile_agent_code); end

    # source://newrelic_rpm//lib/new_relic/agent/threading/agent_thread.rb#9
    def create(label, &blk); end

    # Simplifies testing if we don't directly use ::Thread.list, so keep
    # the accessor for it here on AgentThread to use and stub.
    #
    # source://newrelic_rpm//lib/new_relic/agent/threading/agent_thread.rb#35
    def list; end

    # source://newrelic_rpm//lib/new_relic/agent/threading/agent_thread.rb#56
    def scrub_backtrace(thread, profile_agent_code); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_node.rb#11
class NewRelic::Agent::Threading::BacktraceBase
  # @return [BacktraceBase] a new instance of BacktraceBase
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_node.rb#14
  def initialize; end

  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_node.rb#24
  def add_child(child); end

  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_node.rb#19
  def add_child_unless_present(child); end

  # Returns the value of attribute children.
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_node.rb#12
  def children; end

  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_node.rb#29
  def find_child(raw_line); end
end

# source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_node.rb#80
class NewRelic::Agent::Threading::BacktraceNode < ::NewRelic::Agent::Threading::BacktraceBase
  include ::NewRelic::Coerce

  # @return [BacktraceNode] a new instance of BacktraceNode
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_node.rb#84
  def initialize(line); end

  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_node.rb#91
  def ==(other); end

  # Returns the value of attribute as_array.
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_node.rb#81
  def as_array; end

  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_node.rb#105
  def complete_array_conversion; end

  # Returns the value of attribute depth.
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_node.rb#82
  def depth; end

  # Sets the attribute depth
  #
  # @param value the value to set the attribute depth to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_node.rb#82
  def depth=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_node.rb#116
  def dump_string(indent = T.unsafe(nil)); end

  # Returns the value of attribute file.
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_node.rb#81
  def file; end

  # Returns the value of attribute line_no.
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_node.rb#81
  def line_no; end

  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_node.rb#99
  def mark_for_array_conversion; end

  # Returns the value of attribute method.
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_node.rb#81
  def method; end

  # Returns [filename, method, line number]
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_node.rb#127
  def parse_backtrace_frame(frame); end

  # Returns the value of attribute raw_line.
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_node.rb#81
  def raw_line; end

  # Returns the value of attribute runnable_count.
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_node.rb#82
  def runnable_count; end

  # Sets the attribute runnable_count
  #
  # @param value the value to set the attribute runnable_count to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_node.rb#82
  def runnable_count=(_arg0); end
end

# source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_node.rb#34
class NewRelic::Agent::Threading::BacktraceRoot < ::NewRelic::Agent::Threading::BacktraceBase
  # @return [BacktraceRoot] a new instance of BacktraceRoot
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_node.rb#37
  def initialize; end

  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_node.rb#42
  def ==(other); end

  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_node.rb#50
  def aggregate(backtrace); end

  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_node.rb#46
  def as_array; end

  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_node.rb#72
  def dump_string; end

  # Returns the value of attribute flattened.
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_node.rb#35
  def flattened; end
end

# source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#8
class NewRelic::Agent::Threading::BacktraceService
  # @return [BacktraceService] a new instance of BacktraceService
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#26
  def initialize(event_listener = T.unsafe(nil)); end

  # If our overhead % exceeds the threshold, bump the next poll period
  # relative to how much larger our overhead is than allowed
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#249
  def adjust_polling_time(now, poll_start); end

  # This method is expected to be called with @lock held.
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#130
  def aggregate_backtraces(backtraces, name, start, duration, bucket, thread); end

  # This method is expected to be called with @lock held.
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#221
  def aggregate_global_backtrace(backtrace, bucket, thread); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#202
  def allowed_bucket?(bucket); end

  # Returns the value of attribute buffer.
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#22
  def buffer; end

  # This method is expected to be called with @lock held.
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#209
  def buffer_backtrace_for_thread(thread, timestamp, backtrace, bucket); end

  # Returns the value of attribute effective_polling_period.
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#22
  def effective_polling_period; end

  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#159
  def effective_polling_period=(new_period); end

  # This method is expected to be called with @lock held.
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#238
  def find_effective_polling_period; end

  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#102
  def harvest(transaction_name); end

  # This method is expected to be called with @lock held.
  #
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#189
  def need_backtrace?(bucket); end

  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#113
  def on_transaction_finished(payload); end

  # Returns the value of attribute overhead_percent_threshold.
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#22
  def overhead_percent_threshold; end

  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#164
  def poll; end

  # Returns the value of attribute profile_agent_code.
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#24
  def profile_agent_code; end

  # Sets the attribute profile_agent_code
  #
  # @param value the value to set the attribute profile_agent_code to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#24
  def profile_agent_code=(_arg0); end

  # This method is expected to be called with @lock held.
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#181
  def profiles; end

  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#266
  def record_polling_time(now, poll_start); end

  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#270
  def record_skew(poll_start); end

  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#261
  def record_supportability_metrics(now, poll_start); end

  # Public interface
  #
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#49
  def running?; end

  # This method is expected to be called with @lock held.
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#226
  def sample_thread(thread); end

  # This method is expected to be called with @lock held.
  #
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#184
  def should_buffer?(bucket); end

  # This method is expected to be called with @lock held.
  #
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#243
  def should_profile_agent_code?; end

  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#139
  def start; end

  # This method is expected to be called with @lock held
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#150
  def stop; end

  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#53
  def subscribe(transaction_name, command_arguments = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#96
  def subscribed?(transaction_name); end

  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#77
  def unsubscribe(transaction_name); end

  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#91
  def update_values_from_profiles; end

  # This method is expected to be called with @lock held
  #
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#197
  def watching_for_transaction?; end

  # Returns the value of attribute worker_loop.
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#22
  def worker_loop; end

  # Returns the value of attribute worker_thread.
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#24
  def worker_thread; end

  # Sets the attribute worker_thread
  #
  # @param value the value to set the attribute worker_thread to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#24
  def worker_thread=(_arg0); end

  class << self
    # Because of Resque's forking, we don't poll thread backtraces for it.
    # To accomplish that would require starting a new backtracing thread in
    # each forked worker, and merging profiles across the pipe channel.
    #
    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#18
    def is_resque?; end

    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#11
    def is_supported?; end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#9
NewRelic::Agent::Threading::BacktraceService::ALL_TRANSACTIONS = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_service.rb#206
NewRelic::Agent::Threading::BacktraceService::MAX_BUFFER_LENGTH = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_node.rb#8
NewRelic::Agent::Threading::MAX_THREAD_PROFILE_DEPTH = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/agent/threading/thread_profile.rb#14
class NewRelic::Agent::Threading::ThreadProfile
  include ::NewRelic::Coerce

  # @return [ThreadProfile] a new instance of ThreadProfile
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/thread_profile.rb#20
  def initialize(command_arguments = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/threading/thread_profile.rb#61
  def aggregate(backtrace, bucket, thread); end

  # Returns the value of attribute backtrace_count.
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/thread_profile.rb#15
  def backtrace_count; end

  # Returns the value of attribute command_arguments.
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/thread_profile.rb#15
  def command_arguments; end

  # THREAD_LOCAL_ACCESS
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/thread_profile.rb#71
  def convert_N_trace_nodes_to_arrays(count_to_keep); end

  # Returns the value of attribute created_at.
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/thread_profile.rb#15
  def created_at; end

  # Returns the value of attribute duration.
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/thread_profile.rb#15
  def duration; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/thread_profile.rb#51
  def empty?; end

  # Returns the value of attribute failure_count.
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/thread_profile.rb#15
  def failure_count; end

  # Returns the value of attribute finished_at.
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/thread_profile.rb#18
  def finished_at; end

  # Sets the attribute finished_at
  #
  # @param value the value to set the attribute finished_at to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/thread_profile.rb#18
  def finished_at=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/agent/threading/thread_profile.rb#102
  def generate_traces; end

  # source://newrelic_rpm//lib/new_relic/agent/threading/thread_profile.rb#47
  def increment_poll_count; end

  # Returns the value of attribute poll_count.
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/thread_profile.rb#15
  def poll_count; end

  # Returns the value of attribute profile_agent_code.
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/thread_profile.rb#15
  def profile_agent_code; end

  # Returns the value of attribute profile_id.
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/thread_profile.rb#15
  def profile_id; end

  # source://newrelic_rpm//lib/new_relic/agent/threading/thread_profile.rb#43
  def requested_period; end

  # Returns the value of attribute sample_period.
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/thread_profile.rb#15
  def sample_period; end

  # source://newrelic_rpm//lib/new_relic/agent/threading/thread_profile.rb#113
  def to_collector_array(encoder); end

  # source://newrelic_rpm//lib/new_relic/agent/threading/thread_profile.rb#127
  def to_log_description; end

  # Returns the value of attribute traces.
  #
  # source://newrelic_rpm//lib/new_relic/agent/threading/thread_profile.rb#15
  def traces; end

  # source://newrelic_rpm//lib/new_relic/agent/threading/thread_profile.rb#55
  def unique_thread_count; end
end

# source://newrelic_rpm//lib/new_relic/agent/threading/thread_profile.rb#98
NewRelic::Agent::Threading::ThreadProfile::THREAD_PROFILER_NODES = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/agent/threading/backtrace_node.rb#9
NewRelic::Agent::Threading::UNKNOWN_LINE_NUMBER = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/agent/timestamp_sampled_buffer.rb#9
class NewRelic::Agent::TimestampSampledBuffer < ::NewRelic::Agent::PrioritySampledBuffer
  private

  # source://newrelic_rpm//lib/new_relic/agent/timestamp_sampled_buffer.rb#14
  def priority_for(event); end
end

# source://newrelic_rpm//lib/new_relic/agent/timestamp_sampled_buffer.rb#10
NewRelic::Agent::TimestampSampledBuffer::TIMESTAMP_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context_payload.rb#9
class NewRelic::Agent::TraceContextPayload
  extend ::NewRelic::Coerce

  # @return [TraceContextPayload] a new instance of TraceContextPayload
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context_payload.rb#86
  def initialize(version, parent_type_id, parent_account_id, parent_app_id, id, transaction_id, sampled, priority, timestamp); end

  # Returns the value of attribute id.
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context_payload.rb#74
  def id; end

  # Sets the attribute id
  #
  # @param value the value to set the attribute id to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context_payload.rb#74
  def id=(_arg0); end

  # Returns the value of attribute parent_account_id.
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context_payload.rb#74
  def parent_account_id; end

  # Sets the attribute parent_account_id
  #
  # @param value the value to set the attribute parent_account_id to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context_payload.rb#74
  def parent_account_id=(_arg0); end

  # Returns the value of attribute parent_app_id.
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context_payload.rb#74
  def parent_app_id; end

  # Sets the attribute parent_app_id
  #
  # @param value the value to set the attribute parent_app_id to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context_payload.rb#74
  def parent_app_id=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context_payload.rb#99
  def parent_type; end

  # Returns the value of attribute parent_type_id.
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context_payload.rb#74
  def parent_type_id; end

  # Sets the attribute parent_type_id
  #
  # @param value the value to set the attribute parent_type_id to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context_payload.rb#74
  def parent_type_id=(_arg0); end

  # Returns the value of attribute priority.
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context_payload.rb#74
  def priority; end

  # Sets the attribute priority
  #
  # @param value the value to set the attribute priority to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context_payload.rb#74
  def priority=(_arg0); end

  # Returns the value of attribute sampled.
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context_payload.rb#74
  def sampled; end

  # Sets the attribute sampled
  #
  # @param value the value to set the attribute sampled to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context_payload.rb#74
  def sampled=(_arg0); end

  # Returns the value of attribute sampled.
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context_payload.rb#74
  def sampled?; end

  # Returns the value of attribute timestamp.
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context_payload.rb#74
  def timestamp; end

  # Sets the attribute timestamp
  #
  # @param value the value to set the attribute timestamp to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context_payload.rb#74
  def timestamp=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context_payload.rb#113
  def to_s; end

  # Returns the value of attribute transaction_id.
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context_payload.rb#74
  def transaction_id; end

  # Sets the attribute transaction_id
  #
  # @param value the value to set the attribute transaction_id to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context_payload.rb#74
  def transaction_id=(_arg0); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context_payload.rb#103
  def valid?; end

  # Returns the value of attribute version.
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context_payload.rb#74
  def version; end

  # Sets the attribute version
  #
  # @param value the value to set the attribute version to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context_payload.rb#74
  def version=(_arg0); end

  class << self
    # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context_payload.rb#21
    def create(version: T.unsafe(nil), parent_type: T.unsafe(nil), parent_account_id: T.unsafe(nil), parent_app_id: T.unsafe(nil), id: T.unsafe(nil), transaction_id: T.unsafe(nil), sampled: T.unsafe(nil), priority: T.unsafe(nil), timestamp: T.unsafe(nil)); end

    # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context_payload.rb#37
    def from_s(payload_string); end

    private

    # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context_payload.rb#64
    def handle_invalid_payload(error: T.unsafe(nil), message: T.unsafe(nil)); end

    # source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context_payload.rb#60
    def now_ms; end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context_payload.rb#12
NewRelic::Agent::TraceContextPayload::DELIMITER = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context_payload.rb#16
NewRelic::Agent::TraceContextPayload::FALSE_CHAR = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context_payload.rb#11
NewRelic::Agent::TraceContextPayload::PARENT_TYPE = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context_payload.rb#18
NewRelic::Agent::TraceContextPayload::PARENT_TYPES = T.let(T.unsafe(nil), Array)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context_payload.rb#13
NewRelic::Agent::TraceContextPayload::SUPPORTABILITY_PARSE_EXCEPTION = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context_payload.rb#15
NewRelic::Agent::TraceContextPayload::TRUE_CHAR = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/distributed_tracing/trace_context_payload.rb#10
NewRelic::Agent::TraceContextPayload::VERSION = T.let(T.unsafe(nil), Integer)

# This class helps you interact with the current transaction (if
# it exists), start new transactions/segments, etc.
#
# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/tracer.rb#19
class NewRelic::Agent::Tracer
  class << self
    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#196
    def accept_distributed_trace_payload(payload); end

    # Will potentially capture and notice an error at the
    # segment that was executing when error occurred.
    # if passed +segment+ is something that doesn't
    # respond to +notice_segment_error+ then this method
    # is effectively just a yield to the given &block
    #
    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#354
    def capture_segment_error(segment); end

    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#407
    def clear_state; end

    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#190
    def create_distributed_trace_payload; end

    # Returns the currently active segment in the transaction in
    # progress for this thread, or +nil+ if no segment or
    # transaction exists.
    #
    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#207
    def current_segment; end

    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#413
    def current_segment_key; end

    # Returns the id of the current span, or +nil+ if none exists.
    #
    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#57
    def current_span_id; end

    # Returns the trace_id of the current_transaction, or +nil+ if
    # none exists.
    #
    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#47
    def current_trace_id; end

    # Returns the transaction in progress for this thread, or
    # +nil+ if none exists.
    #
    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#39
    def current_transaction; end

    # Runs the given block of code in a transaction.
    #
    # @api public
    # @param name [String] reserved for New Relic internal use
    # @param partial_name [String] a meaningful name for this
    #   transaction (e.g., +blogs/index+); the Ruby agent will add a
    #   New-Relic-specific prefix
    # @param category [Symbol] +:web+ for web transactions or
    #   +:background+ for background transactions
    # @param options [Hash] reserved for New Relic internal use
    #
    # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#90
    def in_transaction(category:, name: T.unsafe(nil), partial_name: T.unsafe(nil), options: T.unsafe(nil)); end

    # Returns a boolean indicating whether the current_transaction
    # is sampled, or +nil+ if there is no current transaction.
    #
    # @api public
    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#68
    def sampled?; end

    # Returns the id of the current span, or +nil+ if none exists.
    #
    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#57
    def span_id; end

    # Creates and starts a datastore segment used to time
    # datastore operations.
    #
    # @api public
    # @param product [String] the datastore name for use in metric
    #   naming, e.g. "FauxDB"
    # @param operation [String] the name of the operation
    #   (e.g. "select"), often named after the method that's being
    #   instrumented.
    # @param collection [optional, String] the collection name for use in
    #   statement-level metrics (i.e. table or model name)
    # @param host [optional, String] the host this database
    #   instance is running on
    # @param database_name [optional, String] the name of this
    #   database
    # @param start_time [optional, Time] a +Time+ instance
    #   denoting the start time of the segment. Value is set by
    #   AbstractSegment#start if not given.
    # @param parent [optional, Segment] Use for the rare cases
    #   (such as async) where the parent segment should be something
    #   other than the current segment
    # @param port_path_or_id [optional, String] TCP port, file
    #   path, UNIX domain socket, or other connection-related info
    # @return [DatastoreSegment] the newly created segment; you
    #   _must_ call +finish+ on it at the end of the code you're
    #   tracing
    #
    # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#288
    def start_datastore_segment(product: T.unsafe(nil), operation: T.unsafe(nil), collection: T.unsafe(nil), host: T.unsafe(nil), port_path_or_id: T.unsafe(nil), database_name: T.unsafe(nil), start_time: T.unsafe(nil), parent: T.unsafe(nil)); end

    # Creates and starts an external request segment using the
    # given library, URI, and procedure. This is used to time
    # external calls made over HTTP.
    #
    # @api public
    # @param library [String] a string of the class name of the library used to
    #   make the external call, for example, 'Net::HTTP'.
    # @param uri [String, URI] indicates the URI to which the
    #   external request is being made. The URI should begin with the protocol,
    #   for example, 'https://github.com'.
    # @param procedure [String] the HTTP method being used for the external
    #   request as a string, for example, 'GET'.
    # @param start_time [optional, Time] a +Time+ instance
    #   denoting the start time of the segment. Value is set by
    #   AbstractSegment#start if not given.
    # @param parent [optional, Segment] Use for the rare cases
    #   (such as async) where the parent segment should be something
    #   other than the current segment
    # @return [ExternalRequestSegment] the newly created segment;
    #   you _must_ call +finish+ on it at the end of the code
    #   you're tracing
    #
    # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#335
    def start_external_request_segment(library:, uri:, procedure:, start_time: T.unsafe(nil), parent: T.unsafe(nil)); end

    # For New Relic internal use only.
    #
    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#365
    def start_message_broker_segment(action:, library:, destination_type:, destination_name:, headers: T.unsafe(nil), parameters: T.unsafe(nil), start_time: T.unsafe(nil), parent: T.unsafe(nil)); end

    # Creates and starts a general-purpose segment used to time
    # arbitrary code.
    #
    # @api public
    # @param name [String] full name of the segment; the agent
    #   will not add a prefix. Third-party users should begin the
    #   name with +Custom/+; e.g.,
    #   +Custom/UserMailer/send_welcome_email+
    # @param unscoped_metrics [optional, String, Array] additional
    #   unscoped metrics to record using this segment's timing
    #   information
    # @param start_time [optional, Time] a +Time+ instance
    #   denoting the start time of the segment. Value is set by
    #   AbstractSegment#start if not given.
    # @param parent [optional, Segment] Use for the rare cases
    #   (such as async) where the parent segment should be something
    #   other than the current segment
    # @return [Segment] the newly created segment; you _must_ call
    #   +finish+ on it at the end of the code you're tracing
    #
    # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#237
    def start_segment(name:, unscoped_metrics: T.unsafe(nil), start_time: T.unsafe(nil), parent: T.unsafe(nil)); end

    # Takes name or partial_name and a category.
    # Returns a transaction instance or nil
    #
    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#163
    def start_transaction(category:, name: T.unsafe(nil), partial_name: T.unsafe(nil), **options); end

    # Starts a segment on the current transaction (if one exists)
    # or starts a new transaction otherwise.
    #
    # @api public
    # @param name [String] reserved for New Relic internal use
    # @param partial_name [String] a meaningful name for this
    #   transaction (e.g., +blogs/index+); the Ruby agent will add a
    #   New-Relic-specific prefix
    # @param category [Symbol] +:web+ for web transactions or
    #   +:task+ for background transactions
    # @param options [Hash] reserved for New Relic internal use
    # @return [Object, #finish] an object that responds to
    #   +finish+; you _must_ call +finish+ on it at the end of the
    #   code you're tracing
    #
    # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#134
    def start_transaction_or_segment(category:, name: T.unsafe(nil), partial_name: T.unsafe(nil), options: T.unsafe(nil)); end

    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#21
    def state; end

    # This method should only be used by Tracer for access to the
    # current thread's state or to provide read-only accessors for other threads
    #
    # If ever exposed, this requires additional synchronization
    #
    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#394
    def state_for(thread); end

    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#421
    def thread_block_with_current_transaction(segment_name: T.unsafe(nil), parent: T.unsafe(nil), &block); end

    # @api public
    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#417
    def thread_tracing_enabled?; end

    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#407
    def tl_clear; end

    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#21
    def tl_get; end

    # This method should only be used by Tracer for access to the
    # current thread's state or to provide read-only accessors for other threads
    #
    # If ever exposed, this requires additional synchronization
    #
    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#394
    def tl_state_for(thread); end

    # Returns the trace_id of the current_transaction, or +nil+ if
    # none exists.
    #
    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#47
    def trace_id; end

    # Returns +true+ unless called from within an
    # +NewRelic::Agent.disable_all_tracing+ block.
    #
    # @api public
    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#31
    def tracing_enabled?; end

    # Returns a boolean indicating whether the current_transaction
    # is sampled, or +nil+ if there is no current transaction.
    #
    # @api public
    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#68
    def transaction_sampled?; end

    private

    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#456
    def log_error(method_name, exception); end

    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#444
    def start_and_add_segment(segment, parent = T.unsafe(nil)); end
  end
end

# This is THE location to store thread local information during a transaction
# Need a new piece of data? Add a method here, NOT a new thread local variable.
#
# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/tracer.rb#464
class NewRelic::Agent::Tracer::State
  # @api public
  # @return [State] a new instance of State
  #
  # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#465
  def initialize; end

  # Current transaction stack
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#482
  def current_transaction; end

  # Current transaction stack
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#482
  def current_transaction=(_arg0); end

  # @api public
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#496
  def is_execution_traced?; end

  # @api public
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#505
  def is_sql_recorded?; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#491
  def pop_traced; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#487
  def push_traced(should_trace); end

  # TT's and SQL
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#503
  def record_sql; end

  # TT's and SQL
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#503
  def record_sql=(_arg0); end

  # This starts the timer for the transaction.
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#472
  def reset(transaction = T.unsafe(nil)); end

  # Sql Sampler Transaction Data
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#510
  def sql_sampler_transaction_data; end

  # Sql Sampler Transaction Data
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#510
  def sql_sampler_transaction_data=(_arg0); end

  # @api public
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#496
  def tracing_enabled?; end

  # Execution tracing on current thread
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#485
  def untraced; end

  # Execution tracing on current thread
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/tracer.rb#485
  def untraced=(_arg0); end
end

# This class represents a single transaction (usually mapping to one
# web request or background job invocation) instrumented by the Ruby agent.
#
# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/transaction/request_attributes.rb#9
class NewRelic::Agent::Transaction
  include ::NewRelic::Agent::Transaction::Tracing

  # @api public
  # @return [Transaction] a new instance of Transaction
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#214
  def initialize(category, options); end

  # Call this to ensure that the current transaction trace is not saved
  # To fully ignore all metrics and errors, use ignore! instead.
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#497
  def abort_transaction!; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#183
  def add_agent_attribute(key, value, default_destinations); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#893
  def add_custom_attributes(p); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#897
  def add_log_event(event); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#828
  def apdex_bucket(duration, current_apdex_t); end

  # A Time instance used for calculating the apdex score, which
  # might end up being @start, or it might be further upstream if
  # we can find a request header for the queue entry time
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#63
  def apdex_start; end

  # A Time instance used for calculating the apdex score, which
  # might end up being @start, or it might be further upstream if
  # we can find a request header for the queue entry time
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#63
  def apdex_start=(_arg0); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#859
  def apdex_t; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#727
  def append_apdex_perf_zone(payload); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#744
  def append_synthetics_to(payload); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#586
  def assign_agent_attributes; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#611
  def assign_intrinsics; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#579
  def assign_segment_dt_attributes; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#74
  def attributes; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#509
  def background_summary_metrics; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#380
  def best_name; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#644
  def calculate_gc_time; end

  # This method returns transport_duration in seconds. Transport duration
  # is stored in milliseconds on the payload, but it's needed in seconds
  # for metrics and intrinsics.
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#652
  def calculate_transport_duration(distributed_trace_payload); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#74
  def category; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#557
  def commit!(outermost_node_name); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#913
  def cpu_burn; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#447
  def create_initial_segment(options = T.unsafe(nil)); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#473
  def create_nested_segment(category, options); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#452
  def create_segment(name, options = T.unsafe(nil)); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#274
  def current_segment; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#266
  def current_segment_key; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#347
  def default_name=(name); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#288
  def distributed_tracer; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#74
  def duration; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#74
  def end_time; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#65
  def exceptions; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#65
  def exceptions=(_arg0); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#65
  def filtered_params; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#65
  def filtered_params=(_arg0); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#522
  def finish; end

  # @api public
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#443
  def finished?; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#399
  def freeze_name_and_execute_if_not_ignored; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#74
  def gc_start_snapshot; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#673
  def generate_payload; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#74
  def guid; end

  # @api public
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#818
  def had_error_affecting_apdex?; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#65
  def http_response_code; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#65
  def http_response_code=(_arg0); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#929
  def ignore!; end

  # @api public
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#933
  def ignore?; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#937
  def ignore_apdex!; end

  # @api public
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#941
  def ignore_apdex?; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#945
  def ignore_enduser!; end

  # @api public
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#949
  def ignore_enduser?; end

  # @api public
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#953
  def ignore_trace?; end

  # @api public
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#690
  def include_guid?; end

  # @api public
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#376
  def influences_transaction_name?(category); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#439
  def initial_segment; end

  # This transaction-local hash may be used as temporary storage by
  # instrumentation that needs to pass data from one instrumentation point
  # to another.
  #
  # For example, if both A and B are instrumented, and A calls B
  # but some piece of state needed by the instrumentation at B is only
  # available at A, the instrumentation at A may write into the hash, call
  # through, and then remove the key afterwards, allowing the
  # instrumentation at B to read the value in between.
  #
  # Keys should be symbols, and care should be taken to not generate key
  # names dynamically, and to ensure that keys are removed upon return from
  # the method that creates them.
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#339
  def instrumentation_state; end

  # @api public
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#694
  def is_synthetics_request?; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#923
  def jruby_cpu_burn; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#65
  def jruby_cpu_start; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#65
  def jruby_cpu_start=(_arg0); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#371
  def log_frozen_name(name); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#74
  def logs; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#758
  def merge_metrics; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#351
  def merge_request_parameters(params); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#197
  def merge_untrusted_agent_attributes(attributes, prefix, default_destinations); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#74
  def metrics; end

  # @api public
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#418
  def name_frozen?; end

  # @api public
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#518
  def needs_middleware_summary_metrics?(name); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#490
  def nest_initial_segment; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#74
  def nesting_max_depth; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#917
  def normal_cpu_burn; end

  # Do not call this.  Invoke the class method instead.
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#781
  def notice_error(error, options = T.unsafe(nil)); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#343
  def overridden_name=(name); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#270
  def parent_segment_key; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#65
  def parent_span_id; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#65
  def parent_span_id=(_arg0); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#74
  def payload; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#309
  def priority; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#86
  def priority=(_arg0); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#65
  def process_cpu_start; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#65
  def process_cpu_start=(_arg0); end

  # End common interface
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#391
  def promoted_transaction_name(name); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#803
  def queue_time; end

  # Fields for tracking synthetics requests
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#93
  def raw_synthetics_header; end

  # Fields for tracking synthetics requests
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#93
  def raw_synthetics_header=(_arg0); end

  # Fields for tracking synthetics requests
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#93
  def raw_synthetics_info_header; end

  # Fields for tracking synthetics requests
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#93
  def raw_synthetics_info_header=(_arg0); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#832
  def record_apdex; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#846
  def record_apdex_metrics(rollup_metric, transaction_prefix, current_apdex_t); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#770
  def record_exception(exception, options, error_recorded); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#762
  def record_exceptions; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#799
  def record_log_events; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#807
  def record_queue_time; end

  # The summary metrics recorded by this method all end up with a duration
  # equal to the transaction itself, and an exclusive time of zero.
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#661
  def record_summary_metrics(outermost_node_name); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#795
  def record_transaction_event; end

  # @api public
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#901
  def recording_web_transaction?; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#313
  def referer; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#284
  def remove_current_segment_by_thread_id(id); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#317
  def request_path; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#321
  def request_port; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#65
  def response_content_length; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#65
  def response_content_length=(_arg0); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#65
  def response_content_type; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#65
  def response_content_type=(_arg0); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#86
  def sampled=(_arg0); end

  # @api public
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#292
  def sampled?; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#74
  def segments; end

  # This event is fired when the transaction is fully completed. The metric
  # values and sampler can't be successfully modified from this event.
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#669
  def send_transaction_finished_event; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#280
  def set_current_segment(new_segment); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#355
  def set_default_transaction_name(name, category); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#364
  def set_overriding_transaction_name(name, category); end

  # @api public
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#909
  def similar_category?(category); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#422
  def start(options = T.unsafe(nil)); end

  # A Time instance for the start time, never nil
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#58
  def start_time; end

  # A Time instance for the start time, never nil
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#58
  def start_time=(_arg0); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#262
  def state; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#501
  def summary_metrics; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#703
  def synthetics_account_id; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#637
  def synthetics_additional_attributes(&block); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#723
  def synthetics_info(key); end

  # Fields for tracking synthetics requests
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#93
  def synthetics_info_payload; end

  # Fields for tracking synthetics requests
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#93
  def synthetics_info_payload=(_arg0); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#713
  def synthetics_job_id; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#718
  def synthetics_monitor_id; end

  # Fields for tracking synthetics requests
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#93
  def synthetics_payload; end

  # Fields for tracking synthetics requests
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#93
  def synthetics_payload=(_arg0); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#708
  def synthetics_resource_id; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#698
  def synthetics_version; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#868
  def threshold; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#301
  def trace_id; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#305
  def trace_id=(value); end

  # For common interface with Trace
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#380
  def transaction_name; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#863
  def transaction_specific_apdex_t; end

  # Populated with the trace sample once this transaction is completed.
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#90
  def transaction_trace; end

  # @api public
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#548
  def user_defined_rules_ignore?; end

  # @api public
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#905
  def web_category?(category); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#877
  def with_database_metric_name(model, method, product = T.unsafe(nil)); end

  private

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#982
  def agent; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#966
  def jruby_cpu_time; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#959
  def process_cpu; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#990
  def sql_sampler; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#986
  def transaction_sampler; end

  class << self
    # discards the currently saved transaction information
    #
    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#135
    def abort_transaction!; end

    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#175
    def add_agent_attribute(key, value, default_destinations); end

    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#162
    def apdex_bucket(duration, failed, apdex_t); end

    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#189
    def merge_untrusted_agent_attributes(attributes, prefix, default_destinations); end

    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#114
    def name_from_partial(partial_name, category); end

    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#126
    def nested_transaction_name(name); end

    # See NewRelic::Agent.notice_error for options and commentary
    #
    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#142
    def notice_error(e, options = T.unsafe(nil)); end

    # Returns truthy if the current in-progress transaction is considered a
    # a web transaction (as opposed to, e.g., a background transaction).
    #
    # @api public
    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#155
    def recording_web_transaction?; end

    # THREAD_LOCAL_ACCESS
    #
    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#100
    def set_default_transaction_name(partial_name, category = T.unsafe(nil)); end

    # THREAD_LOCAL_ACCESS
    #
    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#106
    def set_overriding_transaction_name(partial_name, category = T.unsafe(nil)); end

    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#119
    def start_new_transaction(state, category, options); end

    # Return the currently active transaction, or nil.
    #
    # @api public
    #
    # source://newrelic_rpm//lib/new_relic/agent/transaction.rb#96
    def tl_current; end
  end
end

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/transaction.rb#37
NewRelic::Agent::Transaction::ACTION_CABLE_PREFIX = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/transaction.rb#49
NewRelic::Agent::Transaction::APDEX_ALL_METRIC = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/transaction.rb#48
NewRelic::Agent::Transaction::APDEX_F = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/transaction.rb#50
NewRelic::Agent::Transaction::APDEX_METRIC = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/transaction.rb#51
NewRelic::Agent::Transaction::APDEX_OTHER_METRIC = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/transaction.rb#53
NewRelic::Agent::Transaction::APDEX_OTHER_TXN_METRIC_PREFIX = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/transaction.rb#46
NewRelic::Agent::Transaction::APDEX_S = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/transaction.rb#47
NewRelic::Agent::Transaction::APDEX_T = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/transaction.rb#52
NewRelic::Agent::Transaction::APDEX_TXN_METRIC_PREFIX = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#10
class NewRelic::Agent::Transaction::AbstractSegment
  # @return [AbstractSegment] a new instance of AbstractSegment
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#30
  def initialize(name = T.unsafe(nil), start_time = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#128
  def all_code_information_present?; end

  # Returns the value of attribute children_time.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#23
  def children_time; end

  # Sets the attribute children_time
  #
  # @param value the value to set the attribute children_time to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#23
  def children_time=(_arg0); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#111
  def children_time_ranges?; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#132
  def code_attributes; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#119
  def code_information=(info = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#115
  def concurrent_children?; end

  # This class is the base class for all segments. It is responsible for
  # timing, naming, and defining lifecycle callbacks. One of the more
  # complex responsibilities of this class is computing exclusive duration.
  # One of the reasons for this complexity is that exclusive time will be
  # computed using time ranges or by recording an aggregate value for
  # a segments children time. The reason for this is that computing
  # exclusive duration using time ranges is expensive and it's only
  # necessary if a segment's children run concurrently, or a segment ends
  # after its parent. We will use the optimized exclusive duration
  # calculation in all other cases.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#22
  def duration; end

  # This class is the base class for all segments. It is responsible for
  # timing, naming, and defining lifecycle callbacks. One of the more
  # complex responsibilities of this class is computing exclusive duration.
  # One of the reasons for this complexity is that exclusive time will be
  # computed using time ranges or by recording an aggregate value for
  # a segments children time. The reason for this is that computing
  # exclusive duration using time ranges is expensive and it's only
  # necessary if a segment's children run concurrently, or a segment ends
  # after its parent. We will use the optimized exclusive duration
  # calculation in all other cases.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#22
  def end_time; end

  # This class is the base class for all segments. It is responsible for
  # timing, naming, and defining lifecycle callbacks. One of the more
  # complex responsibilities of this class is computing exclusive duration.
  # One of the reasons for this complexity is that exclusive time will be
  # computed using time ranges or by recording an aggregate value for
  # a segments children time. The reason for this is that computing
  # exclusive duration using time ranges is expensive and it's only
  # necessary if a segment's children run concurrently, or a segment ends
  # after its parent. We will use the optimized exclusive duration
  # calculation in all other cases.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#22
  def exclusive_duration; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#93
  def finalize; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#65
  def finish; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#77
  def finished?; end

  # This class is the base class for all segments. It is responsible for
  # timing, naming, and defining lifecycle callbacks. One of the more
  # complex responsibilities of this class is computing exclusive duration.
  # One of the reasons for this complexity is that exclusive time will be
  # computed using time ranges or by recording an aggregate value for
  # a segments children time. The reason for this is that computing
  # exclusive duration using time ranges is expensive and it's only
  # necessary if a segment's children run concurrently, or a segment ends
  # after its parent. We will use the optimized exclusive duration
  # calculation in all other cases.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#22
  def guid; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#143
  def inspect; end

  # Returns the value of attribute name.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#23
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#23
  def name=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#164
  def notice_error(exception, options = T.unsafe(nil)); end

  # Returns the value of attribute noticed_error.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#25
  def noticed_error; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#175
  def noticed_error_attributes; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#99
  def params; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#103
  def params?; end

  # Returns the value of attribute parent.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#23
  def parent; end

  # Sets the attribute parent
  #
  # @param value the value to set the attribute parent to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#23
  def parent=(_arg0); end

  # Sets the attribute record_metrics
  #
  # @param value the value to set the attribute record_metrics to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#24
  def record_metrics=(_arg0); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#81
  def record_metrics?; end

  # Sets the attribute record_on_finish
  #
  # @param value the value to set the attribute record_on_finish to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#24
  def record_on_finish=(_arg0); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#89
  def record_on_finish?; end

  # Sets the attribute record_scoped_metric
  #
  # @param value the value to set the attribute record_scoped_metric to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#24
  def record_scoped_metric=(_arg0); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#85
  def record_scoped_metric?; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#154
  def set_noticed_error(noticed_error); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#58
  def start; end

  # This class is the base class for all segments. It is responsible for
  # timing, naming, and defining lifecycle callbacks. One of the more
  # complex responsibilities of this class is computing exclusive duration.
  # One of the reasons for this complexity is that exclusive time will be
  # computed using time ranges or by recording an aggregate value for
  # a segments children time. The reason for this is that computing
  # exclusive duration using time ranges is expensive and it's only
  # necessary if a segment's children run concurrently, or a segment ends
  # after its parent. We will use the optimized exclusive duration
  # calculation in all other cases.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#22
  def start_time; end

  # This class is the base class for all segments. It is responsible for
  # timing, naming, and defining lifecycle callbacks. One of the more
  # complex responsibilities of this class is computing exclusive duration.
  # One of the reasons for this complexity is that exclusive time will be
  # computed using time ranges or by recording an aggregate value for
  # a segments children time. The reason for this is that computing
  # exclusive duration using time ranges is expensive and it's only
  # necessary if a segment's children run concurrently, or a segment ends
  # after its parent. We will use the optimized exclusive duration
  # calculation in all other cases.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#22
  def starting_segment_key; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#107
  def time_range; end

  # Returns the value of attribute transaction.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#23
  def transaction; end

  # Sets the attribute transaction
  #
  # @param value the value to set the attribute transaction to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#23
  def transaction=(_arg0); end

  # callback for subclasses to override
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#151
  def transaction_assigned; end

  # Returns the value of attribute transaction_name.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#23
  def transaction_name; end

  # Sets the attribute transaction_name
  #
  # @param value the value to set the attribute transaction_name to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#23
  def transaction_name=(_arg0); end

  protected

  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#196
  def child_complete(segment); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#189
  def child_start(segment); end

  # When a child segment completes after its parent, we need to propagate
  # the information about the descendant further up the tree so that
  # ancestors can properly account for exclusive time. Once we've reached
  # an ancestor whose end time is greater than or equal to the descendant's
  # we can stop the propagation. We pass along the direct child so we can
  # make any corrections needed for exclusive time calculation.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#212
  def descendant_complete(child, descendant); end

  # Sets the attribute range_recorded
  #
  # @param value the value to set the attribute range_recorded to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#183
  def range_recorded=(_arg0); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#185
  def range_recorded?; end

  private

  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#230
  def add_child_timing(segment); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#234
  def force_finish; end

  # for segment callback usage info, see self.set_segment_callback
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#336
  def invoke_callback; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#278
  def metric_cache; end

  # Child segments operating concurrently with this segment may have
  # start and end times that overlap with this segment's own times. The
  # amount of overlap needs to be removed from the `children_time` total
  # when calculating an `@exclusive_duration` value to be added to the
  # transaction's total time.
  #
  # If there aren't any child segments, return 0.0. Otherwise, take the
  # `@children_timings` array of arrays (each array holds a child
  # segment's start time and end time), sort it by the first elements
  # (start times), and use the start and finish times to create Range
  # objects. Combine all of the child segment ranges that overlap with
  # one another into new bigger ranges. Then take those bigger ranges
  # and calculate how much overlap there is between them and this
  # segment's own time range. Keep a running sum of all of the overlap
  # amounts and then return it.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#307
  def overlapping_duration; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#286
  def range_overlap(range); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#282
  def ranges_intersect?(r1, r2); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#255
  def record_child_time(child); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#268
  def record_child_time_as_number(child); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#263
  def record_child_time_as_range(child); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#272
  def record_exclusive_duration; end

  # @raise [NotImplementedError]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#247
  def record_metrics; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#241
  def run_complete_callbacks; end

  # callback for subclasses to override
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#252
  def segment_complete; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#327
  def transaction_state; end

  class << self
    # Setting and invoking a segment callback
    # =======================================
    # Each individual segment class such as `ExternalRequestSegment` allows
    # for exactly one instance of a `Proc` (meaning a proc or lambda) to be
    # set as a callback. A callback can be set on a segment class by calling
    # `.set_segment_callback` with a proc or lambda as the only argument.
    # If set, the callback will be invoked with `#call` at segment class
    # initialization time.
    #
    # Example usage:
    #   callback = -> { puts 'Hello, World! }
    #   ExternalRequestSegment.set_segment_callback(callback)
    #   ExternalRequestSegment.new(library, uri, procedure)
    #
    # A callback set on a segment class will only be called when that
    # specific segment class is initialized. Other segment classes will not
    # be impacted.
    #
    # Great caution should be taken in the defining of the callback block
    # to not have the block perform anything too time consuming or resource
    # intensive in order to keep the New Relic Ruby agent operating
    # normally.
    #
    # Given that callbacks are user defined, they must be set entirely at
    # the user's own risk. It is recommended that each callback use
    # conditional logic that only performs work for certain qualified
    # segments. It is recommended that each callback be thoroughly tested
    # in non-production environments before being introduced to production
    # environments.
    #
    # source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#375
    def set_segment_callback(callback_proc); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#27
NewRelic::Agent::Transaction::AbstractSegment::CALLBACK = T.let(T.unsafe(nil), Symbol)

# source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#141
NewRelic::Agent::Transaction::AbstractSegment::INSPECT_IGNORE = T.let(T.unsafe(nil), Array)

# source://newrelic_rpm//lib/new_relic/agent/transaction/abstract_segment.rb#28
NewRelic::Agent::Transaction::AbstractSegment::SEGMENT = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/transaction.rb#27
NewRelic::Agent::Transaction::CONTROLLER_PREFIX = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/datastore_segment.rb#13
class NewRelic::Agent::Transaction::DatastoreSegment < ::NewRelic::Agent::Transaction::Segment
  # @return [DatastoreSegment] a new instance of DatastoreSegment
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/datastore_segment.rb#19
  def initialize(product, operation, collection = T.unsafe(nil), host = T.unsafe(nil), port_path_or_id = T.unsafe(nil), database_name = T.unsafe(nil), start_time = T.unsafe(nil)); end

  # @api private
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/datastore_segment.rb#64
  def _notice_sql(sql, config = T.unsafe(nil), explainer = T.unsafe(nil), binds = T.unsafe(nil), name = T.unsafe(nil)); end

  # Returns the value of attribute collection.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/datastore_segment.rb#16
  def collection; end

  # Returns the value of attribute database_name.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/datastore_segment.rb#17
  def database_name; end

  # Sets the attribute database_name
  #
  # @param value the value to set the attribute database_name to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/datastore_segment.rb#17
  def database_name=(_arg0); end

  # Returns the value of attribute host.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/datastore_segment.rb#16
  def host; end

  # Returns the value of attribute nosql_statement.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/datastore_segment.rb#16
  def nosql_statement; end

  # Method for simplifying attaching non-SQL data statements to a
  # transaction. For instance, Mongo or CQL queries, Memcached or Redis
  # keys would all be appropriate data to attach as statements.
  #
  # Data passed to this method is NOT obfuscated by New Relic, so please
  # ensure that user information is obfuscated if the agent setting
  # `transaction_tracer.record_sql` is set to `obfuscated`
  #
  # @note THERE ARE SECURITY CONCERNS WHEN CAPTURING STATEMENTS!
  #   This method will properly ignore statements when the user has turned
  #   off capturing queries, but it is not able to obfuscate arbitrary data!
  #   To prevent exposing user information embedded in captured queries,
  #   please ensure all data passed to this method is safe to transmit to
  #   New Relic.
  # @param nosql_statement [String] text of the statement to capture.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/datastore_segment.rb#87
  def notice_nosql_statement(nosql_statement); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/datastore_segment.rb#58
  def notice_sql(sql); end

  # Returns the value of attribute operation.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/datastore_segment.rb#16
  def operation; end

  # Returns the value of attribute port_path_or_id.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/datastore_segment.rb#16
  def port_path_or_id; end

  # Returns the value of attribute product.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/datastore_segment.rb#16
  def product; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/datastore_segment.rb#94
  def record_metrics; end

  # Returns the value of attribute record_sql.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/datastore_segment.rb#17
  def record_sql; end

  # Sets the attribute record_sql
  #
  # @param value the value to set the attribute record_sql to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/datastore_segment.rb#17
  def record_sql=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/datastore_segment.rb#33
  def set_instance_info(host = T.unsafe(nil), port_path_or_id = T.unsafe(nil)); end

  # Returns the value of attribute sql_statement.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/datastore_segment.rb#16
  def sql_statement; end

  private

  # source://newrelic_rpm//lib/new_relic/agent/transaction/datastore_segment.rb#122
  def add_backtrace_parameter; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/datastore_segment.rb#116
  def add_database_name_parameter; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/datastore_segment.rb#111
  def add_instance_parameters; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/datastore_segment.rb#128
  def notice_sql_statement; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/datastore_segment.rb#133
  def notice_statement; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/datastore_segment.rb#141
  def record_span_event; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/datastore_segment.rb#137
  def record_sql?; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/datastore_segment.rb#101
  def segment_complete; end
end

# source://newrelic_rpm//lib/new_relic/agent/transaction/datastore_segment.rb#120
NewRelic::Agent::Transaction::DatastoreSegment::NEWLINE = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/datastore_segment.rb#14
NewRelic::Agent::Transaction::DatastoreSegment::UNKNOWN = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracer.rb#12
class NewRelic::Agent::Transaction::DistributedTracer
  include ::NewRelic::Agent::CrossAppTracing
  include ::NewRelic::Agent::Transaction::DistributedTracing
  include ::NewRelic::Coerce
  include ::NewRelic::Agent::Transaction::TraceContext

  # @return [DistributedTracer] a new instance of DistributedTracer
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracer.rb#53
  def initialize(transaction); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracer.rb#28
  def accept_incoming_request(request, transport_type = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracer.rb#45
  def accept_incoming_transport_type(request, transport_type); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracer.rb#41
  def accept_transport_type_from_api(value); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracer.rb#62
  def append_payload(payload); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracer.rb#94
  def assign_intrinsics; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracer.rb#37
  def caller_transport_type; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracer.rb#85
  def consume_message_headers(headers, tracer_state, transport_type); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracer.rb#110
  def insert_cat_headers(headers); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracer.rb#102
  def insert_distributed_trace_header(headers); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracer.rb#76
  def insert_headers(headers); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracer.rb#71
  def log_request_headers(headers, direction = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracer.rb#20
  def parent_guid; end

  # Returns the value of attribute parent_transaction_id.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracer.rb#18
  def parent_transaction_id; end

  # Sets the attribute parent_transaction_id
  #
  # @param value the value to set the attribute parent_transaction_id to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracer.rb#18
  def parent_transaction_id=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracer.rb#57
  def record_metrics; end

  # Returns the value of attribute transaction.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracer.rb#17
  def transaction; end

  private

  # source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracer.rb#163
  def accept_cross_app_payload(headers, tracer_state); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracer.rb#155
  def consume_message_cross_app_tracing_headers(headers, tracer_state); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracer.rb#142
  def consume_message_distributed_tracing_headers(headers, transport_type); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracer.rb#127
  def consume_message_synthetics_headers(headers); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracer.rb#179
  def deobfuscate(message); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracer.rb#123
  def dt_enabled?; end
end

# source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracing.rb#12
module NewRelic::Agent::Transaction::DistributedTracing
  # source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracing.rb#62
  def accept_distributed_trace_payload(payload); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracing.rb#38
  def accept_distributed_tracing_incoming_request(request); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracing.rb#49
  def create_distributed_trace_payload; end

  # Returns the value of attribute distributed_trace_payload.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracing.rb#13
  def distributed_trace_payload; end

  # Sets the attribute distributed_trace_payload
  #
  # @param value the value to set the attribute distributed_trace_payload to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracing.rb#13
  def distributed_trace_payload=(_arg0); end

  # Sets the attribute distributed_trace_payload_created
  #
  # @param value the value to set the attribute distributed_trace_payload_created to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracing.rb#14
  def distributed_trace_payload_created=(_arg0); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracing.rb#45
  def distributed_trace_payload_created?; end

  private

  # source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracing.rb#155
  def assign_payload_and_sampling_params(payload); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracing.rb#84
  def check_payload_ignored(payload); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracing.rb#95
  def check_payload_present(payload); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracing.rb#121
  def check_required_fields_present(payload); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracing.rb#146
  def check_trusted_account(payload); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracing.rb#137
  def check_valid_version(payload); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracing.rb#105
  def decode_payload(payload); end
end

# source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracing.rb#24
NewRelic::Agent::Transaction::DistributedTracing::ACCEPT_EXCEPTION_METRIC = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracing.rb#25
NewRelic::Agent::Transaction::DistributedTracing::ACCEPT_PARSE_EXCEPTION_METRIC = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracing.rb#18
NewRelic::Agent::Transaction::DistributedTracing::ACCEPT_PREFIX = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracing.rb#23
NewRelic::Agent::Transaction::DistributedTracing::ACCEPT_SUCCESS_METRIC = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracing.rb#22
NewRelic::Agent::Transaction::DistributedTracing::CREATE_EXCEPTION_METRIC = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracing.rb#17
NewRelic::Agent::Transaction::DistributedTracing::CREATE_PREFIX = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracing.rb#21
NewRelic::Agent::Transaction::DistributedTracing::CREATE_SUCCESS_METRIC = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracing.rb#27
NewRelic::Agent::Transaction::DistributedTracing::IGNORE_ACCEPT_AFTER_CREATE_METRIC = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracing.rb#30
NewRelic::Agent::Transaction::DistributedTracing::IGNORE_ACCEPT_MAJOR_VERSION_METRIC = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracing.rb#29
NewRelic::Agent::Transaction::DistributedTracing::IGNORE_ACCEPT_NULL_METRIC = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracing.rb#31
NewRelic::Agent::Transaction::DistributedTracing::IGNORE_ACCEPT_UNTRUSTED_ACCOUNT_METRIC = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracing.rb#28
NewRelic::Agent::Transaction::DistributedTracing::IGNORE_MULTIPLE_ACCEPT_METRIC = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracing.rb#19
NewRelic::Agent::Transaction::DistributedTracing::IGNORE_PREFIX = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracing.rb#33
NewRelic::Agent::Transaction::DistributedTracing::LBRACE = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracing.rb#36
NewRelic::Agent::Transaction::DistributedTracing::NEWRELIC_TRACE_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracing.rb#34
NewRelic::Agent::Transaction::DistributedTracing::NULL_PAYLOAD = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/distributed_tracing.rb#16
NewRelic::Agent::Transaction::DistributedTracing::SUPPORTABILITY_DISTRIBUTED_TRACE = T.let(T.unsafe(nil), String)

# This class represents an external segment in a transaction trace.
#
# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/transaction/external_request_segment.rb#15
class NewRelic::Agent::Transaction::ExternalRequestSegment < ::NewRelic::Agent::Transaction::Segment
  # @api public
  # @return [ExternalRequestSegment] a new instance of ExternalRequestSegment
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/external_request_segment.rb#28
  def initialize(library, uri, procedure, start_time = T.unsafe(nil)); end

  # This method adds New Relic request headers to a given request made to an
  # external API and checks to see if a host header is used for the request.
  # If a host header is used, it updates the segment name to match the host
  # header.
  #
  # object (must belong to a subclass of NewRelic::Agent::HTTPClients::AbstractRequest)
  #
  # @api public
  # @param request [NewRelic::Agent::HTTPClients::AbstractRequest] the request
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/external_request_segment.rb#64
  def add_request_headers(request); end

  # @api public
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/external_request_segment.rb#103
  def cross_app_request?; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/external_request_segment.rb#107
  def cross_process_id; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/external_request_segment.rb#115
  def cross_process_transaction_name; end

  # Obtain an obfuscated +String+ suitable for delivery across public networks that identifies this application
  # and transaction to another application which is also running a New Relic agent. This +String+ can be processed
  # by +process_request_metadata+ on the receiving application.
  #
  # @api public
  # @return [String] obfuscated request metadata to send
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/external_request_segment.rb#127
  def get_request_metadata; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/external_request_segment.rb#43
  def host; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/external_request_segment.rb#25
  def http_status_code; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/external_request_segment.rb#25
  def library; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/external_request_segment.rb#39
  def name; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/external_request_segment.rb#25
  def procedure; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/external_request_segment.rb#195
  def process_response_headers(response); end

  # Process obfuscated +String+ sent from a called application that is also running a New Relic agent and
  # save information in current transaction for inclusion in a trace. This +String+ is generated by
  # +get_response_metadata+ on the receiving application.
  #
  # @api public
  # @param response_metadata [String] received obfuscated response metadata
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/external_request_segment.rb#170
  def process_response_metadata(response_metadata); end

  # This method extracts app data from an external response if present. If
  # a valid cross-app ID is found, the name of the segment is updated to
  # reflect the cross-process ID and transaction name.
  #
  # @api public
  # @param response [Hash] a hash of response headers
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/external_request_segment.rb#84
  def read_response_headers(response); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/external_request_segment.rb#26
  def record_agent_attributes=(_arg0); end

  # By default external request segments only have errors and the http
  # url recorded as agent attributes. To have all the agent attributes
  # recorded, use the attr_writer like so `segment.record_agent_attributes = true`
  # See: SpanEventPrimitive#for_external_request_segment
  #
  # @api public
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/external_request_segment.rb#51
  def record_agent_attributes?; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/external_request_segment.rb#190
  def record_metrics; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/external_request_segment.rb#111
  def transaction_guid; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/external_request_segment.rb#25
  def uri; end

  private

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/external_request_segment.rb#232
  def add_unscoped_metrics; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/external_request_segment.rb#212
  def insert_synthetics_header(request, header, info); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/external_request_segment.rb#258
  def obfuscator; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/external_request_segment.rb#226
  def process_host_header(request); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/external_request_segment.rb#262
  def record_span_event; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/external_request_segment.rb#217
  def segment_complete; end

  # Only sets the http_status_code if response.status_code is non-empty value
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/external_request_segment.rb#203
  def set_http_status_code(response); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/external_request_segment.rb#242
  def suffixed_rollup_metric; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/external_request_segment.rb#250
  def update_segment_name; end
end

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/transaction/external_request_segment.rb#18
NewRelic::Agent::Transaction::ExternalRequestSegment::APP_DATA_KEY = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/transaction/external_request_segment.rb#20
NewRelic::Agent::Transaction::ExternalRequestSegment::EXTERNAL_ALL = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/transaction/external_request_segment.rb#22
NewRelic::Agent::Transaction::ExternalRequestSegment::EXTERNAL_ALL_OTHER = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/transaction/external_request_segment.rb#21
NewRelic::Agent::Transaction::ExternalRequestSegment::EXTERNAL_ALL_WEB = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/transaction/external_request_segment.rb#23
NewRelic::Agent::Transaction::ExternalRequestSegment::MISSING_STATUS_CODE = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/transaction/external_request_segment.rb#16
NewRelic::Agent::Transaction::ExternalRequestSegment::NR_SYNTHETICS_HEADER = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/transaction/external_request_segment.rb#17
NewRelic::Agent::Transaction::ExternalRequestSegment::NR_SYNTHETICS_INFO_HEADER = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/transaction.rb#36
NewRelic::Agent::Transaction::GRAPE_PREFIX = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/transaction.rb#55
NewRelic::Agent::Transaction::JRUBY_CPU_TIME_ERROR = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/transaction.rb#32
NewRelic::Agent::Transaction::MESSAGE_PREFIX = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/transaction.rb#28
NewRelic::Agent::Transaction::MIDDLEWARE_PREFIX = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/transaction.rb#41
NewRelic::Agent::Transaction::MIDDLEWARE_SUMMARY_METRICS = T.let(T.unsafe(nil), Array)

# source://newrelic_rpm//lib/new_relic/agent/transaction/message_broker_segment.rb#11
class NewRelic::Agent::Transaction::MessageBrokerSegment < ::NewRelic::Agent::Transaction::Segment
  # @return [MessageBrokerSegment] a new instance of MessageBrokerSegment
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/message_broker_segment.rb#54
  def initialize(action:, library:, destination_type:, destination_name:, headers: T.unsafe(nil), parameters: T.unsafe(nil), start_time: T.unsafe(nil)); end

  # Returns the value of attribute action.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/message_broker_segment.rb#48
  def action; end

  # Returns the value of attribute destination_name.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/message_broker_segment.rb#48
  def destination_name; end

  # Returns the value of attribute destination_type.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/message_broker_segment.rb#48
  def destination_type; end

  # Returns the value of attribute headers.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/message_broker_segment.rb#48
  def headers; end

  # Returns the value of attribute library.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/message_broker_segment.rb#48
  def library; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/message_broker_segment.rb#71
  def name; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/message_broker_segment.rb#86
  def transaction_assigned; end
end

# source://newrelic_rpm//lib/new_relic/agent/transaction/message_broker_segment.rb#31
NewRelic::Agent::Transaction::MessageBrokerSegment::ACTIONS = T.let(T.unsafe(nil), Hash)

# source://newrelic_rpm//lib/new_relic/agent/transaction/message_broker_segment.rb#12
NewRelic::Agent::Transaction::MessageBrokerSegment::CONSUME = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/message_broker_segment.rb#22
NewRelic::Agent::Transaction::MessageBrokerSegment::DESTINATION_TYPES = T.let(T.unsafe(nil), Array)

# source://newrelic_rpm//lib/new_relic/agent/transaction/message_broker_segment.rb#13
NewRelic::Agent::Transaction::MessageBrokerSegment::EXCHANGE = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/message_broker_segment.rb#46
NewRelic::Agent::Transaction::MessageBrokerSegment::METRIC_PREFIX = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/message_broker_segment.rb#14
NewRelic::Agent::Transaction::MessageBrokerSegment::NAMED = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/message_broker_segment.rb#15
NewRelic::Agent::Transaction::MessageBrokerSegment::PRODUCE = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/message_broker_segment.rb#17
NewRelic::Agent::Transaction::MessageBrokerSegment::PURGE = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/message_broker_segment.rb#16
NewRelic::Agent::Transaction::MessageBrokerSegment::QUEUE = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/message_broker_segment.rb#18
NewRelic::Agent::Transaction::MessageBrokerSegment::TEMP = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/message_broker_segment.rb#19
NewRelic::Agent::Transaction::MessageBrokerSegment::TOPIC = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/message_broker_segment.rb#37
NewRelic::Agent::Transaction::MessageBrokerSegment::TYPES = T.let(T.unsafe(nil), Hash)

# source://newrelic_rpm//lib/new_relic/agent/transaction/message_broker_segment.rb#20
NewRelic::Agent::Transaction::MessageBrokerSegment::UNKNOWN = T.let(T.unsafe(nil), String)

# for nested transactions
#
# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/transaction.rb#26
NewRelic::Agent::Transaction::NESTED_TRANSACTION_PREFIX = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/transaction.rb#43
NewRelic::Agent::Transaction::OTHER_SUMMARY_METRIC = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/transaction.rb#29
NewRelic::Agent::Transaction::OTHER_TRANSACTION_PREFIX = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/transaction.rb#44
NewRelic::Agent::Transaction::QUEUE_TIME_METRIC = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/transaction.rb#33
NewRelic::Agent::Transaction::RACK_PREFIX = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/transaction.rb#31
NewRelic::Agent::Transaction::RAKE_PREFIX = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/transaction.rb#34
NewRelic::Agent::Transaction::RODA_PREFIX = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/request_attributes.rb#10
class NewRelic::Agent::Transaction::RequestAttributes
  # @return [RequestAttributes] a new instance of RequestAttributes
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/request_attributes.rb#22
  def initialize(request); end

  # the HTTP standard has "referrer" mispelled as "referer"
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/request_attributes.rb#12
  def accept; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/request_attributes.rb#35
  def assign_agent_attributes(txn); end

  # the HTTP standard has "referrer" mispelled as "referer"
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/request_attributes.rb#12
  def content_length; end

  # the HTTP standard has "referrer" mispelled as "referer"
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/request_attributes.rb#12
  def content_type; end

  # the HTTP standard has "referrer" mispelled as "referer"
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/request_attributes.rb#12
  def host; end

  # the HTTP standard has "referrer" mispelled as "referer"
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/request_attributes.rb#12
  def other_headers; end

  # the HTTP standard has "referrer" mispelled as "referer"
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/request_attributes.rb#12
  def port; end

  # the HTTP standard has "referrer" mispelled as "referer"
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/request_attributes.rb#12
  def referer; end

  # the HTTP standard has "referrer" mispelled as "referer"
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/request_attributes.rb#12
  def request_method; end

  # the HTTP standard has "referrer" mispelled as "referer"
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/request_attributes.rb#12
  def request_path; end

  # the HTTP standard has "referrer" mispelled as "referer"
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/request_attributes.rb#12
  def user_agent; end

  private

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/request_attributes.rb#136
  def allow_other_headers?; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/request_attributes.rb#130
  def attribute_from_env(request, key); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/request_attributes.rb#124
  def attribute_from_request(request, attribute_method); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/request_attributes.rb#112
  def content_length_from_request(request); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/request_attributes.rb#152
  def formatted_header(raw_name); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/request_attributes.rb#140
  def other_headers_from_request(request); end

  # In practice we expect req to be a Rack::Request or ActionController::AbstractRequest
  # (for older Rails versions).  But anything that responds to path can be passed to
  # perform_action_with_newrelic_trace.
  #
  # We don't expect the path to include a query string, however older test helpers for
  # rails construct the PATH_INFO enviroment variable improperly and we're generally
  # being defensive.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/request_attributes.rb#106
  def path_from_request(request); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/request_attributes.rb#118
  def port_from_request(request); end

  # Make a safe attempt to get the referer from a request object, generally successful when
  # it's a Rack request.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/request_attributes.rb#92
  def referer_from_request(request); end
end

# source://newrelic_rpm//lib/new_relic/agent/transaction/request_attributes.rb#20
NewRelic::Agent::Transaction::RequestAttributes::ATTRIBUTE_PREFIX = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/request_attributes.rb#17
NewRelic::Agent::Transaction::RequestAttributes::BASE_HEADERS = T.let(T.unsafe(nil), Array)

# source://newrelic_rpm//lib/new_relic/agent/transaction/request_attributes.rb#15
NewRelic::Agent::Transaction::RequestAttributes::HTTP_ACCEPT_HEADER_KEY = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/transaction.rb#35
NewRelic::Agent::Transaction::SINATRA_PREFIX = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/segment.rb#12
class NewRelic::Agent::Transaction::Segment < ::NewRelic::Agent::Transaction::AbstractSegment
  # @return [Segment] a new instance of Segment
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/segment.rb#18
  def initialize(name = T.unsafe(nil), unscoped_metrics = T.unsafe(nil), start_time = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/segment.rb#27
  def add_agent_attribute(key, value, default_destinations = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/segment.rb#45
  def add_custom_attributes(p); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/segment.rb#23
  def attributes; end

  # unscoped_metrics can be nil, a string, or array. we do this to save
  # object allocations. if allocations weren't important then we would
  # initialize it as an array that would be empty, have one item, or many items.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/segment.rb#16
  def custom_transaction_attributes; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/segment.rb#39
  def merge_untrusted_agent_attributes(agent_attributes, prefix, default_destinations); end

  # unscoped_metrics can be nil, a string, or array. we do this to save
  # object allocations. if allocations weren't important then we would
  # initialize it as an array that would be empty, have one item, or many items.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/segment.rb#16
  def unscoped_metrics; end

  private

  # source://newrelic_rpm//lib/new_relic/agent/transaction/segment.rb#68
  def append_unscoped_metric(metric); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/segment.rb#57
  def record_metrics; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/segment.rb#88
  def record_span_event; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/segment.rb#84
  def segment_complete; end

  class << self
    # source://newrelic_rpm//lib/new_relic/agent/transaction/segment.rb#49
    def finish(segment); end

    # source://newrelic_rpm//lib/new_relic/agent/transaction/segment.rb#31
    def merge_untrusted_agent_attributes(attributes, prefix, default_destinations); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/transaction/slowest_sample_buffer.rb#10
class NewRelic::Agent::Transaction::SlowestSampleBuffer < ::NewRelic::Agent::Transaction::TransactionSampleBuffer
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/slowest_sample_buffer.rb#17
  def allow_sample?(sample); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/slowest_sample_buffer.rb#13
  def capacity; end
end

# source://newrelic_rpm//lib/new_relic/agent/transaction/slowest_sample_buffer.rb#11
NewRelic::Agent::Transaction::SlowestSampleBuffer::CAPACITY = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/agent/transaction/synthetics_sample_buffer.rb#10
class NewRelic::Agent::Transaction::SyntheticsSampleBuffer < ::NewRelic::Agent::Transaction::TransactionSampleBuffer
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/synthetics_sample_buffer.rb#15
  def allow_sample?(sample); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/synthetics_sample_buffer.rb#11
  def capacity; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/synthetics_sample_buffer.rb#19
  def truncate_samples; end
end

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/transaction.rb#30
NewRelic::Agent::Transaction::TASK_PREFIX = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/trace.rb#10
class NewRelic::Agent::Transaction::Trace
  # @return [Trace] a new instance of Trace
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace.rb#19
  def initialize(start_time); end

  # Returns the value of attribute attributes.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace.rb#14
  def attributes; end

  # Sets the attribute attributes
  #
  # @param value the value to set the attribute attributes to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace.rb#14
  def attributes=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace.rb#114
  def attributes_for_tracer_destination; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace.rb#78
  def collect_explain_plans!; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace.rb#30
  def count_nodes; end

  # @raise [FinishedTraceError]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace.rb#53
  def create_node(time_since_start, metric_name = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace.rb#40
  def duration; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace.rb#60
  def each_node(&block); end

  # Iterates recursively over each node in the entire transaction
  # sample tree while keeping track of nested nodes
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace.rb#106
  def each_node_with_nest_tracking(&block); end

  # Returns the value of attribute finished.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace.rb#14
  def finished; end

  # Sets the attribute finished
  #
  # @param value the value to set the attribute finished to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace.rb#14
  def finished=(_arg0); end

  # Returns the value of attribute guid.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace.rb#14
  def guid; end

  # Sets the attribute guid
  #
  # @param value the value to set the attribute guid to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace.rb#14
  def guid=(_arg0); end

  # Returns the value of attribute node_count.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace.rb#14
  def node_count; end

  # Sets the attribute node_count
  #
  # @param value the value to set the attribute node_count to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace.rb#14
  def node_count=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace.rb#90
  def prepare_sql_for_transmission!; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace.rb#64
  def prepare_to_send!; end

  # Returns the value of attribute profile.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace.rb#14
  def profile; end

  # Sets the attribute profile
  #
  # @param value the value to set the attribute profile to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace.rb#14
  def profile=(_arg0); end

  # Returns the value of attribute root_node.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace.rb#13
  def root_node; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace.rb#26
  def sample_id; end

  # Returns the value of attribute start_time.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace.rb#13
  def start_time; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace.rb#98
  def strip_sql!; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace.rb#44
  def synthetics_resource_id; end

  # Returns the value of attribute threshold.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace.rb#14
  def threshold; end

  # Sets the attribute threshold
  #
  # @param value the value to set the attribute threshold to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace.rb#14
  def threshold=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace.rb#138
  def to_collector_array(encoder); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace.rb#49
  def to_s_compact; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace.rb#128
  def trace_tree(attributes_hash); end

  # Returns the value of attribute transaction_name.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace.rb#14
  def transaction_name; end

  # Sets the attribute transaction_name
  #
  # @param value the value to set the attribute transaction_name to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace.rb#14
  def transaction_name=(_arg0); end
end

# source://newrelic_rpm//lib/new_relic/agent/transaction/trace.rb#110
NewRelic::Agent::Transaction::Trace::AGENT_ATTRIBUTES_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/trace.rb#11
class NewRelic::Agent::Transaction::Trace::FinishedTraceError < ::StandardError; end

# source://newrelic_rpm//lib/new_relic/agent/transaction/trace.rb#112
NewRelic::Agent::Transaction::Trace::INTRINSIC_ATTRIBUTES_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/trace.rb#17
NewRelic::Agent::Transaction::Trace::ROOT = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/trace.rb#111
NewRelic::Agent::Transaction::Trace::USER_ATTRIBUTES_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/trace_builder.rb#12
module NewRelic::Agent::Transaction::TraceBuilder
  extend ::NewRelic::Agent::Transaction::TraceBuilder

  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_builder.rb#15
  def build_trace(transaction); end

  private

  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_builder.rb#46
  def copy_attributes(transaction, trace); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_builder.rb#40
  def create_trace_node(transaction, segment, parent); end

  # recursively builds a transaction trace from the flat list of segments
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_builder.rb#28
  def process_segments(transaction, segment, parent, relationship_map); end
end

# source://newrelic_rpm//lib/new_relic/agent/transaction/trace_context.rb#8
module NewRelic::Agent::Transaction::TraceContext
  include ::NewRelic::Coerce

  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_context.rb#128
  def accept_trace_context(header_data); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_context.rb#115
  def assign_trace_state_payload; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_context.rb#80
  def create_trace_state; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_context.rb#96
  def create_trace_state_payload; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_context.rb#151
  def ignore_trace_context?; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_context.rb#58
  def insert_trace_context_header(header, format = T.unsafe(nil)); end

  # Returns the value of attribute trace_context_header_data.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_context.rb#39
  def trace_context_header_data; end

  # Sets the attribute trace_context_header_data
  #
  # @param value the value to set the attribute trace_context_header_data to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_context.rb#39
  def trace_context_header_data=(_arg0); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_context.rb#162
  def trace_context_inserted?; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_context.rb#42
  def trace_parent_header_present?(request); end

  # Returns the value of attribute trace_state_payload.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_context.rb#40
  def trace_state_payload; end

  private

  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_context.rb#46
  def accept_trace_context_incoming_request(request); end
end

# source://newrelic_rpm//lib/new_relic/agent/transaction/trace_context.rb#32
NewRelic::Agent::Transaction::TraceContext::ACCEPT_EXCEPTION_METRIC = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/trace_context.rb#25
NewRelic::Agent::Transaction::TraceContext::ACCEPT_PREFIX = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/trace_context.rb#31
NewRelic::Agent::Transaction::TraceContext::ACCEPT_SUCCESS_METRIC = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/trace_context.rb#11
module NewRelic::Agent::Transaction::TraceContext::AccountHelpers
  extend ::NewRelic::Agent::Transaction::TraceContext::AccountHelpers

  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_context.rb#14
  def trace_state_entry_key; end
end

# source://newrelic_rpm//lib/new_relic/agent/transaction/trace_context.rb#29
NewRelic::Agent::Transaction::TraceContext::CREATE_EXCEPTION_METRIC = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/trace_context.rb#24
NewRelic::Agent::Transaction::TraceContext::CREATE_PREFIX = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/trace_context.rb#28
NewRelic::Agent::Transaction::TraceContext::CREATE_SUCCESS_METRIC = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/trace_context.rb#34
NewRelic::Agent::Transaction::TraceContext::IGNORE_ACCEPT_AFTER_CREATE_METRIC = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/trace_context.rb#33
NewRelic::Agent::Transaction::TraceContext::IGNORE_MULTIPLE_ACCEPT_METRIC = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/trace_context.rb#37
NewRelic::Agent::Transaction::TraceContext::INVALID_TRACESTATE_PAYLOAD_METRIC = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/trace_context.rb#36
NewRelic::Agent::Transaction::TraceContext::NO_NR_ENTRY_TRACESTATE_METRIC = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/trace_context.rb#23
NewRelic::Agent::Transaction::TraceContext::SUPPORTABILITY_PREFIX = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/trace_context.rb#26
NewRelic::Agent::Transaction::TraceContext::TRACESTATE_PREFIX = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/trace_node.rb#8
class NewRelic::Agent::Transaction::TraceNode
  # @return [TraceNode] a new instance of TraceNode
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_node.rb#20
  def initialize(metric_name, relative_start, relative_end = T.unsafe(nil), params = T.unsafe(nil), parent = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_node.rb#130
  def [](key); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_node.rb#124
  def []=(key, value); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_node.rb#90
  def children; end

  # Sets the attribute children
  #
  # @param value the value to set the attribute children to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_node.rb#94
  def children=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_node.rb#112
  def count_nodes; end

  # return the total duration of this node
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_node.rb#97
  def duration; end

  # call the provided block for this node and each
  # of the called nodes
  #
  # @yield [_self]
  # @yieldparam _self [NewRelic::Agent::Transaction::TraceNode] the object that the method was called on
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_node.rb#136
  def each_node(&block); end

  # call the provided block for this node and each
  # of the called nodes while keeping track of nested nodes
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_node.rb#146
  def each_node_with_nest_tracking(&block); end

  # sets the final timestamp on a node to indicate the exit
  # point of the node
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_node.rb#39
  def end_trace(timestamp); end

  # Returns the value of attribute entry_timestamp.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_node.rb#9
  def entry_timestamp; end

  # return the duration of this node without
  # including the time in the called nodes
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_node.rb#103
  def exclusive_duration; end

  # The exit timestamp will be relative except for the outermost sample which will
  # have a timestamp.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_node.rb#12
  def exit_timestamp; end

  # The exit timestamp will be relative except for the outermost sample which will
  # have a timestamp.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_node.rb#12
  def exit_timestamp=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_node.rb#162
  def explain_sql; end

  # Returns the value of attribute metric_name.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_node.rb#16
  def metric_name; end

  # Sets the attribute metric_name
  #
  # @param value the value to set the attribute metric_name to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_node.rb#16
  def metric_name=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_node.rb#171
  def obfuscated_sql; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_node.rb#118
  def params; end

  # Sets the attribute params
  #
  # @param value the value to set the attribute params to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_node.rb#122
  def params=(_arg0); end

  # Returns the value of attribute parent_node.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_node.rb#14
  def parent_node; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_node.rb#175
  def parent_node=(s); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_node.rb#56
  def path_string; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_node.rb#29
  def select_allowed_params(params); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_node.rb#47
  def to_array; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_node.rb#69
  def to_debug_str(depth); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_node.rb#43
  def to_s; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/trace_node.rb#60
  def to_s_compact; end
end

# source://newrelic_rpm//lib/new_relic/agent/transaction/trace_node.rb#18
NewRelic::Agent::Transaction::TraceNode::UNKNOWN_NODE_NAME = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/tracing.rb#8
module NewRelic::Agent::Transaction::Tracing
  # source://newrelic_rpm//lib/new_relic/agent/transaction/tracing.rb#23
  def add_segment(segment, parent = T.unsafe(nil)); end

  # Sets the attribute async
  #
  # @param value the value to set the attribute async to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/tracing.rb#15
  def async=(_arg0); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/tracing.rb#11
  def async?; end

  # Returns the value of attribute current_segment_by_thread.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/tracing.rb#9
  def current_segment_by_thread; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/tracing.rb#52
  def segment_complete(segment); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/tracing.rb#61
  def segment_limit; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/tracing.rb#42
  def thread_starting_span; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/tracing.rb#17
  def total_time; end

  # Sets the attribute total_time
  #
  # @param value the value to set the attribute total_time to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/tracing.rb#21
  def total_time=(_arg0); end

  private

  # source://newrelic_rpm//lib/new_relic/agent/transaction/tracing.rb#67
  def finalize_segments; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/tracing.rb#74
  def record_total_time_metrics; end
end

# source://newrelic_rpm//lib/new_relic/agent/transaction/tracing.rb#72
NewRelic::Agent::Transaction::Tracing::OTHER_TRANSACTION_TOTAL_TIME = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/tracing.rb#71
NewRelic::Agent::Transaction::Tracing::WEB_TRANSACTION_TOTAL_TIME = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction/transaction_sample_buffer.rb#8
class NewRelic::Agent::Transaction::TransactionSampleBuffer
  # @return [TransactionSampleBuffer] a new instance of TransactionSampleBuffer
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/transaction_sample_buffer.rb#13
  def initialize; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/transaction_sample_buffer.rb#31
  def allow_sample?(sample); end

  # Capacity is the desired number of samples a buffer will hold. This
  # can be user dictated via config if a feature wants.
  #
  # This value will be forcibly capped by the max_capacity
  #
  # @raise [NotImplementedError]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/transaction_sample_buffer.rb#65
  def capacity; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/transaction_sample_buffer.rb#17
  def enabled?; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/transaction_sample_buffer.rb#57
  def full?; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/transaction_sample_buffer.rb#25
  def harvest_samples; end

  # Apply hard upper limit to the capacity to prevent users from
  # consuming too much memory buffering TT's.
  #
  # A typical buffer should NOT override this method (although we do for
  # odd things like dev-mode)
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/transaction_sample_buffer.rb#74
  def max_capacity; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/transaction_sample_buffer.rb#21
  def reset!; end

  # Returns the value of attribute samples.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/transaction_sample_buffer.rb#9
  def samples; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/transaction_sample_buffer.rb#35
  def store(sample); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/transaction_sample_buffer.rb#44
  def store_previous(previous_samples); end

  # Our default truncation strategy is to keep max_capacity
  # worth of the longest samples. Override this method for alternate
  # behavior.
  #
  # This doesn't use the more convenient #last and #sort_by to avoid
  # additional array allocations (and abundant alliteration)
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/transaction_sample_buffer.rb#84
  def truncate_samples; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction/transaction_sample_buffer.rb#53
  def truncate_samples_if_needed; end

  # When pushing a scope different sample buffers potentially want to
  # know about what's happening to annotate the incoming nodes
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/transaction_sample_buffer.rb#91
  def visit_node(*_arg0); end

  private

  # If a buffer needs to modify an added sample, override this method.
  # Bounds checking, allowing samples and truncation belongs elsewhere.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction/transaction_sample_buffer.rb#99
  def add_sample(sample); end
end

# source://newrelic_rpm//lib/new_relic/agent/transaction/transaction_sample_buffer.rb#11
NewRelic::Agent::Transaction::TransactionSampleBuffer::SINGLE_BUFFER_MAX = T.let(T.unsafe(nil), Integer)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/transaction.rb#42
NewRelic::Agent::Transaction::WEB_SUMMARY_METRIC = T.let(T.unsafe(nil), String)

# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/transaction.rb#39
NewRelic::Agent::Transaction::WEB_TRANSACTION_CATEGORIES = T.let(T.unsafe(nil), Array)

# source://newrelic_rpm//lib/new_relic/agent/transaction_error_primitive.rb#16
module NewRelic::Agent::TransactionErrorPrimitive
  extend ::NewRelic::Agent::TransactionErrorPrimitive

  # source://newrelic_rpm//lib/new_relic/agent/transaction_error_primitive.rb#95
  def append_cat(payload, sample); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction_error_primitive.rb#78
  def append_synthetics(payload, sample); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction_error_primitive.rb#42
  def create(noticed_error, payload, span_id); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction_error_primitive.rb#50
  def intrinsic_attributes_for(noticed_error, payload, span_id); end
end

# source://newrelic_rpm//lib/new_relic/agent/transaction_error_primitive.rb#27
NewRelic::Agent::TransactionErrorPrimitive::DURATION_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction_error_primitive.rb#21
NewRelic::Agent::TransactionErrorPrimitive::ERROR_CLASS_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction_error_primitive.rb#23
NewRelic::Agent::TransactionErrorPrimitive::ERROR_EXPECTED_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction_error_primitive.rb#22
NewRelic::Agent::TransactionErrorPrimitive::ERROR_MESSAGE_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction_error_primitive.rb#29
NewRelic::Agent::TransactionErrorPrimitive::GUID_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction_error_primitive.rb#26
NewRelic::Agent::TransactionErrorPrimitive::NAME_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction_error_primitive.rb#25
NewRelic::Agent::TransactionErrorPrimitive::PORT_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction_error_primitive.rb#37
NewRelic::Agent::TransactionErrorPrimitive::PRIORITY_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction_error_primitive.rb#30
NewRelic::Agent::TransactionErrorPrimitive::REFERRING_TRANSACTION_GUID_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction_error_primitive.rb#28
NewRelic::Agent::TransactionErrorPrimitive::SAMPLED_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction_error_primitive.rb#19
NewRelic::Agent::TransactionErrorPrimitive::SAMPLE_TYPE = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction_error_primitive.rb#38
NewRelic::Agent::TransactionErrorPrimitive::SPAN_ID_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction_error_primitive.rb#35
NewRelic::Agent::TransactionErrorPrimitive::SYNTHETICS_INITIATOR_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction_error_primitive.rb#32
NewRelic::Agent::TransactionErrorPrimitive::SYNTHETICS_JOB_ID_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction_error_primitive.rb#36
NewRelic::Agent::TransactionErrorPrimitive::SYNTHETICS_KEY_PREFIX = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction_error_primitive.rb#33
NewRelic::Agent::TransactionErrorPrimitive::SYNTHETICS_MONITOR_ID_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction_error_primitive.rb#40
NewRelic::Agent::TransactionErrorPrimitive::SYNTHETICS_PAYLOAD_EXPECTED = T.let(T.unsafe(nil), Array)

# source://newrelic_rpm//lib/new_relic/agent/transaction_error_primitive.rb#31
NewRelic::Agent::TransactionErrorPrimitive::SYNTHETICS_RESOURCE_ID_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction_error_primitive.rb#34
NewRelic::Agent::TransactionErrorPrimitive::SYNTHETICS_TYPE_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction_error_primitive.rb#24
NewRelic::Agent::TransactionErrorPrimitive::TIMESTAMP_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction_error_primitive.rb#20
NewRelic::Agent::TransactionErrorPrimitive::TYPE_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction_event_aggregator.rb#13
class NewRelic::Agent::TransactionEventAggregator < ::NewRelic::Agent::EventAggregator
  # source://newrelic_rpm//lib/new_relic/agent/transaction_event_aggregator.rb#19
  def record(priority: T.unsafe(nil), event: T.unsafe(nil), &blk); end

  private

  # source://newrelic_rpm//lib/new_relic/agent/transaction_event_aggregator.rb#34
  def after_harvest(metadata); end

  # THREAD_LOCAL_ACCESS
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction_event_aggregator.rb#40
  def record_sampling_rate(metadata); end
end

# source://newrelic_rpm//lib/new_relic/agent/transaction_event_primitive.rb#15
module NewRelic::Agent::TransactionEventPrimitive
  include ::NewRelic::Coerce
  extend ::NewRelic::Coerce
  extend ::NewRelic::Agent::TransactionEventPrimitive

  # source://newrelic_rpm//lib/new_relic/agent/transaction_event_primitive.rb#47
  def create(payload); end

  private

  # source://newrelic_rpm//lib/new_relic/agent/transaction_event_primitive.rb#117
  def agent_attributes(attributes); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction_event_primitive.rb#96
  def append_cat_alternate_path_hashes(sample, payload); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction_event_primitive.rb#70
  def append_optional_attributes(sample, payload); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction_event_primitive.rb#85
  def append_synthetics_info_attributes(sample, payload); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction_event_primitive.rb#108
  def custom_attributes(attributes); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction_event_primitive.rb#102
  def optionally_append(sample_key, payload_key, sample, payload); end
end

# source://newrelic_rpm//lib/new_relic/agent/transaction_event_primitive.rb#37
NewRelic::Agent::TransactionEventPrimitive::APDEX_PERF_ZONE_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction_event_primitive.rb#36
NewRelic::Agent::TransactionEventPrimitive::CAT_ALTERNATE_PATH_HASHES_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction_event_primitive.rb#34
NewRelic::Agent::TransactionEventPrimitive::CAT_PATH_HASH_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction_event_primitive.rb#35
NewRelic::Agent::TransactionEventPrimitive::CAT_REFERRING_PATH_HASH_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction_event_primitive.rb#19
NewRelic::Agent::TransactionEventPrimitive::COMMA = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction_event_primitive.rb#28
NewRelic::Agent::TransactionEventPrimitive::DURATION_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction_event_primitive.rb#29
NewRelic::Agent::TransactionEventPrimitive::ERROR_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction_event_primitive.rb#32
NewRelic::Agent::TransactionEventPrimitive::GUID_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction_event_primitive.rb#27
NewRelic::Agent::TransactionEventPrimitive::NAME_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction_event_primitive.rb#31
NewRelic::Agent::TransactionEventPrimitive::PRIORITY_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction_event_primitive.rb#33
NewRelic::Agent::TransactionEventPrimitive::REFERRING_TRANSACTION_GUID_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction_event_primitive.rb#30
NewRelic::Agent::TransactionEventPrimitive::SAMPLED_KEY = T.let(T.unsafe(nil), String)

# The type field of the sample
#
# source://newrelic_rpm//lib/new_relic/agent/transaction_event_primitive.rb#22
NewRelic::Agent::TransactionEventPrimitive::SAMPLE_TYPE = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction_event_primitive.rb#42
NewRelic::Agent::TransactionEventPrimitive::SYNTHETICS_INITIATOR_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction_event_primitive.rb#39
NewRelic::Agent::TransactionEventPrimitive::SYNTHETICS_JOB_ID_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction_event_primitive.rb#43
NewRelic::Agent::TransactionEventPrimitive::SYNTHETICS_KEY_PREFIX = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction_event_primitive.rb#40
NewRelic::Agent::TransactionEventPrimitive::SYNTHETICS_MONITOR_ID_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction_event_primitive.rb#45
NewRelic::Agent::TransactionEventPrimitive::SYNTHETICS_PAYLOAD_EXPECTED = T.let(T.unsafe(nil), Array)

# source://newrelic_rpm//lib/new_relic/agent/transaction_event_primitive.rb#38
NewRelic::Agent::TransactionEventPrimitive::SYNTHETICS_RESOURCE_ID_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction_event_primitive.rb#41
NewRelic::Agent::TransactionEventPrimitive::SYNTHETICS_TYPE_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction_event_primitive.rb#26
NewRelic::Agent::TransactionEventPrimitive::TIMESTAMP_KEY = T.let(T.unsafe(nil), String)

# Strings for static keys of the sample structure
#
# source://newrelic_rpm//lib/new_relic/agent/transaction_event_primitive.rb#25
NewRelic::Agent::TransactionEventPrimitive::TYPE_KEY = T.let(T.unsafe(nil), String)

# This is responsible for recording transaction events and managing
# the relationship between events generated from synthetics requests
# vs normal requests.
#
# source://newrelic_rpm//lib/new_relic/agent/transaction_event_recorder.rb#14
class NewRelic::Agent::TransactionEventRecorder
  # @return [TransactionEventRecorder] a new instance of TransactionEventRecorder
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction_event_recorder.rb#18
  def initialize(events); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction_event_recorder.rb#35
  def create_event(payload); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction_event_recorder.rb#43
  def drop_buffered_data; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction_event_recorder.rb#23
  def record(payload); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction_event_recorder.rb#39
  def synthetics_event?(payload); end

  # Returns the value of attribute synthetics_event_aggregator.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction_event_recorder.rb#16
  def synthetics_event_aggregator; end

  # Returns the value of attribute transaction_event_aggregator.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction_event_recorder.rb#15
  def transaction_event_aggregator; end
end

# source://newrelic_rpm//lib/new_relic/agent/transaction_metrics.rb#12
class NewRelic::Agent::TransactionMetrics
  # @return [TransactionMetrics] a new instance of TransactionMetrics
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction_metrics.rb#15
  def initialize; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction_metrics.rb#41
  def [](key); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction_metrics.rb#53
  def _record_metrics(names, value, aux, target, &blk); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction_metrics.rb#49
  def each_scoped; end

  # source://newrelic_rpm//lib/new_relic/agent/transaction_metrics.rb#45
  def each_unscoped; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction_metrics.rb#37
  def has_key?(key); end

  # As a general rule, when recording a scoped metric, the corresponding
  # unscoped metric should always be recorded as well.
  #
  # As an optimization, scoped metrics are representated within this class
  # only by their entries in the @scoped Hash, and it's up to clients to
  # propagate them into unscoped metrics as well when instances of this
  # class are merged into the global metric store.
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction_metrics.rb#29
  def record_scoped_and_unscoped(names, value = T.unsafe(nil), aux = T.unsafe(nil), &blk); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction_metrics.rb#33
  def record_unscoped(names, value = T.unsafe(nil), aux = T.unsafe(nil), &blk); end
end

# source://newrelic_rpm//lib/new_relic/agent/transaction_metrics.rb#13
NewRelic::Agent::TransactionMetrics::DEFAULT_PROC = T.let(T.unsafe(nil), Proc)

# This class contains the logic for recording and storing transaction
# traces (sometimes referred to as 'transaction samples').
#
# A transaction trace is a detailed timeline of the events that happened
# during the processing of a single transaction, including database calls,
# template rendering calls, and other instrumented method calls.
#
# @api public
#
# source://newrelic_rpm//lib/new_relic/agent/transaction_sampler.rb#19
class NewRelic::Agent::TransactionSampler
  # @api public
  # @return [TransactionSampler] a new instance of TransactionSampler
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction_sampler.rb#22
  def initialize; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction_sampler.rb#100
  def count; end

  # @api public
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction_sampler.rb#48
  def enabled?; end

  # Gather transaction traces that we'd like to transmit to the server.
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction_sampler.rb#69
  def harvest!; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction_sampler.rb#107
  def harvest_from_sample_buffers; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction_sampler.rb#20
  def last_sample; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction_sampler.rb#92
  def merge!(previous); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction_sampler.rb#52
  def on_finishing_transaction(txn); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction_sampler.rb#79
  def prepare_samples(samples); end

  # reset samples without rebooting the web server (used by dev mode)
  #
  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction_sampler.rb#124
  def reset!; end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/agent/transaction_sampler.rb#62
  def store_sample(sample); end
end

# source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#216
class NewRelic::Agent::TransactionSqlData
  # @return [TransactionSqlData] a new instance of TransactionSqlData
  #
  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#222
  def initialize; end

  # Returns the value of attribute guid.
  #
  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#220
  def guid; end

  # Returns the value of attribute path.
  #
  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#217
  def path; end

  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#226
  def set_transaction_info(uri, guid); end

  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#231
  def set_transaction_name(name); end

  # Returns the value of attribute sql_data.
  #
  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#219
  def sql_data; end

  # Returns the value of attribute uri.
  #
  # source://newrelic_rpm//lib/new_relic/agent/sql_sampler.rb#218
  def uri; end
end

# source://newrelic_rpm//lib/new_relic/agent/transaction_time_aggregator.rb#14
module NewRelic::Agent::TransactionTimeAggregator
  private

  # source://newrelic_rpm//lib/new_relic/agent/transaction_time_aggregator.rb#44
  def harvest!(timestamp = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction_time_aggregator.rb#24
  def reset!(timestamp = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction_time_aggregator.rb#29
  def transaction_start(timestamp = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/agent/transaction_time_aggregator.rb#35
  def transaction_stop(timestamp = T.unsafe(nil), starting_thread_id = T.unsafe(nil)); end

  class << self
    # source://newrelic_rpm//lib/new_relic/agent/transaction_time_aggregator.rb#44
    def harvest!(timestamp = T.unsafe(nil)); end

    # source://newrelic_rpm//lib/new_relic/agent/transaction_time_aggregator.rb#24
    def reset!(timestamp = T.unsafe(nil)); end

    # source://newrelic_rpm//lib/new_relic/agent/transaction_time_aggregator.rb#29
    def transaction_start(timestamp = T.unsafe(nil)); end

    # source://newrelic_rpm//lib/new_relic/agent/transaction_time_aggregator.rb#35
    def transaction_stop(timestamp = T.unsafe(nil), starting_thread_id = T.unsafe(nil)); end

    private

    # source://newrelic_rpm//lib/new_relic/agent/transaction_time_aggregator.rb#98
    def current_thread; end

    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/transaction_time_aggregator.rb#94
    def in_transaction?(thread_id = T.unsafe(nil)); end

    # this method has no test coverage
    #
    # source://newrelic_rpm//lib/new_relic/agent/transaction_time_aggregator.rb#149
    def log_missing_elapsed_transaction_time; end

    # source://newrelic_rpm//lib/new_relic/agent/transaction_time_aggregator.rb#85
    def record_elapsed_transaction_time_until(timestamp, thread_id = T.unsafe(nil)); end

    # source://newrelic_rpm//lib/new_relic/agent/transaction_time_aggregator.rb#125
    def set_transaction_start_time(timestamp, thread_id = T.unsafe(nil)); end

    # @raise [ArgumentError]
    #
    # source://newrelic_rpm//lib/new_relic/agent/transaction_time_aggregator.rb#129
    def split_transaction_at_harvest(timestamp, thread_id = T.unsafe(nil)); end

    # source://newrelic_rpm//lib/new_relic/agent/transaction_time_aggregator.rb#120
    def thread_by_id(thread_id); end

    # @return [Boolean]
    #
    # source://newrelic_rpm//lib/new_relic/agent/transaction_time_aggregator.rb#102
    def thread_is_alive?(thread_id); end

    # source://newrelic_rpm//lib/new_relic/agent/transaction_time_aggregator.rb#136
    def transaction_time_in_thread(timestamp, thread_id, entry); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/transaction_time_aggregator.rb#42
NewRelic::Agent::TransactionTimeAggregator::INSTANCE_BUSY_METRIC = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/transaction_time_aggregator.rb#15
class NewRelic::Agent::TransactionTimeAggregator::TransactionStats < ::Struct
  # Returns the value of attribute elapsed_transaction_time
  #
  # @return [Object] the current value of elapsed_transaction_time
  def elapsed_transaction_time; end

  # Sets the attribute elapsed_transaction_time
  #
  # @param value [Object] the value to set the attribute elapsed_transaction_time to.
  # @return [Object] the newly set value
  def elapsed_transaction_time=(_); end

  # Returns the value of attribute transaction_started_at
  #
  # @return [Object] the current value of transaction_started_at
  def transaction_started_at; end

  # Sets the attribute transaction_started_at
  #
  # @param value [Object] the value to set the attribute transaction_started_at to.
  # @return [Object] the newly set value
  def transaction_started_at=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# placeholder name used when we cannot determine a transaction's name
#
# @api public
#
# source://newrelic_rpm//lib/new_relic/agent.rb#107
NewRelic::Agent::UNKNOWN_METRIC = T.let(T.unsafe(nil), String)

# An unrecoverable client-side error that prevents the agent from continuing
#
# @api public
#
# source://newrelic_rpm//lib/new_relic/agent.rb#101
class NewRelic::Agent::UnrecoverableAgentException < ::NewRelic::Agent::ServerConnectionException; end

# When a post is either too large or poorly formatted we should
# drop it and not try to resend
#
# @api public
#
# source://newrelic_rpm//lib/new_relic/agent.rb#98
class NewRelic::Agent::UnrecoverableServerException < ::NewRelic::Agent::ServerConnectionException; end

# source://newrelic_rpm//lib/new_relic/agent/utilization/vendor.rb#9
module NewRelic::Agent::Utilization; end

# source://newrelic_rpm//lib/new_relic/agent/utilization/aws.rb#10
class NewRelic::Agent::Utilization::AWS < ::NewRelic::Agent::Utilization::Vendor
  class << self
    # source://newrelic_rpm//lib/new_relic/agent/utilization/aws.rb#18
    def imds_token; end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/utilization/aws.rb#11
NewRelic::Agent::Utilization::AWS::IMDS_BASE_URL = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/utilization/aws.rb#12
NewRelic::Agent::Utilization::AWS::IMDS_KEYS = T.let(T.unsafe(nil), Array)

# source://newrelic_rpm//lib/new_relic/agent/utilization/aws.rb#13
NewRelic::Agent::Utilization::AWS::IMDS_TOKEN_TTL_SECS = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/utilization/aws.rb#14
NewRelic::Agent::Utilization::AWS::TOKEN_OPEN_TIMEOUT_SECS = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/agent/utilization/aws.rb#15
NewRelic::Agent::Utilization::AWS::TOKEN_READ_TIMEOUT_SECS = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/agent/utilization/azure.rb#8
class NewRelic::Agent::Utilization::Azure < ::NewRelic::Agent::Utilization::Vendor; end

# source://newrelic_rpm//lib/new_relic/agent/utilization/gcp.rb#10
class NewRelic::Agent::Utilization::GCP < ::NewRelic::Agent::Utilization::Vendor
  # source://newrelic_rpm//lib/new_relic/agent/utilization/gcp.rb#20
  def prepare_response(response); end

  # source://newrelic_rpm//lib/new_relic/agent/utilization/gcp.rb#27
  def trim_leading(value); end
end

# source://newrelic_rpm//lib/new_relic/agent/utilization/gcp.rb#17
NewRelic::Agent::Utilization::GCP::MACH_TYPE = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/utilization/gcp.rb#18
NewRelic::Agent::Utilization::GCP::ZONE = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/utilization/pcf.rb#10
class NewRelic::Agent::Utilization::PCF < ::NewRelic::Agent::Utilization::Vendor
  # source://newrelic_rpm//lib/new_relic/agent/utilization/pcf.rb#15
  def detect; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/utilization/pcf.rb#27
  def pcf_keys_present?; end
end

# source://newrelic_rpm//lib/new_relic/agent/utilization/vendor.rb#10
class NewRelic::Agent::Utilization::Vendor
  # @return [Vendor] a new instance of Vendor
  #
  # source://newrelic_rpm//lib/new_relic/agent/utilization/vendor.rb#45
  def initialize; end

  # source://newrelic_rpm//lib/new_relic/agent/utilization/vendor.rb#55
  def detect; end

  # source://newrelic_rpm//lib/new_relic/agent/utilization/vendor.rb#50
  def endpoint; end

  # source://newrelic_rpm//lib/new_relic/agent/utilization/vendor.rb#50
  def headers; end

  # source://newrelic_rpm//lib/new_relic/agent/utilization/vendor.rb#50
  def key_transforms; end

  # source://newrelic_rpm//lib/new_relic/agent/utilization/vendor.rb#50
  def keys; end

  # Returns the value of attribute metadata.
  #
  # source://newrelic_rpm//lib/new_relic/agent/utilization/vendor.rb#43
  def metadata; end

  # source://newrelic_rpm//lib/new_relic/agent/utilization/vendor.rb#50
  def vendor_name; end

  private

  # source://newrelic_rpm//lib/new_relic/agent/utilization/vendor.rb#106
  def normalize(value); end

  # source://newrelic_rpm//lib/new_relic/agent/utilization/vendor.rb#88
  def prepare_response(response); end

  # source://newrelic_rpm//lib/new_relic/agent/utilization/vendor.rb#92
  def process_response(response); end

  # source://newrelic_rpm//lib/new_relic/agent/utilization/vendor.rb#151
  def record_supportability_metric; end

  # source://newrelic_rpm//lib/new_relic/agent/utilization/vendor.rb#74
  def request_metadata; end

  # source://newrelic_rpm//lib/new_relic/agent/utilization/vendor.rb#145
  def transform_key(key); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/utilization/vendor.rb#132
  def valid_chars?(value); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/utilization/vendor.rb#121
  def valid_length?(value); end

  class << self
    # source://newrelic_rpm//lib/new_relic/agent/utilization/vendor.rb#16
    def endpoint(endpoint = T.unsafe(nil)); end

    # source://newrelic_rpm//lib/new_relic/agent/utilization/vendor.rb#20
    def headers(headers = T.unsafe(nil)); end

    # source://newrelic_rpm//lib/new_relic/agent/utilization/vendor.rb#28
    def key_transforms(key_transforms = T.unsafe(nil)); end

    # source://newrelic_rpm//lib/new_relic/agent/utilization/vendor.rb#24
    def keys(keys = T.unsafe(nil)); end

    # source://newrelic_rpm//lib/new_relic/agent/utilization/vendor.rb#32
    def processed_headers; end

    # source://newrelic_rpm//lib/new_relic/agent/utilization/vendor.rb#12
    def vendor_name(vendor_name = T.unsafe(nil)); end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/utilization/vendor.rb#53
NewRelic::Agent::Utilization::Vendor::SUCCESS = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/utilization/vendor.rb#130
NewRelic::Agent::Utilization::Vendor::VALID_CHARS = T.let(T.unsafe(nil), Regexp)

# source://newrelic_rpm//lib/new_relic/agent/utilization_data.rb#12
class NewRelic::Agent::UtilizationData
  # source://newrelic_rpm//lib/new_relic/agent/utilization_data.rb#114
  def append_boot_id(collector_hash); end

  # source://newrelic_rpm//lib/new_relic/agent/utilization_data.rb#110
  def append_configured_values(collector_hash); end

  # source://newrelic_rpm//lib/new_relic/agent/utilization_data.rb#101
  def append_docker_info(collector_hash); end

  # source://newrelic_rpm//lib/new_relic/agent/utilization_data.rb#138
  def append_full_hostname(collector_hash); end

  # source://newrelic_rpm//lib/new_relic/agent/utilization_data.rb#120
  def append_ip_address(collector_hash); end

  # source://newrelic_rpm//lib/new_relic/agent/utilization_data.rb#127
  def append_kubernetes_info(collector_hash); end

  # source://newrelic_rpm//lib/new_relic/agent/utilization_data.rb#87
  def append_vendor_info(collector_hash); end

  # source://newrelic_rpm//lib/new_relic/agent/utilization_data.rb#145
  def config_hash; end

  # source://newrelic_rpm//lib/new_relic/agent/utilization_data.rb#47
  def configured_hostname; end

  # this is slightly ugly, but if a string value is passed in
  # for the env var: NEW_RELIC_UTILIZATION_LOGICAL_PROCESSORS the
  # coercion from EnvironmentSource will turn that into a numerical 0,
  # which is not a reasonable value for logical_processes and should
  # not be sent up
  #
  # source://newrelic_rpm//lib/new_relic/agent/utilization_data.rb#56
  def configured_logical_processors; end

  # see comment above as the situation is the same for:
  # NEW_RELIC_UTILIZATION_TOTAL_RAM_MIB
  #
  # source://newrelic_rpm//lib/new_relic/agent/utilization_data.rb#63
  def configured_total_ram_mib; end

  # source://newrelic_rpm//lib/new_relic/agent/utilization_data.rb#34
  def container_id; end

  # source://newrelic_rpm//lib/new_relic/agent/utilization_data.rb#38
  def cpu_count; end

  # source://newrelic_rpm//lib/new_relic/agent/utilization_data.rb#26
  def fqdn; end

  # source://newrelic_rpm//lib/new_relic/agent/utilization_data.rb#22
  def hostname; end

  # source://newrelic_rpm//lib/new_relic/agent/utilization_data.rb#30
  def ip_addresses; end

  # source://newrelic_rpm//lib/new_relic/agent/utilization_data.rb#43
  def ram_in_mib; end

  # source://newrelic_rpm//lib/new_relic/agent/utilization_data.rb#68
  def to_collector_hash; end
end

# source://newrelic_rpm//lib/new_relic/agent/utilization_data.rb#125
NewRelic::Agent::UtilizationData::KUBERNETES_SERVICE_HOST = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/agent/utilization_data.rb#13
NewRelic::Agent::UtilizationData::METADATA_VERSION = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/agent/utilization_data.rb#15
NewRelic::Agent::UtilizationData::VENDORS = T.let(T.unsafe(nil), Hash)

# source://newrelic_rpm//lib/new_relic/agent/vm/monotonic_gc_profiler.rb#15
module NewRelic::Agent::VM
  class << self
    # source://newrelic_rpm//lib/new_relic/agent/vm.rb#20
    def create_vm; end

    # source://newrelic_rpm//lib/new_relic/agent/vm.rb#12
    def snapshot; end

    # source://newrelic_rpm//lib/new_relic/agent/vm.rb#16
    def vm; end
  end
end

# source://newrelic_rpm//lib/new_relic/agent/vm/c_ruby_vm.rb#11
class NewRelic::Agent::VM::CRubyVM
  # source://newrelic_rpm//lib/new_relic/agent/vm/c_ruby_vm.rb#63
  def gather_constant_cache_invalidations; end

  # source://newrelic_rpm//lib/new_relic/agent/vm/c_ruby_vm.rb#67
  def gather_constant_cache_misses; end

  # source://newrelic_rpm//lib/new_relic/agent/vm/c_ruby_vm.rb#34
  def gather_derived_stats(snap); end

  # source://newrelic_rpm//lib/new_relic/agent/vm/c_ruby_vm.rb#30
  def gather_gc_runs(snap); end

  # source://newrelic_rpm//lib/new_relic/agent/vm/c_ruby_vm.rb#25
  def gather_gc_stats(snap); end

  # source://newrelic_rpm//lib/new_relic/agent/vm/c_ruby_vm.rb#43
  def gather_gc_time(snap); end

  # source://newrelic_rpm//lib/new_relic/agent/vm/c_ruby_vm.rb#49
  def gather_ruby_vm_stats(snap); end

  # source://newrelic_rpm//lib/new_relic/agent/vm/c_ruby_vm.rb#18
  def gather_stats(snap); end

  # source://newrelic_rpm//lib/new_relic/agent/vm/c_ruby_vm.rb#71
  def gather_thread_stats(snap); end

  # source://newrelic_rpm//lib/new_relic/agent/vm/c_ruby_vm.rb#12
  def snapshot; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/vm/c_ruby_vm.rb#75
  def supports?(key); end
end

# source://newrelic_rpm//lib/new_relic/agent/vm/jruby_vm.rb#11
class NewRelic::Agent::VM::JRubyVM
  # source://newrelic_rpm//lib/new_relic/agent/vm/jruby_vm.rb#18
  def gather_stats(snap); end

  # source://newrelic_rpm//lib/new_relic/agent/vm/jruby_vm.rb#12
  def snapshot; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/vm/jruby_vm.rb#27
  def supports?(key); end
end

# source://newrelic_rpm//lib/new_relic/agent/vm/monotonic_gc_profiler.rb#16
class NewRelic::Agent::VM::MonotonicGCProfiler
  # @return [MonotonicGCProfiler] a new instance of MonotonicGCProfiler
  #
  # source://newrelic_rpm//lib/new_relic/agent/vm/monotonic_gc_profiler.rb#17
  def initialize; end

  # source://newrelic_rpm//lib/new_relic/agent/vm/monotonic_gc_profiler.rb#22
  def total_time_s; end
end

# source://newrelic_rpm//lib/new_relic/agent/vm/snapshot.rb#8
class NewRelic::Agent::VM::Snapshot
  # @return [Snapshot] a new instance of Snapshot
  #
  # source://newrelic_rpm//lib/new_relic/agent/vm/snapshot.rb#14
  def initialize; end

  # Returns the value of attribute constant_cache_invalidations.
  #
  # source://newrelic_rpm//lib/new_relic/agent/vm/snapshot.rb#9
  def constant_cache_invalidations; end

  # Sets the attribute constant_cache_invalidations
  #
  # @param value the value to set the attribute constant_cache_invalidations to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/vm/snapshot.rb#9
  def constant_cache_invalidations=(_arg0); end

  # Returns the value of attribute constant_cache_misses.
  #
  # source://newrelic_rpm//lib/new_relic/agent/vm/snapshot.rb#9
  def constant_cache_misses; end

  # Sets the attribute constant_cache_misses
  #
  # @param value the value to set the attribute constant_cache_misses to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/vm/snapshot.rb#9
  def constant_cache_misses=(_arg0); end

  # Returns the value of attribute gc_runs.
  #
  # source://newrelic_rpm//lib/new_relic/agent/vm/snapshot.rb#9
  def gc_runs; end

  # Sets the attribute gc_runs
  #
  # @param value the value to set the attribute gc_runs to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/vm/snapshot.rb#9
  def gc_runs=(_arg0); end

  # Returns the value of attribute gc_total_time.
  #
  # source://newrelic_rpm//lib/new_relic/agent/vm/snapshot.rb#9
  def gc_total_time; end

  # Sets the attribute gc_total_time
  #
  # @param value the value to set the attribute gc_total_time to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/vm/snapshot.rb#9
  def gc_total_time=(_arg0); end

  # Returns the value of attribute heap_free.
  #
  # source://newrelic_rpm//lib/new_relic/agent/vm/snapshot.rb#9
  def heap_free; end

  # Sets the attribute heap_free
  #
  # @param value the value to set the attribute heap_free to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/vm/snapshot.rb#9
  def heap_free=(_arg0); end

  # Returns the value of attribute heap_live.
  #
  # source://newrelic_rpm//lib/new_relic/agent/vm/snapshot.rb#9
  def heap_live; end

  # Sets the attribute heap_live
  #
  # @param value the value to set the attribute heap_live to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/vm/snapshot.rb#9
  def heap_live=(_arg0); end

  # Returns the value of attribute major_gc_count.
  #
  # source://newrelic_rpm//lib/new_relic/agent/vm/snapshot.rb#9
  def major_gc_count; end

  # Sets the attribute major_gc_count
  #
  # @param value the value to set the attribute major_gc_count to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/vm/snapshot.rb#9
  def major_gc_count=(_arg0); end

  # Returns the value of attribute method_cache_invalidations.
  #
  # source://newrelic_rpm//lib/new_relic/agent/vm/snapshot.rb#9
  def method_cache_invalidations; end

  # Sets the attribute method_cache_invalidations
  #
  # @param value the value to set the attribute method_cache_invalidations to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/vm/snapshot.rb#9
  def method_cache_invalidations=(_arg0); end

  # Returns the value of attribute minor_gc_count.
  #
  # source://newrelic_rpm//lib/new_relic/agent/vm/snapshot.rb#9
  def minor_gc_count; end

  # Sets the attribute minor_gc_count
  #
  # @param value the value to set the attribute minor_gc_count to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/vm/snapshot.rb#9
  def minor_gc_count=(_arg0); end

  # Returns the value of attribute taken_at.
  #
  # source://newrelic_rpm//lib/new_relic/agent/vm/snapshot.rb#9
  def taken_at; end

  # Sets the attribute taken_at
  #
  # @param value the value to set the attribute taken_at to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/vm/snapshot.rb#9
  def taken_at=(_arg0); end

  # Returns the value of attribute thread_count.
  #
  # source://newrelic_rpm//lib/new_relic/agent/vm/snapshot.rb#9
  def thread_count; end

  # Sets the attribute thread_count
  #
  # @param value the value to set the attribute thread_count to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/vm/snapshot.rb#9
  def thread_count=(_arg0); end

  # Returns the value of attribute total_allocated_object.
  #
  # source://newrelic_rpm//lib/new_relic/agent/vm/snapshot.rb#9
  def total_allocated_object; end

  # Sets the attribute total_allocated_object
  #
  # @param value the value to set the attribute total_allocated_object to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/vm/snapshot.rb#9
  def total_allocated_object=(_arg0); end
end

# A worker loop executes a set of registered tasks on a single thread.
# A task is a proc or block with a specified call period in seconds.
#
# source://newrelic_rpm//lib/new_relic/agent/worker_loop.rb#11
class NewRelic::Agent::WorkerLoop
  # Optional argument :duration (in seconds) for how long the worker loop runs
  # or :limit (integer) for max number of iterations
  #
  # @return [WorkerLoop] a new instance of WorkerLoop
  #
  # source://newrelic_rpm//lib/new_relic/agent/worker_loop.rb#17
  def initialize(opts = T.unsafe(nil)); end

  # Returns the value of attribute iterations.
  #
  # source://newrelic_rpm//lib/new_relic/agent/worker_loop.rb#13
  def iterations; end

  # a simple accessor for @should_run
  #
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/worker_loop.rb#62
  def keep_running?; end

  # Returns the value of attribute period.
  #
  # source://newrelic_rpm//lib/new_relic/agent/worker_loop.rb#12
  def period; end

  # Sets the attribute period
  #
  # @param value the value to set the attribute period to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/worker_loop.rb#12
  def period=(_arg0); end

  # Returns the value of attribute propagate_errors.
  #
  # source://newrelic_rpm//lib/new_relic/agent/worker_loop.rb#12
  def propagate_errors; end

  # Sets the attribute propagate_errors
  #
  # @param value the value to set the attribute propagate_errors to.
  #
  # source://newrelic_rpm//lib/new_relic/agent/worker_loop.rb#12
  def propagate_errors=(_arg0); end

  # Run infinitely, calling the registered tasks at their specified
  # call periods.  The caller is responsible for creating the thread
  # that runs this worker loop.  This will run the task immediately.
  #
  # source://newrelic_rpm//lib/new_relic/agent/worker_loop.rb#43
  def run(period = T.unsafe(nil), &block); end

  # Executes the block given to the worker loop, and handles errors.
  #
  # source://newrelic_rpm//lib/new_relic/agent/worker_loop.rb#80
  def run_task; end

  # source://newrelic_rpm//lib/new_relic/agent/worker_loop.rb#53
  def schedule_next_invocation; end

  # Reset state that is changed by running the worker loop
  #
  # source://newrelic_rpm//lib/new_relic/agent/worker_loop.rb#29
  def setup(period, task); end

  # Sets @should_run to false. Returns false
  #
  # source://newrelic_rpm//lib/new_relic/agent/worker_loop.rb#75
  def stop; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/worker_loop.rb#66
  def under_duration?; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/agent/worker_loop.rb#70
  def under_limit?; end
end

# source://newrelic_rpm//lib/new_relic/base64.rb#6
module NewRelic::Base64
  extend ::NewRelic::Base64

  # source://newrelic_rpm//lib/new_relic/base64.rb#13
  def decode64(str); end

  # source://newrelic_rpm//lib/new_relic/base64.rb#9
  def encode64(bin); end

  # source://newrelic_rpm//lib/new_relic/base64.rb#21
  def strict_decode64(str); end

  # source://newrelic_rpm//lib/new_relic/base64.rb#17
  def strict_encode64(bin); end
end

# source://newrelic_rpm//lib/new_relic/constants.rb#22
NewRelic::CANDIDATE_NEWRELIC_KEYS = T.let(T.unsafe(nil), Array)

# source://newrelic_rpm//lib/new_relic/constants.rb#38
NewRelic::CONNECT_RETRY_PERIODS = T.let(T.unsafe(nil), Array)

# This class is used by NewRelic::Agent.set_sql_obfuscator to chain multiple
# obfuscation blocks when not using the default :replace action
#
# source://newrelic_rpm//lib/new_relic/agent/chained_call.rb#7
class NewRelic::ChainedCall
  # @return [ChainedCall] a new instance of ChainedCall
  #
  # source://newrelic_rpm//lib/new_relic/agent/chained_call.rb#8
  def initialize(block1, block2); end

  # source://newrelic_rpm//lib/new_relic/agent/chained_call.rb#13
  def call(sql); end
end

# source://newrelic_rpm//lib/new_relic/coerce.rb#6
module NewRelic::Coerce
  private

  # Use when you plan to perform a boolean check using the integer 1
  # for true and the integer 0 for false
  # String values will be converted to 0
  #
  # source://newrelic_rpm//lib/new_relic/coerce.rb#75
  def boolean_int!(value); end

  # source://newrelic_rpm//lib/new_relic/coerce.rb#32
  def float(value, context = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/coerce.rb#79
  def float!(value, precision = T.unsafe(nil)); end

  # We really don't want to send bad values to the collector, and it doesn't
  # accept types like Rational that have occasionally slipped into our data.
  #
  # These non-bang methods are intended to safely coerce things into the form we want,
  # to provide documentation of expected types on to_collector_array methods,
  # and to log failures if totally invalid data gets into outgoing data
  #
  # source://newrelic_rpm//lib/new_relic/coerce.rb#16
  def int(value, context = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/coerce.rb#66
  def int!(value); end

  # source://newrelic_rpm//lib/new_relic/coerce.rb#23
  def int_or_nil(value, context = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/coerce.rb#91
  def log_failure(value, type, context, error); end

  # source://newrelic_rpm//lib/new_relic/coerce.rb#51
  def scalar(val); end

  # source://newrelic_rpm//lib/new_relic/coerce.rb#42
  def string(value, context = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/coerce.rb#85
  def value_or_nil(value); end

  class << self
    # Use when you plan to perform a boolean check using the integer 1
    # for true and the integer 0 for false
    # String values will be converted to 0
    #
    # source://newrelic_rpm//lib/new_relic/coerce.rb#75
    def boolean_int!(value); end

    # source://newrelic_rpm//lib/new_relic/coerce.rb#32
    def float(value, context = T.unsafe(nil)); end

    # source://newrelic_rpm//lib/new_relic/coerce.rb#79
    def float!(value, precision = T.unsafe(nil)); end

    # We really don't want to send bad values to the collector, and it doesn't
    # accept types like Rational that have occasionally slipped into our data.
    #
    # These non-bang methods are intended to safely coerce things into the form we want,
    # to provide documentation of expected types on to_collector_array methods,
    # and to log failures if totally invalid data gets into outgoing data
    #
    # source://newrelic_rpm//lib/new_relic/coerce.rb#16
    def int(value, context = T.unsafe(nil)); end

    # source://newrelic_rpm//lib/new_relic/coerce.rb#66
    def int!(value); end

    # source://newrelic_rpm//lib/new_relic/coerce.rb#23
    def int_or_nil(value, context = T.unsafe(nil)); end

    # source://newrelic_rpm//lib/new_relic/coerce.rb#91
    def log_failure(value, type, context, error); end

    # source://newrelic_rpm//lib/new_relic/coerce.rb#51
    def scalar(val); end

    # source://newrelic_rpm//lib/new_relic/coerce.rb#42
    def string(value, context = T.unsafe(nil)); end

    # source://newrelic_rpm//lib/new_relic/coerce.rb#85
    def value_or_nil(value); end
  end
end

# source://newrelic_rpm//lib/new_relic/collection_helper.rb#6
module NewRelic::CollectionHelper
  # Transform parameter hash into a hash whose values are strictly
  # strings
  #
  # source://newrelic_rpm//lib/new_relic/collection_helper.rb#11
  def normalize_params(params); end

  private

  # Convert any kind of object to a short string.
  #
  # source://newrelic_rpm//lib/new_relic/collection_helper.rb#38
  def flatten(object); end

  # source://newrelic_rpm//lib/new_relic/collection_helper.rb#47
  def truncate(string, len = T.unsafe(nil)); end
end

# source://newrelic_rpm//lib/new_relic/collection_helper.rb#8
NewRelic::CollectionHelper::DEFAULT_ARRAY_TRUNCATION_SIZE = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/collection_helper.rb#7
NewRelic::CollectionHelper::DEFAULT_TRUNCATION_SIZE = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/helper.rb#9
class NewRelic::CommandExecutableNotFoundError < ::StandardError; end

# source://newrelic_rpm//lib/new_relic/helper.rb#10
class NewRelic::CommandRunFailedError < ::StandardError; end

# The Control is a singleton responsible for the startup and
# initialization sequence.  The initializer uses a LocalEnvironment to
# detect the framework and instantiates the framework specific
# subclass.
#
# The Control also implements some of the public API for the agent.
#
# source://newrelic_rpm//lib/new_relic/control/frameworks.rb#6
class NewRelic::Control
  include ::NewRelic::Control::ServerMethods
  include ::NewRelic::Control::Instrumentation
  include ::NewRelic::Control::PrivateInstanceMethods
  include ::NewRelic::Control::InstanceMethods
  extend ::NewRelic::Control::ClassMethods

  # source://newrelic_rpm//lib/new_relic/control/instrumentation.rb#70
  def rails_32_deprecation; end
end

# class-level methods for lazy creation of NewRelic::Control and
# NewRelic::LocalEnvironment instances.
#
# source://newrelic_rpm//lib/new_relic/control/class_methods.rb#9
module NewRelic::Control::ClassMethods
  # Access the Control singleton, lazy initialized.  Default will instantiate a new
  # instance or pass false to defer
  #
  # source://newrelic_rpm//lib/new_relic/control/class_methods.rb#12
  def instance(create = T.unsafe(nil)); end

  # Loads the specified framework class from the
  # NewRelic::Control::Frameworks module
  #
  # source://newrelic_rpm//lib/new_relic/control/class_methods.rb#45
  def load_framework_class(framework); end

  # nb this does not 'load test' the framework, it loads the 'test framework'
  #
  # source://newrelic_rpm//lib/new_relic/control/class_methods.rb#37
  def load_test_framework; end

  # Access the LocalEnvironment singleton, lazy initialized
  #
  # source://newrelic_rpm//lib/new_relic/control/class_methods.rb#23
  def local_env; end

  # Create the concrete class for environment specific behavior
  #
  # source://newrelic_rpm//lib/new_relic/control/class_methods.rb#28
  def new_instance; end

  # The root directory for the plugin or gem
  #
  # source://newrelic_rpm//lib/new_relic/control/class_methods.rb#56
  def newrelic_root; end

  # clear out memoized Control and LocalEnv instances
  #
  # source://newrelic_rpm//lib/new_relic/control/class_methods.rb#17
  def reset; end
end

# Contains subclasses of NewRelic::Control that are used when
# starting the agent within an application. Framework-specific
# logic should be included here, as documented within the Control
# abstract parent class
#
# source://newrelic_rpm//lib/new_relic/control/frameworks.rb#11
module NewRelic::Control::Frameworks; end

# Contains methods that relate to the runtime usage of the control
# object. Note that these are subject to override in the
# NewRelic::Control::Framework classes that are actually instantiated
#
# source://newrelic_rpm//lib/new_relic/control/instance_methods.rb#16
module NewRelic::Control::InstanceMethods
  include ::NewRelic::Control::PrivateInstanceMethods

  # source://newrelic_rpm//lib/new_relic/control/instance_methods.rb#150
  def initialize(local_env, config_file_override = T.unsafe(nil)); end

  # for backward compatibility with the old config interface
  #
  # source://newrelic_rpm//lib/new_relic/control/instance_methods.rb#130
  def [](key); end

  # source://newrelic_rpm//lib/new_relic/control/instance_methods.rb#121
  def app; end

  # source://newrelic_rpm//lib/new_relic/control/instance_methods.rb#95
  def configure_agent(env, options); end

  # source://newrelic_rpm//lib/new_relic/control/instance_methods.rb#78
  def determine_env(options); end

  # source://newrelic_rpm//lib/new_relic/control/instance_methods.rb#138
  def dispatcher; end

  # The env is the setting used to identify which section of the newrelic.yml
  # to load.  This defaults to a framework specific value, such as ENV['RAILS_ENV']
  # but can be overridden as long as you set it before calling #init_plugin
  #
  # source://newrelic_rpm//lib/new_relic/control/instance_methods.rb#21
  def env=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/control/instance_methods.rb#125
  def framework; end

  # source://newrelic_rpm//lib/new_relic/control/instance_methods.rb#108
  def handle_invalid_security_settings; end

  # Initialize the plugin/gem and start the agent.  This does the
  # necessary configuration based on the framework environment and
  # determines whether or not to start the agent.  If the agent is
  # not going to be started then it loads the agent shim which has
  # stubs for all the external api.
  #
  # This may be invoked multiple times, as long as you don't attempt
  # to uninstall the agent after it has been started.
  #
  # If the plugin is initialized and it determines that the agent is
  # not enabled, it will skip starting it and install the shim.  But
  # if you later call this with <tt>:agent_enabled => true</tt>,
  # then it will install the real agent and start it.
  #
  # What determines whether the agent is launched is the result of
  # calling agent_enabled?  This will indicate whether the
  # instrumentation should/will be installed.  If we're in a mode
  # where tracers are not installed then we should not start the
  # agent.
  #
  # Subclasses are not allowed to override, but must implement
  # init_config({}) which is called one or more times.
  #
  # source://newrelic_rpm//lib/new_relic/control/instance_methods.rb#52
  def init_plugin(options = T.unsafe(nil)); end

  # The local environment contains all the information we report
  # to the server about what kind of application this is, what
  # gems and plugins it uses, and many other kinds of
  # machine-dependent information useful in debugging
  #
  # source://newrelic_rpm//lib/new_relic/control/instance_methods.rb#27
  def local_env; end

  # Delegates to the class method newrelic_root, implemented by
  # each subclass
  #
  # source://newrelic_rpm//lib/new_relic/control/instance_methods.rb#144
  def newrelic_root; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/control/instance_methods.rb#104
  def security_settings_valid?; end

  # source://newrelic_rpm//lib/new_relic/control/instance_methods.rb#134
  def settings; end

  # Install the real agent into the Agent module, and issue the start command.
  #
  # source://newrelic_rpm//lib/new_relic/control/instance_methods.rb#116
  def start_agent; end

  protected

  # source://newrelic_rpm//lib/new_relic/control/instance_methods.rb#159
  def root; end

  # source://newrelic_rpm//lib/new_relic/control/instance_methods.rb#163
  def stdout; end
end

# Contains methods that relate to adding and executing files that
# contain instrumentation for the Ruby Agent
#
# source://newrelic_rpm//lib/new_relic/control/instrumentation.rb#9
module NewRelic::Control::Instrumentation
  # Add instrumentation.  Don't call this directly.  Use NewRelic::Agent#add_instrumentation.
  # This will load the file synchronously if we've already loaded the default
  # instrumentation, otherwise instrumentation files specified
  # here will be deferred until all instrumentation is run
  #
  # This happens after the agent has loaded and all dependencies
  # are ready to be instrumented
  #
  # source://newrelic_rpm//lib/new_relic/control/instrumentation.rb#36
  def add_instrumentation(pattern); end

  # Signals the agent that it's time to actually load the
  # instrumentation files. May be overridden by subclasses
  #
  # source://newrelic_rpm//lib/new_relic/control/instrumentation.rb#46
  def install_instrumentation; end

  # source://newrelic_rpm//lib/new_relic/control/instrumentation.rb#25
  def install_shim; end

  # Adds a list of files in Dir.glob format
  # (e.g. '/app/foo/**/*_instrumentation.rb')
  # This requires the files within a rescue block, so that any
  # errors within instrumentation files do not affect the overall
  # agent or application in which it runs.
  #
  # source://newrelic_rpm//lib/new_relic/control/instrumentation.rb#15
  def load_instrumentation_files(pattern); end

  private

  # source://newrelic_rpm//lib/new_relic/control/instrumentation.rb#52
  def _install_instrumentation; end
end

# source://newrelic_rpm//lib/new_relic/control/private_instance_methods.rb#10
module NewRelic::Control::PrivateInstanceMethods
  private

  # source://newrelic_rpm//lib/new_relic/control/private_instance_methods.rb#24
  def config_file_path; end

  # source://newrelic_rpm//lib/new_relic/control/private_instance_methods.rb#13
  def configure_high_security; end

  # source://newrelic_rpm//lib/new_relic/control/private_instance_methods.rb#28
  def create_logger(options); end

  # source://newrelic_rpm//lib/new_relic/control/private_instance_methods.rb#34
  def init_instrumentation; end

  # source://newrelic_rpm//lib/new_relic/control/private_instance_methods.rb#20
  def log_yaml_source_failures(yaml_source); end
end

# Structs holding info for the remote server and proxy server
#
# source://newrelic_rpm//lib/new_relic/control/server_methods.rb#8
class NewRelic::Control::Server < ::Struct
  # source://newrelic_rpm//lib/new_relic/control/server_methods.rb#9
  def to_s; end
end

# Contains methods that deal with connecting to the server
#
# source://newrelic_rpm//lib/new_relic/control/server_methods.rb#13
module NewRelic::Control::ServerMethods
  # the server we should contact for api requests, like uploading
  # deployments and the like
  #
  # source://newrelic_rpm//lib/new_relic/control/server_methods.rb#20
  def api_server; end

  # source://newrelic_rpm//lib/new_relic/control/server_methods.rb#14
  def server; end

  # source://newrelic_rpm//lib/new_relic/control/server_methods.rb#24
  def server_from_host(hostname = T.unsafe(nil)); end
end

# source://newrelic_rpm//lib/new_relic/delayed_job_injection.rb#6
module NewRelic::DelayedJobInjection
  extend ::NewRelic::DelayedJobInjection

  # Returns the value of attribute worker_name.
  #
  # source://newrelic_rpm//lib/new_relic/delayed_job_injection.rb#8
  def worker_name; end

  # Sets the attribute worker_name
  #
  # @param value the value to set the attribute worker_name to.
  #
  # source://newrelic_rpm//lib/new_relic/delayed_job_injection.rb#8
  def worker_name=(_arg0); end
end

# source://newrelic_rpm//lib/new_relic/constants.rb#10
NewRelic::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# source://newrelic_rpm//lib/new_relic/constants.rb#11
NewRelic::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# source://newrelic_rpm//lib/new_relic/constants.rb#12
NewRelic::EMPTY_STR = T.let(T.unsafe(nil), String)

# The EnvironmentReport is responsible for analyzing the application's
# environment and generating the data for the Environment Report in New
# Relic's interface.
#
# It contains useful system information like Ruby version, OS, loaded gems,
# etc.
#
# Additional logic can be registered by using the EnvironmentReport.report_on
# hook.
#
# source://newrelic_rpm//lib/new_relic/environment_report.rb#15
class NewRelic::EnvironmentReport
  # Generate the report based on the class level logic.
  #
  # @return [EnvironmentReport] a new instance of EnvironmentReport
  #
  # source://newrelic_rpm//lib/new_relic/environment_report.rb#92
  def initialize; end

  # source://newrelic_rpm//lib/new_relic/environment_report.rb#104
  def [](key); end

  # source://newrelic_rpm//lib/new_relic/environment_report.rb#108
  def []=(key, value); end

  # end reporting logic
  #
  # source://newrelic_rpm//lib/new_relic/environment_report.rb#90
  def data; end

  # source://newrelic_rpm//lib/new_relic/environment_report.rb#112
  def to_a; end

  private

  # source://newrelic_rpm//lib/new_relic/environment_report.rb#125
  def record_empty_value(key, value); end

  # source://newrelic_rpm//lib/new_relic/environment_report.rb#118
  def record_value(data, key, value); end

  # source://newrelic_rpm//lib/new_relic/environment_report.rb#131
  def rescue_initialize(key, exception); end

  class << self
    # source://newrelic_rpm//lib/new_relic/environment_report.rb#34
    def registered_reporters; end

    # allow the logic to be swapped out in tests
    #
    # source://newrelic_rpm//lib/new_relic/environment_report.rb#39
    def registered_reporters=(logic); end

    # This is the main interface for registering logic that should be included
    # in the Environment Report. For example:
    #
    # EnvironmentReport.report_on "Day of week" do
    #   Time.now.strftime("%A")
    # end
    #
    # The passed blocks will be run in EnvironmentReport instances on #initialize.
    #
    # Errors raised in passed blocks will be handled and logged at debug, so it
    # is safe to report on things that may not work in certain environments.
    #
    # The blocks should only return strings or arrays full of strings.  Falsey
    # values will be ignored.
    #
    # source://newrelic_rpm//lib/new_relic/environment_report.rb#30
    def report_on(key, &block); end
  end
end

# source://newrelic_rpm//lib/new_relic/constants.rb#18
NewRelic::FORMAT_NON_RACK = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/constants.rb#19
NewRelic::FORMAT_RACK = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/constants.rb#14
NewRelic::HTTP = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/constants.rb#15
NewRelic::HTTPS = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/constants.rb#36
NewRelic::HTTP_NEWRELIC_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/constants.rb#34
NewRelic::HTTP_TRACEPARENT_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/constants.rb#35
NewRelic::HTTP_TRACESTATE_KEY = T.let(T.unsafe(nil), String)

# A singleton for shared generic helper methods
#
# source://newrelic_rpm//lib/new_relic/helper.rb#13
module NewRelic::Helper
  extend ::NewRelic::Helper

  # Confirm a string is correctly encoded,
  # If not force the encoding to ASCII-8BIT (binary)
  #
  # source://newrelic_rpm//lib/new_relic/helper.rb#18
  def correctly_encoded(string); end

  # TODO: Open3 defers the actual execution of a binary to Process.spawn,
  #       which will raise an Errno::ENOENT exception for a file that
  #       cannot be found. We might want to take the time to evaluate
  #       relying on that Process.spawn behavior instead of checking for
  #       existence ourselves. We'd need to see what it does, how efficient
  #       it is, if it differs in functionality between Ruby versions and
  #       operating systems, etc.
  #
  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/helper.rb#77
  def executable_in_path?(executable); end

  # source://newrelic_rpm//lib/new_relic/helper.rb#26
  def instance_method_visibility(klass, method_name); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/helper.rb#36
  def instance_methods_include?(klass, method_name); end

  # source://newrelic_rpm//lib/new_relic/helper.rb#49
  def run_command(command); end

  # source://newrelic_rpm//lib/new_relic/helper.rb#45
  def time_to_millis(time); end
end

# source://newrelic_rpm//lib/new_relic/language_support.rb#6
module NewRelic::LanguageSupport
  extend ::NewRelic::LanguageSupport

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/language_support.rb#90
  def bundled_gem?(gem_name); end

  # source://newrelic_rpm//lib/new_relic/language_support.rb#76
  def camelize(string); end

  # source://newrelic_rpm//lib/new_relic/language_support.rb#81
  def camelize_with_first_letter_downcased(string); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/language_support.rb#10
  def can_fork?; end

  # TODO: OLD RUBIES - RUBY_VERSION < 2.6
  #
  # Ruby 2.6 introduced an improved version of `Object.const_get` that
  # respects the full namespace of the input and doesn't just grab the first
  # constant matching the string to the right of the last '::'.
  # Once we drop support for Ruby 2.5 and below, the only value this custom
  # method will provide beyond `Object.const_get` itself is to automatically
  # catch NameError.
  #
  # see: https://github.com/rails/rails/commit/7057ccf6565c1cb5354c1906880119276a9d15c0
  #
  # With Ruby 2.6+, this method can be defined like so:
  # def constantize(constant_as_string_or_symbol)
  #   Object.const_get(constant_as_string_or_symbol)
  # rescue NameError
  # end
  #
  # source://newrelic_rpm//lib/new_relic/language_support.rb#55
  def constantize(const_name); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/language_support.rb#21
  def gc_profiler_enabled?; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/language_support.rb#17
  def gc_profiler_usable?; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/language_support.rb#34
  def jruby?; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/language_support.rb#25
  def object_space_usable?; end

  # source://newrelic_rpm//lib/new_relic/language_support.rb#86
  def snakeize(string); end
end

# This class is responsible for determining the 'dispatcher' in use by the
# current process. The dispatcher might be a recognized web server such as
# unicorn or passenger, a background job processor such as resque or sidekiq,
# or nil for unknown.
#
# Dispatcher detection is best-effort, and serves two purposes:
#
# 1. For some dispatchers, we need to apply specific workarounds in order for
#    the agent to work correctly.
# 2. When reading logs, since multiple processes on a given host might write
#    into the same log, it's useful to be able to identify what kind of
#    process a given PID mapped to.
#
# Overriding the dispatcher is possible via the NEW_RELIC_DISPATCHER
# environment variable, but this should not generally be necessary unless
# you're on a dispatcher that falls into category 1 above, and our detection
# logic isn't working correctly.
#
# If the environment can't be determined, it will be set to nil.
#
# NewRelic::LocalEnvironment should be accessed through NewRelic::Control#local_env (via the NewRelic::Control singleton).
#
# source://newrelic_rpm//lib/new_relic/local_environment.rb#30
class NewRelic::LocalEnvironment
  # @return [LocalEnvironment] a new instance of LocalEnvironment
  #
  # source://newrelic_rpm//lib/new_relic/local_environment.rb#36
  def initialize; end

  # source://newrelic_rpm//lib/new_relic/local_environment.rb#31
  def discovered_dispatcher; end

  # source://newrelic_rpm//lib/new_relic/local_environment.rb#208
  def executable; end

  # Runs through all the objects in ObjectSpace to find the first one that
  # match the provided class
  #
  # source://newrelic_rpm//lib/new_relic/local_environment.rb#50
  def find_class_in_object_space(klass); end

  # outputs a human-readable description
  #
  # source://newrelic_rpm//lib/new_relic/local_environment.rb#204
  def to_s; end

  private

  # source://newrelic_rpm//lib/new_relic/local_environment.rb#150
  def check_for_delayed_job; end

  # source://newrelic_rpm//lib/new_relic/local_environment.rb#143
  def check_for_falcon; end

  # source://newrelic_rpm//lib/new_relic/local_environment.rb#116
  def check_for_fastcgi; end

  # source://newrelic_rpm//lib/new_relic/local_environment.rb#91
  def check_for_glassfish; end

  # source://newrelic_rpm//lib/new_relic/local_environment.rb#189
  def check_for_litespeed; end

  # this case covers starting by mongrel_rails
  #
  # source://newrelic_rpm//lib/new_relic/local_environment.rb#123
  def check_for_mongrel; end

  # source://newrelic_rpm//lib/new_relic/local_environment.rb#195
  def check_for_passenger; end

  # source://newrelic_rpm//lib/new_relic/local_environment.rb#137
  def check_for_puma; end

  # source://newrelic_rpm//lib/new_relic/local_environment.rb#156
  def check_for_resque; end

  # source://newrelic_rpm//lib/new_relic/local_environment.rb#169
  def check_for_sidekiq; end

  # source://newrelic_rpm//lib/new_relic/local_environment.rb#175
  def check_for_thin; end

  # source://newrelic_rpm//lib/new_relic/local_environment.rb#84
  def check_for_torquebox; end

  # source://newrelic_rpm//lib/new_relic/local_environment.rb#100
  def check_for_trinidad; end

  # source://newrelic_rpm//lib/new_relic/local_environment.rb#129
  def check_for_unicorn; end

  # source://newrelic_rpm//lib/new_relic/local_environment.rb#110
  def check_for_webrick; end

  # source://newrelic_rpm//lib/new_relic/local_environment.rb#61
  def discover_dispatcher; end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/local_environment.rb#106
  def jruby_rack?; end
end

# source://newrelic_rpm//lib/new_relic/constants.rb#39
NewRelic::MAX_RETRY_PERIOD = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/metric_data.rb#8
class NewRelic::MetricData
  include ::NewRelic::Coerce

  # @return [MetricData] a new instance of MetricData
  #
  # source://newrelic_rpm//lib/new_relic/metric_data.rb#16
  def initialize(metric_spec, stats); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/metric_data.rb#22
  def eql?(o); end

  # source://newrelic_rpm//lib/new_relic/metric_data.rb#26
  def hash; end

  # source://newrelic_rpm//lib/new_relic/metric_data.rb#30
  def inspect; end

  # a NewRelic::MetricSpec object
  #
  # source://newrelic_rpm//lib/new_relic/metric_data.rb#10
  def metric_spec; end

  # assigns a new metric spec, and retains the old metric spec as
  #
  # source://newrelic_rpm//lib/new_relic/metric_data.rb#36
  def metric_spec=(new_spec); end

  # source://newrelic_rpm//lib/new_relic/metric_data.rb#41
  def original_spec; end

  # a NewRelic::Agent::Stats object
  #
  # source://newrelic_rpm//lib/new_relic/metric_data.rb#12
  def stats; end

  # a NewRelic::Agent::Stats object
  #
  # source://newrelic_rpm//lib/new_relic/metric_data.rb#12
  def stats=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/metric_data.rb#45
  def to_collector_array(encoder = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/metric_data.rb#50
  def to_json(*a); end

  # source://newrelic_rpm//lib/new_relic/metric_data.rb#54
  def to_s; end

  private

  # source://newrelic_rpm//lib/new_relic/metric_data.rb#60
  def stats_collector_array(stat_key); end
end

# this struct uniquely defines a metric, optionally inside
# the call scope of another metric
#
# source://newrelic_rpm//lib/new_relic/metric_spec.rb#7
class NewRelic::MetricSpec
  # @return [MetricSpec] a new instance of MetricSpec
  #
  # source://newrelic_rpm//lib/new_relic/metric_spec.rb#15
  def initialize(metric_name = T.unsafe(nil), metric_scope = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/metric_spec.rb#60
  def <=>(o); end

  # source://newrelic_rpm//lib/new_relic/metric_spec.rb#33
  def ==(o); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/metric_spec.rb#37
  def eql?(o); end

  # source://newrelic_rpm//lib/new_relic/metric_spec.rb#41
  def hash; end

  # source://newrelic_rpm//lib/new_relic/metric_spec.rb#51
  def inspect; end

  # Returns the value of attribute name.
  #
  # source://newrelic_rpm//lib/new_relic/metric_spec.rb#8
  def name; end

  # Returns the value of attribute scope.
  #
  # source://newrelic_rpm//lib/new_relic/metric_spec.rb#8
  def scope; end

  # source://newrelic_rpm//lib/new_relic/metric_spec.rb#55
  def to_json(*a); end

  # source://newrelic_rpm//lib/new_relic/metric_spec.rb#45
  def to_s; end
end

# source://newrelic_rpm//lib/new_relic/metric_spec.rb#13
NewRelic::MetricSpec::EMPTY_SCOPE = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/metric_spec.rb#12
NewRelic::MetricSpec::LENGTH_RANGE = T.let(T.unsafe(nil), Range)

# the maximum length of a metric name or metric scope
#
# source://newrelic_rpm//lib/new_relic/metric_spec.rb#11
NewRelic::MetricSpec::MAX_LENGTH = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/constants.rb#21
NewRelic::NEWRELIC_KEY = T.let(T.unsafe(nil), String)

# This class encapsulates an error that was noticed by New Relic in a managed app.
#
# source://newrelic_rpm//lib/new_relic/noticed_error.rb#10
class NewRelic::NoticedError
  include ::NewRelic::Coerce
  extend ::NewRelic::CollectionHelper

  # @return [NoticedError] a new instance of NoticedError
  #
  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#37
  def initialize(path, exception, timestamp = T.unsafe(nil), expected = T.unsafe(nil)); end

  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#66
  def ==(other); end

  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#166
  def agent_attributes; end

  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#162
  def append_attributes(outgoing_params, outgoing_key, source_attributes); end

  # Returns the value of attribute attributes.
  #
  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#13
  def attributes; end

  # Sets the attribute attributes
  #
  # @param value the value to set the attribute attributes to.
  #
  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#13
  def attributes=(_arg0); end

  # Returns the value of attribute attributes_from_notice_error.
  #
  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#13
  def attributes_from_notice_error; end

  # Sets the attribute attributes_from_notice_error
  #
  # @param value the value to set the attribute attributes_from_notice_error to.
  #
  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#13
  def attributes_from_notice_error=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#106
  def base_parameters; end

  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#148
  def build_agent_attributes(merged_attributes); end

  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#140
  def build_error_attributes; end

  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#154
  def build_intrinsic_attributes; end

  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#170
  def custom_attributes; end

  # Returns the value of attribute error_group.
  #
  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#18
  def error_group; end

  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#194
  def error_group=(name); end

  # Returns the value of attribute exception_class_name.
  #
  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#13
  def exception_class_name; end

  # Sets the attribute exception_class_name
  #
  # @param value the value to set the attribute exception_class_name to.
  #
  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#13
  def exception_class_name=(_arg0); end

  # Returns the value of attribute exception_id.
  #
  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#18
  def exception_id; end

  # Returns the value of attribute expected.
  #
  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#13
  def expected; end

  # Sets the attribute expected
  #
  # @param value the value to set the attribute expected to.
  #
  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#13
  def expected=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#178
  def extract_class_name_and_message_from(exception); end

  # Returns the value of attribute file_name.
  #
  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#13
  def file_name; end

  # Sets the attribute file_name
  #
  # @param value the value to set the attribute file_name to.
  #
  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#13
  def file_name=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#174
  def intrinsic_attributes; end

  # Returns the value of attribute is_internal.
  #
  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#18
  def is_internal; end

  # Returns the value of attribute line_number.
  #
  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#13
  def line_number; end

  # Sets the attribute line_number
  #
  # @param value the value to set the attribute line_number to.
  #
  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#13
  def line_number=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#133
  def merge_custom_attributes_from_notice_error(merged_attributes); end

  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#126
  def merge_custom_attributes_from_transaction(merged_attributes); end

  # We can get custom attributes from two sources--the transaction, which we
  # hold in @attributes, or passed options to notice_error which show up in
  # in our Attributes class for consistent handling
  #
  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#119
  def merged_custom_attributes(merged_attributes); end

  # Returns the value of attribute message.
  #
  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#13
  def message; end

  # Sets the attribute message
  #
  # @param value the value to set the attribute message to.
  #
  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#13
  def message=(_arg0); end

  # Returns the value of attribute path.
  #
  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#13
  def path; end

  # Sets the attribute path
  #
  # @param value the value to set the attribute path to.
  #
  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#13
  def path=(_arg0); end

  # Note that we process attributes lazily and store the result. This is because
  # there is a possibility that a noticed error will be discarded and not sent back
  # as a traced error or TransactionError.
  #
  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#95
  def processed_attributes; end

  # Returns the value of attribute request_port.
  #
  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#13
  def request_port; end

  # Sets the attribute request_port
  #
  # @param value the value to set the attribute request_port to.
  #
  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#13
  def request_port=(_arg0); end

  # Returns the value of attribute request_uri.
  #
  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#13
  def request_uri; end

  # Sets the attribute request_uri
  #
  # @param value the value to set the attribute request_uri to.
  #
  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#13
  def request_uri=(_arg0); end

  # Returns the value of attribute stack_trace.
  #
  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#13
  def stack_trace; end

  # Sets the attribute stack_trace
  #
  # @param value the value to set the attribute stack_trace to.
  #
  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#13
  def stack_trace=(_arg0); end

  # Returns the value of attribute timestamp.
  #
  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#13
  def timestamp; end

  # Sets the attribute timestamp
  #
  # @param value the value to set the attribute timestamp to.
  #
  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#13
  def timestamp=(_arg0); end

  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#82
  def to_collector_array(encoder = T.unsafe(nil)); end

  # Returns the value of attribute transaction_id.
  #
  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#13
  def transaction_id; end

  # Sets the attribute transaction_id
  #
  # @param value the value to set the attribute transaction_id to.
  #
  # source://newrelic_rpm//lib/new_relic/noticed_error.rb#13
  def transaction_id=(_arg0); end

  class << self
    # source://newrelic_rpm//lib/new_relic/noticed_error.rb#74
    def passes_message_allowlist(exception_class); end
  end
end

# source://newrelic_rpm//lib/new_relic/noticed_error.rb#25
NewRelic::NoticedError::AGENT_ATTRIBUTES = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/noticed_error.rb#30
NewRelic::NoticedError::AGENT_ATTRIBUTE_ERROR_GROUP = T.let(T.unsafe(nil), Symbol)

# source://newrelic_rpm//lib/new_relic/noticed_error.rb#28
NewRelic::NoticedError::DESTINATION = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/noticed_error.rb#34
NewRelic::NoticedError::ERROR_CLASS_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/noticed_error.rb#35
NewRelic::NoticedError::ERROR_EXPECTED_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/noticed_error.rb#33
NewRelic::NoticedError::ERROR_MESSAGE_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/noticed_error.rb#32
NewRelic::NoticedError::ERROR_PREFIX_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/noticed_error.rb#26
NewRelic::NoticedError::INTRINSIC_ATTRIBUTES = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/noticed_error.rb#22
NewRelic::NoticedError::NIL_ERROR_MESSAGE = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/noticed_error.rb#20
NewRelic::NoticedError::STRIPPED_EXCEPTION_REPLACEMENT_MESSAGE = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/noticed_error.rb#21
NewRelic::NoticedError::UNKNOWN_ERROR_CLASS_NAME = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/noticed_error.rb#24
NewRelic::NoticedError::USER_ATTRIBUTES = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/constants.rb#8
NewRelic::PRIORITY_PRECISION = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/constants.rb#42
NewRelic::ROOT = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/newrelic_rpm.rb#22
class NewRelic::Railtie < ::Rails::Railtie; end

# source://newrelic_rpm//lib/new_relic/constants.rb#41
NewRelic::SLASH = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/constants.rb#32
NewRelic::STANDARD_OUT = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/supportability_helper.rb#6
module NewRelic::SupportabilityHelper
  # source://newrelic_rpm//lib/new_relic/supportability_helper.rb#65
  def record_api_supportability_metric(method_name); end

  # @return [Boolean]
  #
  # source://newrelic_rpm//lib/new_relic/supportability_helper.rb#74
  def valid_api_argument_class?(arg, name, klass); end
end

# pre-instantiate these strings as they may be used multiple times per
# transaction, just to eke out a bit less performance hit
#
# source://newrelic_rpm//lib/new_relic/supportability_helper.rb#12
NewRelic::SupportabilityHelper::API_SUPPORTABILITY_METRICS = T.let(T.unsafe(nil), Hash)

# source://newrelic_rpm//lib/new_relic/supportability_helper.rb#7
NewRelic::SupportabilityHelper::API_SUPPORTABILITY_PREFIX = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/constants.rb#29
NewRelic::TRACEPARENT_KEY = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/constants.rb#30
NewRelic::TRACESTATE_KEY = T.let(T.unsafe(nil), String)

# This class allows the current transaction to be passed to a Thread so that nested segments can be created from the operations performed within the Thread's block.
# To have the New Relic Ruby agent automatically trace all of your applications threads,
# enable the +instrumentation.thread.tracing+ configuration option in your newrelic.yml.
#
# Note: disabling the configuration option +instrumentation.thread+ while using this class can cause incorrectly nested spans.
#
# @api public
#
# source://newrelic_rpm//lib/new_relic/traced_thread.rb#14
class NewRelic::TracedThread < ::Thread
  # Creates a new Thread whose work will be traced by New Relic.
  # Use this class as a replacement for the native Thread class.
  # Example: Instead of using +Thread.new+, use:
  #
  #     NewRelic::TracedThread.new { execute_some_code }
  #
  # @api public
  # @return [TracedThread] a new instance of TracedThread
  #
  # source://newrelic_rpm//lib/new_relic/traced_thread.rb#23
  def initialize(*args, &block); end

  # @api public
  #
  # source://newrelic_rpm//lib/new_relic/traced_thread.rb#29
  def create_traced_block(&block); end
end

# source://newrelic_rpm//lib/new_relic/constants.rb#16
NewRelic::UNKNOWN = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/version.rb#7
module NewRelic::VERSION; end

# source://newrelic_rpm//lib/new_relic/version.rb#8
NewRelic::VERSION::MAJOR = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/version.rb#9
NewRelic::VERSION::MINOR = T.let(T.unsafe(nil), Integer)

# source://newrelic_rpm//lib/new_relic/version.rb#12
NewRelic::VERSION::STRING = T.let(T.unsafe(nil), String)

# source://newrelic_rpm//lib/new_relic/version.rb#10
NewRelic::VERSION::TINY = T.let(T.unsafe(nil), Integer)
