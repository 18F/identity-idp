# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `net-ssh` gem.
# Please instead update this file by running `bin/tapioca gem net-ssh`.


# Net::SSH is a library for interacting, programmatically, with remote
# processes via the SSH2 protocol. Sessions are always initiated via
# Net::SSH.start. From there, a program interacts with the new SSH session
# via the convenience methods on Net::SSH::Connection::Session, by opening
# and interacting with new channels (Net::SSH::Connection:Session#open_channel
# and Net::SSH::Connection::Channel), or by forwarding local and/or
# remote ports through the connection (Net::SSH::Service::Forward).
#
# The SSH protocol is very event-oriented. Requests are sent from the client
# to the server, and are answered asynchronously. This gives great flexibility
# (since clients can have multiple requests pending at a time), but it also
# adds complexity. Net::SSH tries to manage this complexity by providing
# some simpler methods of synchronous communication (see Net::SSH::Connection::Session#exec!).
#
# In general, though, and if you want to do anything more complicated than
# simply executing commands and capturing their output, you'll need to use
# channels (Net::SSH::Connection::Channel) to build state machines that are
# executed while the event loop runs (Net::SSH::Connection::Session#loop).
#
# Net::SSH::Connection::Session and Net::SSH::Connection::Channel have more
# information about this technique.
#
# = "Um, all I want to do is X, just show me how!"
#
# == X == "execute a command and capture the output"
#
#   Net::SSH.start("host", "user", password: "password") do |ssh|
#     result = ssh.exec!("ls -l")
#     puts result
#   end
#
# == X == "forward connections on a local port to a remote host"
#
#   Net::SSH.start("host", "user", password: "password") do |ssh|
#     ssh.forward.local(1234, "www.google.com", 80)
#     ssh.loop { true }
#   end
#
# == X == "forward connections on a remote port to the local host"
#
#   Net::SSH.start("host", "user", password: "password") do |ssh|
#     ssh.forward.remote(80, "www.google.com", 1234)
#     ssh.loop { true }
#   end
#
# source://net-ssh//lib/net/ssh/config.rb#2
module Net::SSH
  class << self
    # source://net-ssh//lib/net/ssh.rb#291
    def assign_defaults(options); end

    # Returns a hash of the configuration options for the given host, as read
    # from the SSH configuration file(s). If +use_ssh_config+ is true (the
    # default), this will load configuration from both ~/.ssh/config and
    # /etc/ssh_config. If +use_ssh_config+ is nil or false, nothing will be
    # loaded (and an empty hash returned). Otherwise, +use_ssh_config+ may
    # be a file name (or array of file names) of SSH configuration file(s)
    # to read.
    #
    # See Net::SSH::Config for the full description of all supported options.
    #
    # source://net-ssh//lib/net/ssh.rb#281
    def configuration_for(host, use_ssh_config); end

    # The standard means of starting a new SSH connection. When used with a
    # block, the connection will be closed when the block terminates, otherwise
    # the connection will just be returned. The yielded (or returned) value
    # will be an instance of Net::SSH::Connection::Session (q.v.). (See also
    # Net::SSH::Connection::Channel and Net::SSH::Service::Forward.)
    #
    #   Net::SSH.start("host", "user") do |ssh|
    #     ssh.exec! "cp /some/file /another/location"
    #     hostname = ssh.exec!("hostname")
    #
    #     ssh.open_channel do |ch|
    #       ch.exec "sudo -p 'sudo password: ' ls" do |ch, success|
    #         abort "could not execute sudo ls" unless success
    #
    #         ch.on_data do |ch, data|
    #           print data
    #           if data =~ /sudo password: /
    #             ch.send_data("password\n")
    #           end
    #         end
    #       end
    #     end
    #
    #     ssh.loop
    #   end
    #
    # This method accepts the following options (all are optional):
    #
    # * :auth_methods => an array of authentication methods to try
    # * :bind_address => the IP address on the connecting machine to use in
    #   establishing connection. (:bind_address is discarded if :proxy
    #   is set.)
    # * :check_host_ip => Also ckeck IP address when connecting to remote host.
    #   Defaults to +true+.
    # * :compression => the compression algorithm to use, or +true+ to use
    #   whatever is supported.
    # * :compression_level => the compression level to use when sending data
    # * :config => set to +true+ to load the default OpenSSH config files
    #   (~/.ssh/config, /etc/ssh_config), or to +false+ to not load them, or to
    #   a file-name (or array of file-names) to load those specific configuration
    #   files. Defaults to +true+.
    # * :encryption => the encryption cipher (or ciphers) to use
    # * :forward_agent => set to true if you want the SSH agent connection to
    #   be forwarded
    # * :known_hosts => a custom object holding known hosts records.
    #   It must implement #search_for and add in a similiar manner as KnownHosts.
    # * :global_known_hosts_file => the location of the global known hosts
    #   file. Set to an array if you want to specify multiple global known
    #   hosts files. Defaults to %w(/etc/ssh/ssh_known_hosts /etc/ssh/ssh_known_hosts2).
    # * :hmac => the hmac algorithm (or algorithms) to use
    # * :host_key => the host key algorithm (or algorithms) to use
    # * :host_key_alias => the host name to use when looking up or adding a
    #   host to a known_hosts dictionary file
    # * :host_name => the real host name or IP to log into. This is used
    #   instead of the +host+ parameter, and is primarily only useful when
    #   specified in an SSH configuration file. It lets you specify an
    #   "alias", similarly to adding an entry in /etc/hosts but without needing
    #   to modify /etc/hosts.
    # * :keepalive => set to +true+ to send a keepalive packet to the SSH server
    #   when there's no traffic between the SSH server and Net::SSH client for
    #   the keepalive_interval seconds. Defaults to +false+.
    # * :keepalive_interval => the interval seconds for keepalive.
    #   Defaults to +300+ seconds.
    # * :keepalive_maxcount => the maximun number of keepalive packet miss allowed.
    #   Defaults to 3
    # * :kex => the key exchange algorithm (or algorithms) to use
    # * :keys => an array of file names of private keys to use for publickey
    #   and hostbased authentication
    # * :keycerts => an array of file names of key certificates to use
    #    with publickey authentication
    # * :key_data => an array of strings, with each element of the array being
    #   a raw private key in PEM format.
    # * :keys_only => set to +true+ to use only private keys from +keys+ and
    #   +key_data+ parameters, even if ssh-agent offers more identities. This
    #   option is intended for situations where ssh-agent offers many different
    #   identites.
    # * :logger => the logger instance to use when logging
    # * :max_pkt_size => maximum size we tell the other side that is supported per
    #   packet. Default is 0x8000 (32768 bytes). Increase to 0x10000 (65536 bytes)
    #   for better performance if your SSH server supports it (most do).
    # * :max_win_size => maximum size we tell the other side that is supported for
    #   the window.
    # * :non_interactive => set to true if your app is non interactive and prefers
    #   authentication failure vs password prompt. Non-interactive applications
    #   should set it to true to prefer failing a password/etc auth methods vs.
    #   asking for password.
    # * :paranoid => deprecated alias for :verify_host_key
    # * :passphrase => the passphrase to use when loading a private key (default
    #   is +nil+, for no passphrase)
    # * :password => the password to use to login
    # * :port => the port to use when connecting to the remote host
    # * :properties => a hash of key/value pairs to add to the new connection's
    #   properties (see Net::SSH::Connection::Session#properties)
    # * :proxy => a proxy instance (see Proxy) to use when connecting
    # * :rekey_blocks_limit => the max number of blocks to process before rekeying
    # * :rekey_limit => the max number of bytes to process before rekeying
    # * :rekey_packet_limit => the max number of packets to process before rekeying
    # * :send_env => an array of local environment variable names to export to the
    #   remote environment. Names may be given as String or Regexp.
    # * :set_env => a hash of environment variable names and values to set to the
    #   remote environment. Override the ones if specified in +send_env+.
    # * :timeout => how long to wait for the initial connection to be made
    # * :user => the user name to log in as; this overrides the +user+
    #   parameter, and is primarily only useful when provided via an SSH
    #   configuration file.
    # * :remote_user => used for substitution into the '%r' part of a ProxyCommand
    # * :user_known_hosts_file => the location of the user known hosts file.
    #   Set to an array to specify multiple user known hosts files.
    #   Defaults to %w(~/.ssh/known_hosts ~/.ssh/known_hosts2).
    # * :use_agent => Set false to disable the use of ssh-agent. Defaults to
    #   true
    # * :verbose => how verbose to be (Logger verbosity constants, Logger::DEBUG
    #   is very verbose, Logger::FATAL is all but silent). Logger::FATAL is the
    #   default. The symbols :debug, :info, :warn, :error, and :fatal are also
    #   supported and are translated to the corresponding Logger constant.
    # * :append_all_supported_algorithms => set to +true+ to append all supported
    #   algorithms by net-ssh. Was the default behaviour until 2.10
    # * :number_of_password_prompts => Number of prompts for the password
    #   authentication method defaults to 3 set to 0 to disable prompt for
    #   password auth method
    # * :password_prompt => a custom prompt object with ask method. See Net::SSH::Prompt
    #
    # * :agent_socket_factory => enables the user to pass a lambda/block that will serve as the socket factory
    #    Net::SSH.start(host,user,agent_socket_factory: ->{ UNIXSocket.open('/foo/bar') })
    #    example: ->{ UNIXSocket.open('/foo/bar')}
    # * :verify_host_key => specify how strict host-key verification should be.
    #   In order of increasing strictness:
    #   * :never (very insecure) ::Net::SSH::Verifiers::Never
    #   * :accept_new_or_local_tunnel (insecure) ::Net::SSH::Verifiers::AcceptNewOrLocalTunnel
    #   * :accept_new (insecure) ::Net::SSH::Verifiers::AcceptNew
    #   * :always (secure) ::Net::SSH::Verifiers::Always
    #   You can also provide an own Object which responds to +verify+. The argument
    #   given to +verify+ is a hash consisting of the +:key+, the +:key_blob+,
    #   the +:fingerprint+ and the +:session+. Returning true accepts the host key,
    #   returning false declines it and closes the connection.
    # * :fingerprint_hash => 'MD5' or 'SHA256', defaults to 'SHA256'
    # If +user+ parameter is nil it defaults to USER from ssh_config, or
    # local username
    #
    # source://net-ssh//lib/net/ssh.rb#218
    def start(host, user = T.unsafe(nil), options = T.unsafe(nil), &block); end

    private

    # source://net-ssh//lib/net/ssh.rb#304
    def _sanitize_options(options); end

    # source://net-ssh//lib/net/ssh.rb#313
    def _support_deprecated_option_paranoid(options); end
  end
end

# source://net-ssh//lib/net/ssh/authentication/pub_key_fingerprint.rb#5
module Net::SSH::Authentication; end

# This class implements a simple client for the ssh-agent protocol. It
# does not implement any specific protocol, but instead copies the
# behavior of the ssh-agent functions in the OpenSSH library (3.8).
#
# This means that although it behaves like a SSH1 client, it also has
# some SSH2 functionality (like signing data).
#
# source://net-ssh//lib/net/ssh/authentication/agent.rb#25
class Net::SSH::Authentication::Agent
  include ::Net::SSH::Loggable

  # Creates a new Agent object, using the optional logger instance to
  # report status.
  #
  # @return [Agent] a new instance of Agent
  #
  # source://net-ssh//lib/net/ssh/authentication/agent.rb#74
  def initialize(logger = T.unsafe(nil)); end

  # Adds the private key with comment to the agent.
  # If lifetime is given, the key will automatically be removed after lifetime
  # seconds.
  # If confirm is true, confirmation will be required for each agent signing
  # operation.
  #
  # @raise [AgentError]
  #
  # source://net-ssh//lib/net/ssh/authentication/agent.rb#166
  def add_identity(priv_key, comment, lifetime: T.unsafe(nil), confirm: T.unsafe(nil)); end

  # Closes this socket. This agent reference is no longer able to
  # query the agent.
  #
  # source://net-ssh//lib/net/ssh/authentication/agent.rb#146
  def close; end

  # Connect to the agent process using the socket factory and socket name
  # given by the attribute writers. If the agent on the other end of the
  # socket reports that it is an SSH2-compatible agent, this will fail
  # (it only supports the ssh-agent distributed by OpenSSH).
  #
  # source://net-ssh//lib/net/ssh/authentication/agent.rb#82
  def connect!(agent_socket_factory = T.unsafe(nil), identity_agent = T.unsafe(nil)); end

  # Return an array of all identities (public keys) known to the agent.
  # Each key returned is augmented with a +comment+ property which is set
  # to the comment returned by the agent for that key.
  #
  # @raise [AgentError]
  #
  # source://net-ssh//lib/net/ssh/authentication/agent.rb#118
  def identities; end

  # Attempts to negotiate the SSH agent protocol version. Raises an error
  # if the version could not be negotiated successfully.
  #
  # @raise [AgentNotAvailable]
  #
  # source://net-ssh//lib/net/ssh/authentication/agent.rb#103
  def negotiate!; end

  # Removes all identities from the agent.
  #
  # @raise [AgentError]
  #
  # source://net-ssh//lib/net/ssh/authentication/agent.rb#187
  def remove_all_identities; end

  # Removes key from the agent.
  #
  # @raise [AgentError]
  #
  # source://net-ssh//lib/net/ssh/authentication/agent.rb#181
  def remove_identity(key); end

  # Using the agent and the given public key, sign the given data. The
  # signature is returned in SSH2 format.
  #
  # @raise [AgentError]
  #
  # source://net-ssh//lib/net/ssh/authentication/agent.rb#152
  def sign(key, data, flags = T.unsafe(nil)); end

  # The underlying socket being used to communicate with the SSH agent.
  #
  # source://net-ssh//lib/net/ssh/authentication/agent.rb#61
  def socket; end

  private

  # Returns +true+ if the parameter indicates a "failure" response from
  # the agent, and +false+ otherwise.
  #
  # source://net-ssh//lib/net/ssh/authentication/agent.rb#226
  def agent_failed(type); end

  # source://net-ssh//lib/net/ssh/authentication/agent.rb#232
  def blob_for_add(priv_key); end

  # Read the next packet from the agent. This will return a two-part
  # tuple consisting of the packet type, and the packet's body (which
  # is returned as a Net::SSH::Buffer).
  #
  # source://net-ssh//lib/net/ssh/authentication/agent.rb#209
  def read_packet; end

  # Send the given packet and return the subsequent reply from the agent.
  # (See #send_packet and #read_packet).
  #
  # source://net-ssh//lib/net/ssh/authentication/agent.rb#219
  def send_and_wait(type, *args); end

  # Send a new packet of the given type, with the associated data.
  #
  # source://net-ssh//lib/net/ssh/authentication/agent.rb#199
  def send_packet(type, *args); end

  # source://net-ssh//lib/net/ssh/authentication/agent.rb#194
  def unix_socket_class; end

  class << self
    # Instantiates a new agent object, connects to a running SSH agent,
    # negotiates the agent protocol version, and returns the agent object.
    #
    # source://net-ssh//lib/net/ssh/authentication/agent.rb#65
    def connect(logger = T.unsafe(nil), agent_socket_factory = T.unsafe(nil), identity_agent = T.unsafe(nil)); end
  end
end

# A simple module for extending keys, to allow comments to be specified
# for them.
#
# source://net-ssh//lib/net/ssh/authentication/agent.rb#30
module Net::SSH::Authentication::Agent::Comment
  # Returns the value of attribute comment.
  #
  # source://net-ssh//lib/net/ssh/authentication/agent.rb#31
  def comment; end

  # Sets the attribute comment
  #
  # @param value the value to set the attribute comment to.
  #
  # source://net-ssh//lib/net/ssh/authentication/agent.rb#31
  def comment=(_arg0); end
end

# source://net-ssh//lib/net/ssh/authentication/agent.rb#39
Net::SSH::Authentication::Agent::SSH2_AGENT_ADD_IDENTITY = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/authentication/agent.rb#42
Net::SSH::Authentication::Agent::SSH2_AGENT_ADD_ID_CONSTRAINED = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/authentication/agent.rb#43
Net::SSH::Authentication::Agent::SSH2_AGENT_FAILURE = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/authentication/agent.rb#36
Net::SSH::Authentication::Agent::SSH2_AGENT_IDENTITIES_ANSWER = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/authentication/agent.rb#41
Net::SSH::Authentication::Agent::SSH2_AGENT_REMOVE_ALL_IDENTITIES = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/authentication/agent.rb#40
Net::SSH::Authentication::Agent::SSH2_AGENT_REMOVE_IDENTITY = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/authentication/agent.rb#35
Net::SSH::Authentication::Agent::SSH2_AGENT_REQUEST_IDENTITIES = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/authentication/agent.rb#34
Net::SSH::Authentication::Agent::SSH2_AGENT_REQUEST_VERSION = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/authentication/agent.rb#37
Net::SSH::Authentication::Agent::SSH2_AGENT_SIGN_REQUEST = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/authentication/agent.rb#38
Net::SSH::Authentication::Agent::SSH2_AGENT_SIGN_RESPONSE = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/authentication/agent.rb#44
Net::SSH::Authentication::Agent::SSH2_AGENT_VERSION_RESPONSE = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/authentication/agent.rb#55
Net::SSH::Authentication::Agent::SSH_AGENT_CONSTRAIN_CONFIRM = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/authentication/agent.rb#54
Net::SSH::Authentication::Agent::SSH_AGENT_CONSTRAIN_LIFETIME = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/authentication/agent.rb#51
Net::SSH::Authentication::Agent::SSH_AGENT_FAILURE = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/authentication/agent.rb#48
Net::SSH::Authentication::Agent::SSH_AGENT_REQUEST_RSA_IDENTITIES = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/authentication/agent.rb#49
Net::SSH::Authentication::Agent::SSH_AGENT_RSA_IDENTITIES_ANSWER1 = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/authentication/agent.rb#50
Net::SSH::Authentication::Agent::SSH_AGENT_RSA_IDENTITIES_ANSWER2 = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/authentication/agent.rb#57
Net::SSH::Authentication::Agent::SSH_AGENT_RSA_SHA2_256 = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/authentication/agent.rb#58
Net::SSH::Authentication::Agent::SSH_AGENT_RSA_SHA2_512 = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/authentication/agent.rb#52
Net::SSH::Authentication::Agent::SSH_AGENT_SUCCESS = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/authentication/agent.rb#46
Net::SSH::Authentication::Agent::SSH_COM_AGENT2_FAILURE = T.let(T.unsafe(nil), Integer)

# Class for representing agent-specific errors.
#
# source://net-ssh//lib/net/ssh/authentication/agent.rb#15
class Net::SSH::Authentication::AgentError < ::Net::SSH::Exception; end

# An exception for indicating that the SSH agent is not available.
#
# source://net-ssh//lib/net/ssh/authentication/agent.rb#17
class Net::SSH::Authentication::AgentNotAvailable < ::Net::SSH::Authentication::AgentError; end

# Class for representing an SSH certificate.
#
# http://cvsweb.openbsd.org/cgi-bin/cvsweb/~checkout~/src/usr.bin/ssh/PROTOCOL.certkeys?rev=1.10&content-type=text/plain
#
# source://net-ssh//lib/net/ssh/authentication/certificate.rb#9
class Net::SSH::Authentication::Certificate
  # Returns the value of attribute critical_options.
  #
  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#18
  def critical_options; end

  # Sets the attribute critical_options
  #
  # @param value the value to set the attribute critical_options to.
  #
  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#18
  def critical_options=(_arg0); end

  # Returns the value of attribute extensions.
  #
  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#19
  def extensions; end

  # Sets the attribute extensions
  #
  # @param value the value to set the attribute extensions to.
  #
  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#19
  def extensions=(_arg0); end

  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#80
  def fingerprint; end

  # Returns the value of attribute key.
  #
  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#11
  def key; end

  # Sets the attribute key
  #
  # @param value the value to set the attribute key to.
  #
  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#11
  def key=(_arg0); end

  # Returns the value of attribute key_id.
  #
  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#14
  def key_id; end

  # Sets the attribute key_id
  #
  # @param value the value to set the attribute key_id to.
  #
  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#14
  def key_id=(_arg0); end

  # Returns the value of attribute nonce.
  #
  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#10
  def nonce; end

  # Sets the attribute nonce
  #
  # @param value the value to set the attribute nonce to.
  #
  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#10
  def nonce=(_arg0); end

  # Returns the value of attribute reserved.
  #
  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#20
  def reserved; end

  # Sets the attribute reserved
  #
  # @param value the value to set the attribute reserved to.
  #
  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#20
  def reserved=(_arg0); end

  # Returns the value of attribute serial.
  #
  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#12
  def serial; end

  # Sets the attribute serial
  #
  # @param value the value to set the attribute serial to.
  #
  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#12
  def serial=(_arg0); end

  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#96
  def sign(key, sign_nonce = T.unsafe(nil)); end

  # Signs the certificate with key.
  #
  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#85
  def sign!(key, sign_nonce = T.unsafe(nil)); end

  # Returns the value of attribute signature.
  #
  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#22
  def signature; end

  # Sets the attribute signature
  #
  # @param value the value to set the attribute signature to.
  #
  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#22
  def signature=(_arg0); end

  # Returns the value of attribute signature_key.
  #
  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#21
  def signature_key; end

  # Sets the attribute signature_key
  #
  # @param value the value to set the attribute signature_key to.
  #
  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#21
  def signature_key=(_arg0); end

  # Checks whether the certificate's signature was signed by signature key.
  #
  # @return [Boolean]
  #
  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#102
  def signature_valid?; end

  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#68
  def ssh_do_sign(data); end

  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#72
  def ssh_do_verify(sig, data); end

  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#56
  def ssh_signature_type; end

  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#52
  def ssh_type; end

  # Serializes the certificate (and key).
  #
  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#61
  def to_blob; end

  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#76
  def to_pem; end

  # Returns the value of attribute type.
  #
  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#13
  def type; end

  # Sets the attribute type
  #
  # @param value the value to set the attribute type to.
  #
  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#13
  def type=(_arg0); end

  # Returns the value of attribute valid_after.
  #
  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#16
  def valid_after; end

  # Sets the attribute valid_after
  #
  # @param value the value to set the attribute valid_after to.
  #
  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#16
  def valid_after=(_arg0); end

  # Returns the value of attribute valid_before.
  #
  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#17
  def valid_before; end

  # Sets the attribute valid_before
  #
  # @param value the value to set the attribute valid_before to.
  #
  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#17
  def valid_before=(_arg0); end

  # Returns the value of attribute valid_principals.
  #
  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#15
  def valid_principals; end

  # Sets the attribute valid_principals
  #
  # @param value the value to set the attribute valid_principals to.
  #
  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#15
  def valid_principals=(_arg0); end

  private

  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#162
  def key_without_type; end

  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#169
  def options_to_blob(options); end

  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#139
  def ssh_time(t); end

  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#144
  def to_blob_without_signature; end

  # source://net-ssh//lib/net/ssh/authentication/certificate.rb#133
  def type_value(type); end

  class << self
    # Read a certificate blob associated with a key of the given type.
    #
    # source://net-ssh//lib/net/ssh/authentication/certificate.rb#25
    def read_certblob(buffer, type); end

    private

    # @raise [ArgumentError]
    #
    # source://net-ssh//lib/net/ssh/authentication/certificate.rb#108
    def read_options(buffer); end

    # source://net-ssh//lib/net/ssh/authentication/certificate.rb#124
    def type_symbol(type); end
  end
end

# Describes the constants used by the Net::SSH::Authentication components
# of the Net::SSH library. Individual authentication method implemenations
# may define yet more constants that are specific to their implementation.
#
# source://net-ssh//lib/net/ssh/authentication/constants.rb#8
module Net::SSH::Authentication::Constants; end

# source://net-ssh//lib/net/ssh/authentication/constants.rb#12
Net::SSH::Authentication::Constants::USERAUTH_BANNER = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/authentication/constants.rb#10
Net::SSH::Authentication::Constants::USERAUTH_FAILURE = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/authentication/constants.rb#17
Net::SSH::Authentication::Constants::USERAUTH_METHOD_RANGE = T.let(T.unsafe(nil), Range)

# source://net-ssh//lib/net/ssh/authentication/constants.rb#14
Net::SSH::Authentication::Constants::USERAUTH_PASSWD_CHANGEREQ = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/authentication/constants.rb#15
Net::SSH::Authentication::Constants::USERAUTH_PK_OK = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/authentication/constants.rb#9
Net::SSH::Authentication::Constants::USERAUTH_REQUEST = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/authentication/constants.rb#11
Net::SSH::Authentication::Constants::USERAUTH_SUCCESS = T.let(T.unsafe(nil), Integer)

# Raised if the current authentication method is not allowed
#
# source://net-ssh//lib/net/ssh/authentication/session.rb#16
class Net::SSH::Authentication::DisallowedMethod < ::Net::SSH::Exception; end

# Loads ED25519 support which requires optinal dependecies like
# ed25519, bcrypt_pbkdf
#
# source://net-ssh//lib/net/ssh/authentication/ed25519_loader.rb#7
module Net::SSH::Authentication::ED25519Loader
  class << self
    # source://net-ssh//lib/net/ssh/authentication/ed25519_loader.rb#24
    def dependenciesRequiredForED25519; end

    # @raise [NotImplementedError]
    #
    # source://net-ssh//lib/net/ssh/authentication/ed25519_loader.rb#18
    def raiseUnlessLoaded(message); end
  end
end

# source://net-ssh//lib/net/ssh/authentication/ed25519_loader.rb#14
Net::SSH::Authentication::ED25519Loader::ERROR = T.let(T.unsafe(nil), Gem::LoadError)

# source://net-ssh//lib/net/ssh/authentication/ed25519_loader.rb#15
Net::SSH::Authentication::ED25519Loader::LOADED = T.let(T.unsafe(nil), FalseClass)

# This class encapsulates all operations done by clients on a user's
# private keys. In practice, the client should never need a reference
# to a private key; instead, they grab a list of "identities" (public
# keys) that are available from the KeyManager, and then use
# the KeyManager to do various private key operations using those
# identities.
#
# The KeyManager also uses the Agent class to encapsulate the
# ssh-agent. Thus, from a client's perspective it is completely
# hidden whether an identity comes from the ssh-agent or from a file
# on disk.
#
# source://net-ssh//lib/net/ssh/authentication/key_manager.rb#24
class Net::SSH::Authentication::KeyManager
  include ::Net::SSH::Loggable

  # Create a new KeyManager. By default, the manager will
  # use the ssh-agent if it is running and the `:use_agent` option
  # is not false.
  #
  # @return [KeyManager] a new instance of KeyManager
  #
  # source://net-ssh//lib/net/ssh/authentication/key_manager.rb#45
  def initialize(logger, options = T.unsafe(nil)); end

  # Add the given key_file to the list of key files that will be used.
  #
  # source://net-ssh//lib/net/ssh/authentication/key_manager.rb#68
  def add(key_file); end

  # Add the given key_file to the list of keys that will be used.
  #
  # source://net-ssh//lib/net/ssh/authentication/key_manager.rb#80
  def add_key_data(key_data_); end

  # Add the given keycert_file to the list of keycert files that will be used.
  #
  # source://net-ssh//lib/net/ssh/authentication/key_manager.rb#74
  def add_keycert(keycert_file); end

  # Returns an Agent instance to use for communicating with an SSH
  # agent process. Returns nil if use of an SSH agent has been disabled,
  # or if the agent is otherwise not available.
  #
  # source://net-ssh//lib/net/ssh/authentication/key_manager.rb#202
  def agent; end

  # Clear all knowledge of any loaded user keys. This also clears the list
  # of default identity files that are to be loaded, thus making it
  # appropriate to use if a client wishes to NOT use the default identity
  # files.
  #
  # source://net-ssh//lib/net/ssh/authentication/key_manager.rb#60
  def clear!; end

  # Iterates over all available identities (public keys) known to this
  # manager. As it finds one, it will then yield it to the caller.
  # The origin of the identities may be from files on disk or from an
  # ssh-agent. Note that identities from an ssh-agent are always listed
  # first in the array, with other identities coming after.
  #
  # If key manager was created with :keys_only option, any identity
  # from ssh-agent will be ignored unless it present in key_files or
  # key_data.
  #
  # source://net-ssh//lib/net/ssh/authentication/key_manager.rb#108
  def each_identity; end

  # This is used as a hint to the KeyManager indicating that the agent
  # connection is no longer needed. Any other open resources may be closed
  # at this time.
  #
  # Calling this does NOT indicate that the KeyManager will no longer
  # be used. Identities may still be requested and operations done on
  # loaded identities, in which case, the agent will be automatically
  # reconnected. This method simply allows the client connection to be
  # closed when it will not be used in the immediate future.
  #
  # source://net-ssh//lib/net/ssh/authentication/key_manager.rb#94
  def finish; end

  # The list of user key data that will be examined
  #
  # source://net-ssh//lib/net/ssh/authentication/key_manager.rb#31
  def key_data; end

  # The list of user key files that will be examined
  #
  # source://net-ssh//lib/net/ssh/authentication/key_manager.rb#28
  def key_files; end

  # The list of user key certificate files that will be examined
  #
  # source://net-ssh//lib/net/ssh/authentication/key_manager.rb#34
  def keycert_files; end

  # The map of loaded identities
  #
  # source://net-ssh//lib/net/ssh/authentication/key_manager.rb#37
  def known_identities; end

  # @return [Boolean]
  #
  # source://net-ssh//lib/net/ssh/authentication/key_manager.rb#210
  def no_keys?; end

  # The map of options that were passed to the key-manager
  #
  # source://net-ssh//lib/net/ssh/authentication/key_manager.rb#40
  def options; end

  # Sign the given data, using the corresponding private key of the given
  # identity. If the identity was originally obtained from an ssh-agent,
  # then the ssh-agent will be used to sign the data, otherwise the
  # private key for the identity will be loaded from disk (if it hasn't
  # been loaded already) and will then be used to sign the data.
  #
  # Regardless of the identity's origin or who does the signing, this
  # will always return the signature in an SSH2-specified "signature
  # blob" format.
  #
  # @raise [KeyManagerError]
  #
  # source://net-ssh//lib/net/ssh/authentication/key_manager.rb#162
  def sign(identity, data); end

  # Toggles whether the ssh-agent will be used or not. If true, an
  # attempt will be made to use the ssh-agent. If false, any existing
  # connection to an agent is closed and the agent will not be used.
  #
  # source://net-ssh//lib/net/ssh/authentication/key_manager.rb#194
  def use_agent=(use_agent); end

  # Identifies whether the ssh-agent will be used or not.
  #
  # @return [Boolean]
  #
  # source://net-ssh//lib/net/ssh/authentication/key_manager.rb#187
  def use_agent?; end

  private

  # Load prepared identities. Private key decryption errors ignored if ignore_decryption_errors
  #
  # source://net-ssh//lib/net/ssh/authentication/key_manager.rb#249
  def load_identities(identities, ask_passphrase, ignore_decryption_errors); end

  # Prepared identities from user key_data, preserving their order and sources.
  #
  # source://net-ssh//lib/net/ssh/authentication/key_manager.rb#242
  def prepare_identities_from_data; end

  # Prepares identities from user key_files for loading, preserving their order and sources.
  #
  # source://net-ssh//lib/net/ssh/authentication/key_manager.rb#217
  def prepare_identities_from_files; end

  # source://net-ssh//lib/net/ssh/authentication/key_manager.rb#285
  def process_identity_loading_error(identity, e); end

  # @return [Boolean]
  #
  # source://net-ssh//lib/net/ssh/authentication/key_manager.rb#237
  def readable_file?(path); end
end

# A trivial exception class used to report errors in the key manager.
#
# source://net-ssh//lib/net/ssh/authentication/key_manager.rb#11
class Net::SSH::Authentication::KeyManagerError < ::Net::SSH::Exception; end

# source://net-ssh//lib/net/ssh/authentication/methods/abstract.rb#9
module Net::SSH::Authentication::Methods; end

# The base class of all user authentication methods. It provides a few
# bits of common functionality.
#
# source://net-ssh//lib/net/ssh/authentication/methods/abstract.rb#13
class Net::SSH::Authentication::Methods::Abstract
  include ::Net::SSH::Loggable
  include ::Net::SSH::Authentication::Constants

  # Instantiates a new authentication method.
  #
  # @return [Abstract] a new instance of Abstract
  #
  # source://net-ssh//lib/net/ssh/authentication/methods/abstract.rb#25
  def initialize(session, options = T.unsafe(nil)); end

  # The key manager object. Not all authentication methods will require
  # this.
  #
  # source://net-ssh//lib/net/ssh/authentication/methods/abstract.rb#22
  def key_manager; end

  # Sends a message via the underlying transport layer abstraction. This
  # will block until the message is completely sent.
  #
  # source://net-ssh//lib/net/ssh/authentication/methods/abstract.rb#41
  def send_message(msg); end

  # The authentication session object
  #
  # source://net-ssh//lib/net/ssh/authentication/methods/abstract.rb#18
  def session; end

  # Returns the session-id, as generated during the first key exchange of
  # an SSH connection.
  #
  # source://net-ssh//lib/net/ssh/authentication/methods/abstract.rb#35
  def session_id; end

  # Creates a new USERAUTH_REQUEST packet. The extra arguments on the end
  # must be either boolean values or strings, and are tacked onto the end
  # of the packet. The new packet is returned, ready for sending.
  #
  # source://net-ssh//lib/net/ssh/authentication/methods/abstract.rb#48
  def userauth_request(username, next_service, auth_method, *others); end

  private

  # Returns the value of attribute prompt.
  #
  # source://net-ssh//lib/net/ssh/authentication/methods/abstract.rb#65
  def prompt; end
end

# Implements the host-based SSH authentication method.
#
# source://net-ssh//lib/net/ssh/authentication/methods/hostbased.rb#9
class Net::SSH::Authentication::Methods::Hostbased < ::Net::SSH::Authentication::Methods::Abstract
  # Attempts to perform host-based authorization of the user by trying
  # all known keys.
  #
  # source://net-ssh//lib/net/ssh/authentication/methods/hostbased.rb#14
  def authenticate(next_service, username, password = T.unsafe(nil)); end

  private

  # Attempts to perform host-based authentication of the user, using
  # the given host identity (key).
  #
  # source://net-ssh//lib/net/ssh/authentication/methods/hostbased.rb#34
  def authenticate_with(identity, next_service, username, key_manager); end

  # Build the "core" hostbased request string.
  #
  # source://net-ssh//lib/net/ssh/authentication/methods/hostbased.rb#65
  def build_request(identity, next_service, username, hostname, client_username); end

  # Returns the hostname as reported by the underlying socket.
  #
  # source://net-ssh//lib/net/ssh/authentication/methods/hostbased.rb#28
  def hostname; end
end

# Implements the "keyboard-interactive" SSH authentication method.
#
# source://net-ssh//lib/net/ssh/authentication/methods/keyboard_interactive.rb#10
class Net::SSH::Authentication::Methods::KeyboardInteractive < ::Net::SSH::Authentication::Methods::Abstract
  # Attempt to authenticate the given user for the given service.
  #
  # source://net-ssh//lib/net/ssh/authentication/methods/keyboard_interactive.rb#15
  def authenticate(next_service, username, password = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://net-ssh//lib/net/ssh/authentication/methods/keyboard_interactive.rb#69
  def interactive?; end
end

# source://net-ssh//lib/net/ssh/authentication/methods/keyboard_interactive.rb#11
Net::SSH::Authentication::Methods::KeyboardInteractive::USERAUTH_INFO_REQUEST = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/authentication/methods/keyboard_interactive.rb#12
Net::SSH::Authentication::Methods::KeyboardInteractive::USERAUTH_INFO_RESPONSE = T.let(T.unsafe(nil), Integer)

# Implements the "none" SSH authentication method.
#
# source://net-ssh//lib/net/ssh/authentication/methods/none.rb#10
class Net::SSH::Authentication::Methods::None < ::Net::SSH::Authentication::Methods::Abstract
  # Attempt to authenticate as "none"
  #
  # source://net-ssh//lib/net/ssh/authentication/methods/none.rb#12
  def authenticate(next_service, user = T.unsafe(nil), password = T.unsafe(nil)); end
end

# Implements the "password" SSH authentication method.
#
# source://net-ssh//lib/net/ssh/authentication/methods/password.rb#11
class Net::SSH::Authentication::Methods::Password < ::Net::SSH::Authentication::Methods::Abstract
  # Attempt to authenticate the given user for the given service. If
  # the password parameter is nil, this will ask for password
  #
  # source://net-ssh//lib/net/ssh/authentication/methods/password.rb#14
  def authenticate(next_service, username, password = T.unsafe(nil)); end

  private

  # source://net-ssh//lib/net/ssh/authentication/methods/password.rb#60
  def ask_password(username); end

  # source://net-ssh//lib/net/ssh/authentication/methods/password.rb#55
  def clear_prompter!; end

  # source://net-ssh//lib/net/ssh/authentication/methods/password.rb#71
  def get_max_retries; end
end

# source://net-ssh//lib/net/ssh/authentication/methods/password.rb#53
Net::SSH::Authentication::Methods::Password::NUMBER_OF_PASSWORD_PROMPTS = T.let(T.unsafe(nil), Integer)

# Implements the "publickey" SSH authentication method.
#
# source://net-ssh//lib/net/ssh/authentication/methods/publickey.rb#11
class Net::SSH::Authentication::Methods::Publickey < ::Net::SSH::Authentication::Methods::Abstract
  # Attempts to perform public-key authentication for the given
  # username, trying each identity known to the key manager. If any of
  # them succeed, returns +true+, otherwise returns +false+. This
  # requires the presence of a key manager.
  #
  # source://net-ssh//lib/net/ssh/authentication/methods/publickey.rb#16
  def authenticate(next_service, username, password = T.unsafe(nil)); end

  private

  # Attempts to perform public-key authentication for the given
  # username, with the given identity (public key). Returns +true+ if
  # successful, or +false+ otherwise.
  #
  # source://net-ssh//lib/net/ssh/authentication/methods/publickey.rb#49
  def authenticate_with(identity, next_service, username); end

  # Builds a packet that contains the request formatted for sending
  # a public-key request to the server.
  #
  # source://net-ssh//lib/net/ssh/authentication/methods/publickey.rb#30
  def build_request(pub_key, username, next_service, has_sig); end

  # Builds and sends a request formatted for a public-key
  # authentication request.
  #
  # source://net-ssh//lib/net/ssh/authentication/methods/publickey.rb#40
  def send_request(pub_key, username, next_service, signature = T.unsafe(nil)); end
end

# Public key fingerprinting utility module - internal not part of API.
# This is included in pubkey classes and called from there. All RSA, DSA, and ECC keys
# are supported.
#
#     require 'net/ssh'
#     my_pubkey_text = File.read('/path/to/id_ed25519.pub')
#        #=> "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIDB2NBh4GJPPUN1kXPMu8b633Xcv55WoKC3OkBjFAbzJ alice@example.com"
#     my_pubkey = Net::SSH::KeyFactory.load_data_public_key(my_pubkey_text)
#        #=> #<Net::SSH::Authentication::ED25519::PubKey:0x00007fc8e91819b0
#     my_pubkey.fingerprint
#        #=> "2f:7f:97:21:76:a4:0f:38:c4:fe:d8:b4:6a:39:72:30"
#     my_pubkey.fingerprint('SHA256')
#        #=> "SHA256:u6mXnY8P1b0FODGp8mckqOB33u8+jvkSCtJbD5Q9klg"
#
# source://net-ssh//lib/net/ssh/authentication/pub_key_fingerprint.rb#19
module Net::SSH::Authentication::PubKeyFingerprint
  # Return the key's fingerprint.  Algorithm may be either +MD5+ (default),
  # or +SHA256+. For +SHA256+, fingerprints are in the same format
  # returned by OpenSSH's <tt>`ssh-add -l -E SHA256`</tt>, i.e.,
  # trailing base64 padding '=' characters are stripped and the
  # literal string +SHA256:+ is prepended.
  #
  # source://net-ssh//lib/net/ssh/authentication/pub_key_fingerprint.rb#25
  def fingerprint(algorithm = T.unsafe(nil)); end

  class << self
    # source://net-ssh//lib/net/ssh/authentication/pub_key_fingerprint.rb#30
    def fingerprint(blob, algorithm = T.unsafe(nil)); end
  end
end

# Represents an authentication session. It manages the authentication of
# a user over an established connection (the "transport" object, see
# Net::SSH::Transport::Session).
#
# The use of an authentication session to manage user authentication is
# internal to Net::SSH (specifically Net::SSH.start). Consumers of the
# Net::SSH library will never need to access this class directly.
#
# source://net-ssh//lib/net/ssh/authentication/session.rb#26
class Net::SSH::Authentication::Session
  include ::Net::SSH::Loggable
  include ::Net::SSH::Authentication::Constants
  include ::Net::SSH::Transport::Constants

  # Instantiates a new Authentication::Session object over the given
  # transport layer abstraction.
  #
  # @return [Session] a new instance of Session
  #
  # source://net-ssh//lib/net/ssh/authentication/session.rb#45
  def initialize(transport, options = T.unsafe(nil)); end

  # the list of authentication methods that are allowed
  #
  # source://net-ssh//lib/net/ssh/authentication/session.rb#38
  def allowed_auth_methods; end

  # the list of authentication methods to try
  #
  # source://net-ssh//lib/net/ssh/authentication/session.rb#35
  def auth_methods; end

  # Attempts to authenticate the given user, in preparation for the next
  # service request. Returns true if an authentication method succeeds in
  # authenticating the user, and false otherwise.
  #
  # source://net-ssh//lib/net/ssh/authentication/session.rb#58
  def authenticate(next_service, username, password = T.unsafe(nil)); end

  # Blocks until a packet is received, and returns it if it is of the given
  # type. If it is not, an exception is raised.
  #
  # @raise [Net::SSH::Exception]
  #
  # source://net-ssh//lib/net/ssh/authentication/session.rb#129
  def expect_message(type); end

  # Blocks until a packet is received. It silently handles USERAUTH_BANNER
  # packets, and will raise an error if any packet is received that is not
  # valid during user authentication.
  #
  # source://net-ssh//lib/net/ssh/authentication/session.rb#100
  def next_message; end

  # a hash of options, given at construction time
  #
  # source://net-ssh//lib/net/ssh/authentication/session.rb#41
  def options; end

  # transport layer abstraction
  #
  # source://net-ssh//lib/net/ssh/authentication/session.rb#32
  def transport; end

  private

  # Returns an array of paths to the key files usually defined
  # by system default.
  #
  # source://net-ssh//lib/net/ssh/authentication/session.rb#139
  def default_keys; end

  # Returns an array of the key data that should be used when
  # attempting any key-based authentication mechanism.
  #
  # source://net-ssh//lib/net/ssh/authentication/session.rb#158
  def key_data; end

  # Returns an array of paths to the keycert files that should be used when
  # attempting any key-based authentication mechanism.
  #
  # source://net-ssh//lib/net/ssh/authentication/session.rb#152
  def keycerts; end

  # Returns an array of paths to the key files that should be used when
  # attempting any key-based authentication mechanism.
  #
  # source://net-ssh//lib/net/ssh/authentication/session.rb#146
  def keys; end
end

# This exception is raised when authentication fails (whether it be
# public key authentication, password authentication, or whatever).
#
# source://net-ssh//lib/net/ssh/errors.rb#9
class Net::SSH::AuthenticationFailed < ::Net::SSH::Exception; end

# Net::SSH::Buffer is a flexible class for building and parsing binary
# data packets. It provides a stream-like interface for sequentially
# reading data items from the buffer, as well as a useful helper method
# for building binary packets given a signature.
#
# Writing to a buffer always appends to the end, regardless of where the
# read cursor is. Reading, on the other hand, always begins at the first
# byte of the buffer and increments the read cursor, with subsequent reads
# taking up where the last left off.
#
# As a consumer of the Net::SSH library, you will rarely come into contact
# with these buffer objects directly, but it could happen. Also, if you
# are ever implementing a protocol on top of SSH (e.g. SFTP), this buffer
# class can be quite handy.
#
# source://net-ssh//lib/net/ssh/buffer.rb#23
class Net::SSH::Buffer
  # Creates a new buffer, initialized to the given content. The position
  # is initialized to the beginning of the buffer.
  #
  # @return [Buffer] a new instance of Buffer
  #
  # source://net-ssh//lib/net/ssh/buffer.rb#74
  def initialize(content = T.unsafe(nil)); end

  # Compares the contents of the two buffers, returning +true+ only if they
  # are identical in size and content.
  #
  # source://net-ssh//lib/net/ssh/buffer.rb#97
  def ==(buffer); end

  # Appends the given text to the end of the buffer. Does not alter the
  # read position. Returns the buffer object itself.
  #
  # source://net-ssh//lib/net/ssh/buffer.rb#146
  def append(text); end

  # Returns the number of bytes available to be read (e.g., how many bytes
  # remain between the current position and the end of the buffer).
  #
  # source://net-ssh//lib/net/ssh/buffer.rb#86
  def available; end

  # Resets the buffer, making it empty. Also, resets the read position to
  # 0.
  #
  # source://net-ssh//lib/net/ssh/buffer.rb#120
  def clear!; end

  # Consumes n bytes from the buffer, where n is the current position
  # unless otherwise specified. This is useful for removing data from the
  # buffer that has previously been read, when you are expecting more data
  # to be appended. It helps to keep the size of buffers down when they
  # would otherwise tend to grow without bound.
  #
  # Returns the buffer object itself.
  #
  # source://net-ssh//lib/net/ssh/buffer.rb#132
  def consume!(n = T.unsafe(nil)); end

  # exposes the raw content of the buffer
  #
  # source://net-ssh//lib/net/ssh/buffer.rb#67
  def content; end

  # Returns +true+ if the buffer contains no data (e.g., it is of zero length).
  #
  # @return [Boolean]
  #
  # source://net-ssh//lib/net/ssh/buffer.rb#102
  def empty?; end

  # Returns true if the pointer is at the end of the buffer. Subsequent
  # reads will return nil, in this case.
  #
  # @return [Boolean]
  #
  # source://net-ssh//lib/net/ssh/buffer.rb#114
  def eof?; end

  # Returns the length of the buffer's content.
  #
  # source://net-ssh//lib/net/ssh/buffer.rb#80
  def length; end

  # the current position of the pointer in the buffer
  #
  # source://net-ssh//lib/net/ssh/buffer.rb#70
  def position; end

  # the current position of the pointer in the buffer
  #
  # source://net-ssh//lib/net/ssh/buffer.rb#70
  def position=(_arg0); end

  # Reads and returns the next +count+ bytes from the buffer, starting from
  # the read position. If +count+ is +nil+, this will return all remaining
  # text in the buffer. This method will increment the pointer.
  #
  # source://net-ssh//lib/net/ssh/buffer.rb#175
  def read(count = T.unsafe(nil)); end

  # Reads (as #read) and returns the given number of bytes from the buffer,
  # and then consumes (as #consume!) all data up to the new read position.
  #
  # source://net-ssh//lib/net/ssh/buffer.rb#184
  def read!(count = T.unsafe(nil)); end

  # Calls block(self) until the buffer is empty, and returns all results.
  #
  # source://net-ssh//lib/net/ssh/buffer.rb#191
  def read_all(&block); end

  # Read a bignum (OpenSSL::BN) from the buffer, in SSH2 format. It is
  # essentially just a string, which is reinterpreted to be a bignum in
  # binary format.
  #
  # source://net-ssh//lib/net/ssh/buffer.rb#237
  def read_bignum; end

  # Read a single byte and convert it into a boolean, using 'C' rules
  # (i.e., zero is false, non-zero is true).
  #
  # source://net-ssh//lib/net/ssh/buffer.rb#229
  def read_bool; end

  # Reads the next string from the buffer, and returns a new Buffer
  # object that wraps it.
  #
  # source://net-ssh//lib/net/ssh/buffer.rb#335
  def read_buffer; end

  # Read and return the next byte in the buffer. Returns nil if called at
  # the end of the buffer.
  #
  # source://net-ssh//lib/net/ssh/buffer.rb#214
  def read_byte; end

  # Return the next 8 bytes as a 64-bit integer (in network byte order).
  # Returns nil if there are less than 8 bytes remaining to be read in the
  # buffer.
  #
  # source://net-ssh//lib/net/ssh/buffer.rb#198
  def read_int64; end

  # Read a key from the buffer. The key will start with a string
  # describing its type. The remainder of the key is defined by the
  # type that was read.
  #
  # source://net-ssh//lib/net/ssh/buffer.rb#246
  def read_key; end

  # Read a keyblob of the given type from the buffer, and return it as
  # a key. Only RSA, DSA, and ECDSA keys are supported.
  #
  # source://net-ssh//lib/net/ssh/buffer.rb#293
  def read_keyblob(type); end

  # Return the next four bytes as a long integer (in network byte order).
  # Returns nil if there are less than 4 bytes remaining to be read in the
  # buffer.
  #
  # source://net-ssh//lib/net/ssh/buffer.rb#207
  def read_long; end

  # source://net-ssh//lib/net/ssh/buffer.rb#251
  def read_private_keyblob(type); end

  # Read and return an SSH2-encoded string. The string starts with a long
  # integer that describes the number of bytes remaining in the string.
  # Returns nil if there are not enough bytes to satisfy the request.
  #
  # source://net-ssh//lib/net/ssh/buffer.rb#222
  def read_string; end

  # Reads all data up to and including the given pattern, which may be a
  # String, Fixnum, or Regexp and is interpreted exactly as String#index
  # does. Returns nil if nothing matches. Increments the position to point
  # immediately after the pattern, if it does match. Returns all data up to
  # and including the text that matched the pattern.
  #
  # source://net-ssh//lib/net/ssh/buffer.rb#162
  def read_to(pattern); end

  # Returns all text from the current pointer to the end of the buffer as
  # a new Net::SSH::Buffer object.
  #
  # source://net-ssh//lib/net/ssh/buffer.rb#153
  def remainder_as_buffer; end

  # Resets the pointer to the start of the buffer. Subsequent reads will
  # begin at position 0.
  #
  # source://net-ssh//lib/net/ssh/buffer.rb#108
  def reset!; end

  # Returns a copy of the buffer's content.
  #
  # source://net-ssh//lib/net/ssh/buffer.rb#91
  def to_s; end

  # Writes the given data literally into the string. Does not alter the
  # read position. Returns the buffer object.
  #
  # source://net-ssh//lib/net/ssh/buffer.rb#341
  def write(*data); end

  # Writes each argument to the buffer as a bignum (SSH2-style). No
  # checking is done to ensure that the arguments are, in fact, bignums.
  # Does not alter the read position. Returns the buffer object.
  #
  # source://net-ssh//lib/net/ssh/buffer.rb#416
  def write_bignum(*n); end

  # Writes each argument to the buffer as a (C-style) boolean, with 1
  # meaning true, and 0 meaning false. Does not alter the read position.
  # Returns the buffer object.
  #
  # source://net-ssh//lib/net/ssh/buffer.rb#408
  def write_bool(*b); end

  # Writes each argument to the buffer as a byte. Does not alter the read
  # position. Returns the buffer object.
  #
  # source://net-ssh//lib/net/ssh/buffer.rb#375
  def write_byte(*n); end

  # Writes each argument to the buffer as a network-byte-order-encoded
  # 64-bit integer (8 bytes). Does not alter the read position. Returns the
  # buffer object.
  #
  # source://net-ssh//lib/net/ssh/buffer.rb#356
  def write_int64(*n); end

  # Writes the given arguments to the buffer as SSH2-encoded keys. Does not
  # alter the read position. Returns the buffer object.
  #
  # source://net-ssh//lib/net/ssh/buffer.rb#423
  def write_key(*key); end

  # Writes each argument to the buffer as a network-byte-order-encoded
  # long (4-byte) integer. Does not alter the read position. Returns the
  # buffer object.
  #
  # source://net-ssh//lib/net/ssh/buffer.rb#368
  def write_long(*n); end

  # Optimized version of write where the caller gives up ownership of string
  # to the method. This way we can mutate the string.
  #
  # source://net-ssh//lib/net/ssh/buffer.rb#348
  def write_moved(string); end

  # Writes each argument to the buffer as an SSH2-encoded string. Each
  # string is prefixed by its length, encoded as a 4-byte long integer.
  # Does not alter the read position. Returns the buffer object.
  # Might alter arguments see write_moved
  #
  # source://net-ssh//lib/net/ssh/buffer.rb#396
  def write_mstring(*text); end

  # Writes each argument to the buffer as an SSH2-encoded string. Each
  # string is prefixed by its length, encoded as a 4-byte long integer.
  # Does not alter the read position. Returns the buffer object.
  #
  # source://net-ssh//lib/net/ssh/buffer.rb#383
  def write_string(*text); end

  class << self
    # This is a convenience method for creating and populating a new buffer
    # from a single command. The arguments must be even in length, with the
    # first of each pair of arguments being a symbol naming the type of the
    # data that follows. If the type is :raw, the value is written directly
    # to the hash.
    #
    #   b = Buffer.from(:byte, 1, :string, "hello", :raw, "\1\2\3\4")
    #   #-> "\1\0\0\0\5hello\1\2\3\4"
    #
    # The supported data types are:
    #
    # * :raw => write the next value verbatim (#write)
    # * :int64 => write an 8-byte integer (#write_int64)
    # * :long => write a 4-byte integer (#write_long)
    # * :byte => write a single byte (#write_byte)
    # * :string => write a 4-byte length followed by character data (#write_string)
    # * :mstring => same as string, but caller cannot resuse the string, avoids potential duplication (#write_moved)
    # * :bool => write a single byte, interpreted as a boolean (#write_bool)
    # * :bignum => write an SSH-encoded bignum (#write_bignum)
    # * :key => write an SSH-encoded key value (#write_key)
    #
    # Any of these, except for :raw, accepts an Array argument, to make it
    # easier to write multiple values of the same type in a briefer manner.
    #
    # @raise [ArgumentError]
    #
    # source://net-ssh//lib/net/ssh/buffer.rb#47
    def from(*args); end
  end
end

# This module is used to extend sockets and other IO objects, to allow
# them to be buffered for both read and write. This abstraction makes it
# quite easy to write a select-based event loop
# (see Net::SSH::Connection::Session#listen_to).
#
# The general idea is that instead of calling #read directly on an IO that
# has been extended with this module, you call #fill (to add pending input
# to the internal read buffer), and then #read_available (to read from that
# buffer). Likewise, you don't call #write directly, you call #enqueue to
# add data to the write buffer, and then #send_pending or #wait_for_pending_sends
# to actually send the data across the wire.
#
# In this way you can easily use the object as an argument to IO.select,
# calling #fill when it is available for read, or #send_pending when it is
# available for write, and then call #enqueue and #read_available during
# the idle times.
#
#   socket = TCPSocket.new(address, port)
#   socket.extend(Net::SSH::BufferedIo)
#
#   ssh.listen_to(socket)
#
#   ssh.loop do
#     if socket.available > 0
#       puts socket.read_available
#       socket.enqueue("response\n")
#     end
#   end
#
# Note that this module must be used to extend an instance, and should not
# be included in a class. If you do want to use it via an include, then you
# must make sure to invoke the private #initialize_buffered_io method in
# your class' #initialize method:
#
#   class Foo < IO
#     include Net::SSH::BufferedIo
#
#     def initialize
#       initialize_buffered_io
#       # ...
#     end
#   end
#
# source://net-ssh//lib/net/ssh/buffered_io.rb#49
module Net::SSH::BufferedIo
  include ::Net::SSH::Loggable

  # Returns the number of bytes available to be read from the input buffer.
  # (See #read_available.)
  #
  # source://net-ssh//lib/net/ssh/buffered_io.rb#82
  def available; end

  # Enqueues data in the output buffer, to be written when #send_pending
  # is called. Note that the data is _not_ sent immediately by this method!
  #
  # source://net-ssh//lib/net/ssh/buffered_io.rb#88
  def enqueue(data); end

  # Tries to read up to +n+ bytes of data from the remote end, and appends
  # the data to the input buffer. It returns the number of bytes read, or 0
  # if no data was available to be read.
  #
  # source://net-ssh//lib/net/ssh/buffered_io.rb#63
  def fill(n = T.unsafe(nil)); end

  # Returns +true+ if there is data waiting in the output buffer, and
  # +false+ otherwise.
  #
  # @return [Boolean]
  #
  # source://net-ssh//lib/net/ssh/buffered_io.rb#94
  def pending_write?; end

  # Read up to +length+ bytes from the input buffer. If +length+ is nil,
  # all available data is read from the buffer. (See #available.)
  #
  # source://net-ssh//lib/net/ssh/buffered_io.rb#76
  def read_available(length = T.unsafe(nil)); end

  # source://net-ssh//lib/net/ssh/buffered_io.rb#128
  def read_buffer; end

  # Sends as much of the pending output as possible. Returns +true+ if any
  # data was sent, and +false+ otherwise.
  #
  # source://net-ssh//lib/net/ssh/buffered_io.rb#100
  def send_pending; end

  # Calls #send_pending repeatedly, if necessary, blocking until the output
  # buffer is empty.
  #
  # source://net-ssh//lib/net/ssh/buffered_io.rb#113
  def wait_for_pending_sends; end

  # source://net-ssh//lib/net/ssh/buffered_io.rb#124
  def write_buffer; end

  private

  # Initializes the intput and output buffers for this object. This method
  # is called automatically when the module is mixed into an object via
  # Object#extend (see Net::SSH::BufferedIo.extended), but must be called
  # explicitly in the +initialize+ method of any class that uses
  # Module#include to add this module.
  #
  # source://net-ssh//lib/net/ssh/buffered_io.rb#148
  def initialize_buffered_io; end

  # --
  # Can't use attr_reader here (after +private+) without incurring the
  # wrath of "ruby -w". We hates it.
  # ++
  #
  # source://net-ssh//lib/net/ssh/buffered_io.rb#139
  def input; end

  # source://net-ssh//lib/net/ssh/buffered_io.rb#141
  def output; end

  class << self
    # Called when the #extend is called on an object, with this module as the
    # argument. It ensures that the modules instance variables are all properly
    # initialized.
    #
    # source://net-ssh//lib/net/ssh/buffered_io.rb#55
    def extended(object); end
  end
end

# This is exception is primarily used internally, but if you have a channel
# open handler (see Net::SSH::Connection::Session#on_open_channel) and you
# want to fail in such a way that the server knows it failed, you can
# raise this exception in the handler and Net::SSH will translate that into
# a "channel open failed" message.
#
# source://net-ssh//lib/net/ssh/errors.rb#34
class Net::SSH::ChannelOpenFailed < ::Net::SSH::Exception
  # @return [ChannelOpenFailed] a new instance of ChannelOpenFailed
  #
  # source://net-ssh//lib/net/ssh/errors.rb#37
  def initialize(code, reason); end

  # Returns the value of attribute code.
  #
  # source://net-ssh//lib/net/ssh/errors.rb#35
  def code; end

  # Returns the value of attribute reason.
  #
  # source://net-ssh//lib/net/ssh/errors.rb#35
  def reason; end
end

# This exception is primarily used internally, but if you have a channel
# request handler (see Net::SSH::Connection::Channel#on_request) that you
# want to fail in such a way that the server knows it failed, you can
# raise this exception in the handler and Net::SSH will translate that into
# a "channel failure" message.
#
# source://net-ssh//lib/net/ssh/errors.rb#27
class Net::SSH::ChannelRequestFailed < ::Net::SSH::Exception; end

# The Net::SSH::Config class is used to parse OpenSSH configuration files,
# and translates that syntax into the configuration syntax that Net::SSH
# understands. This lets Net::SSH scripts read their configuration (to
# some extent) from OpenSSH configuration files (~/.ssh/config, /etc/ssh_config,
# and so forth).
#
# Only a subset of OpenSSH configuration options are understood:
#
# * ChallengeResponseAuthentication => maps to the :auth_methods option challenge-response (then coleasced into keyboard-interactive)
# * KbdInteractiveAuthentication => maps to the :auth_methods keyboard-interactive
# * CertificateFile => maps to the :keycerts option
# * Ciphers => maps to the :encryption option
# * Compression => :compression
# * CompressionLevel => :compression_level
# * ConnectTimeout => maps to the :timeout option
# * ForwardAgent => :forward_agent
# * GlobalKnownHostsFile => :global_known_hosts_file
# * HostBasedAuthentication => maps to the :auth_methods option
# * HostKeyAlgorithms => maps to :host_key option
# * HostKeyAlias => :host_key_alias
# * HostName => :host_name
# * IdentityFile => maps to the :keys option
# * IdentityAgent => :identity_agent
# * IdentitiesOnly => :keys_only
# * CheckHostIP => :check_host_ip
# * Macs => maps to the :hmac option
# * PasswordAuthentication => maps to the :auth_methods option password
# * Port => :port
# * PreferredAuthentications => maps to the :auth_methods option
# * ProxyCommand => maps to the :proxy option
# * ProxyJump => maps to the :proxy option
# * PubKeyAuthentication => maps to the :auth_methods option
# * RekeyLimit => :rekey_limit
# * StrictHostKeyChecking => :strict_host_key_checking
# * User => :user
# * UserKnownHostsFile => :user_known_hosts_file
# * NumberOfPasswordPrompts => :number_of_password_prompts
# * FingerprintHash => :fingerprint_hash
#
# Note that you will never need to use this class directly--you can control
# whether the OpenSSH configuration files are read by passing the :config
# option to Net::SSH.start. (They are, by default.)
#
# source://net-ssh//lib/net/ssh/config.rb#46
class Net::SSH::Config
  class << self
    # source://net-ssh//lib/net/ssh/config.rb#61
    def default_auth_methods; end

    # Returns an array of locations of OpenSSH configuration files
    # to parse by default.
    #
    # source://net-ssh//lib/net/ssh/config.rb#57
    def default_files; end

    # Filters default_files down to the files that are expandable.
    #
    # source://net-ssh//lib/net/ssh/config.rb#187
    def expandable_default_files; end

    # Loads the configuration data for the given +host+ from all of the
    # given +files+ (defaulting to the list of files returned by
    # #default_files), translates the resulting hash into the options
    # recognized by Net::SSH, and returns them.
    #
    # source://net-ssh//lib/net/ssh/config.rb#69
    def for(host, files = T.unsafe(nil)); end

    # Load the OpenSSH configuration settings in the given +file+ for the
    # given +host+. If +settings+ is given, the options are merged into
    # that hash, with existing values taking precedence over newly parsed
    # ones. Returns a hash containing the OpenSSH options. (See
    # #translate for how to convert the OpenSSH options into Net::SSH
    # options.)
    #
    # source://net-ssh//lib/net/ssh/config.rb#81
    def load(path, host, settings = T.unsafe(nil), base_dir = T.unsafe(nil)); end

    # Given a hash of OpenSSH configuration options, converts them into
    # a hash of Net::SSH options. Unrecognized options are ignored. The
    # +settings+ hash must have Strings for keys, all downcased, and
    # the returned hash will have Symbols for keys.
    #
    # source://net-ssh//lib/net/ssh/config.rb#177
    def translate(settings); end

    private

    # source://net-ssh//lib/net/ssh/config.rb#352
    def eval_match_conditions(condition, host, settings); end

    # source://net-ssh//lib/net/ssh/config.rb#340
    def included_file_paths(base_dir, config_paths); end

    # Converts the given size into an integer number of bytes.
    #
    # source://net-ssh//lib/net/ssh/config.rb#323
    def interpret_size(size); end

    # source://net-ssh//lib/net/ssh/config.rb#332
    def merge_challenge_response_with_keyboard_interactive(hash); end

    # Converts an ssh_config pattern into a regex for matching against
    # host names.
    #
    # source://net-ssh//lib/net/ssh/config.rb#303
    def pattern2regex(pattern); end

    # source://net-ssh//lib/net/ssh/config.rb#288
    def setup_proxy(type, value); end

    # Tokenize string into tokens.
    # A token is a word or a quoted sequence of words, separated by whitespaces.
    #
    # source://net-ssh//lib/net/ssh/config.rb#348
    def tokenize_config_value(str); end

    # source://net-ssh//lib/net/ssh/config.rb#219
    def translate_config_key(hash, key, value, settings); end

    # source://net-ssh//lib/net/ssh/config.rb#387
    def unquote(string); end
  end
end

# source://net-ssh//lib/net/ssh/connection/constants.rb#3
module Net::SSH::Connection; end

# The channel abstraction. Multiple "channels" can be multiplexed onto a
# single SSH channel, each operating independently and seemingly in parallel.
# This class represents a single such channel. Most operations performed
# with the Net::SSH library will involve using one or more channels.
#
# Channels are intended to be used asynchronously. You request that one be
# opened (via Connection::Session#open_channel), and when it is opened, your
# callback is invoked. Then, you set various other callbacks on the newly
# opened channel, which are called in response to the corresponding events.
# Programming with Net::SSH works best if you think of your programs as
# state machines. Complex programs are best implemented as objects that
# wrap a channel. See Net::SCP and Net::SFTP for examples of how complex
# state machines can be built on top of the SSH protocol.
#
#   ssh.open_channel do |channel|
#     channel.exec("/invoke/some/command") do |ch, success|
#       abort "could not execute command" unless success
#
#       channel.on_data do |ch, data|
#         puts "got stdout: #{data}"
#         channel.send_data "something for stdin\n"
#       end
#
#       channel.on_extended_data do |ch, type, data|
#         puts "got stderr: #{data}"
#       end
#
#       channel.on_close do |ch|
#         puts "channel is closing!"
#       end
#     end
#   end
#
#   ssh.loop
#
# Channels also have a basic hash-like interface, that allows programs to
# store arbitrary state information on a channel object. This helps simplify
# the writing of state machines, especially when you may be juggling
# multiple open channels at the same time.
#
# Note that data sent across SSH channels are governed by maximum packet
# sizes and maximum window sizes. These details are managed internally
# by Net::SSH::Connection::Channel, so you may remain blissfully ignorant
# if you so desire, but you can always inspect the current maximums, as
# well as the remaining window size, using the reader attributes for those
# values.
#
# source://net-ssh//lib/net/ssh/connection/channel.rb#55
class Net::SSH::Connection::Channel
  include ::Net::SSH::Loggable
  include ::Net::SSH::Connection::Constants

  # Instantiates a new channel on the given connection, of the given type,
  # and with the given id. If a block is given, it will be remembered until
  # the channel is confirmed open by the server, and will be invoked at
  # that time (see #do_open_confirmation).
  #
  # This also sets the default maximum packet size and maximum window size.
  #
  # @return [Channel] a new instance of Channel
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#113
  def initialize(connection, type, local_id, max_pkt_size = T.unsafe(nil), max_win_size = T.unsafe(nil), &on_confirm_open); end

  # A shortcut for accessing properties of the channel (see #properties).
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#136
  def [](name); end

  # A shortcut for setting properties of the channel (see #properties).
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#141
  def []=(name, value); end

  # Returns true if the channel exists in the channel list of the session,
  # and false otherwise. This can be used to determine whether a channel has
  # been closed or not.
  #
  #   ssh.loop { channel.active? }
  #
  # @return [Boolean]
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#262
  def active?; end

  # Requests that the channel be closed. It only marks the channel to be closed
  # the CHANNEL_CLOSE message will be sent from event loop
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#299
  def close; end

  # True if close() has been called; NOTE: if the channel has data waiting to
  # be sent then the channel will close after all the data is sent. See
  # closed?() to determine if we have actually sent CHANNEL_CLOSE to server.
  # This may be true for awhile before closed? returns true if we are still
  # sending buffered output to server.
  #
  # @return [Boolean]
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#280
  def closing?; end

  # The underlying Net::SSH::Connection::Session instance that supports this channel.
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#69
  def connection; end

  # Invokes the #on_close callback when the server closes a channel.
  # The channel is the only argument.
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#610
  def do_close; end

  # Invokes the #on_data callback when the server sends data to the
  # channel. This will reduce the available window size on the local end,
  # but does not actually throttle requests that come in illegally when
  # the window size is too small. The callback is invoked with the channel
  # as the first argument, and the data as the second.
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#587
  def do_data(data); end

  # Invokes the #on_eof callback when the server indicates that no
  # further data is forthcoming. The callback is invoked with the channel
  # as the argument.
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#604
  def do_eof; end

  # Invokes the #on_extended_data callback when the server sends
  # extended data to the channel. This will reduce the available window
  # size on the local end. The callback is invoked with the channel,
  # type, and data.
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#596
  def do_extended_data(type, data); end

  # Invokes the next pending request callback with +false+ as the second
  # argument.
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#616
  def do_failure; end

  # Invoked when the server confirms that a channel has been opened.
  # The remote_id is the id of the channel as assigned by the remote host,
  # and max_window and max_packet are the maximum window and maximum
  # packet sizes, respectively. If an open-confirmation callback was
  # given when the channel was created, it is invoked at this time with
  # the channel itself as the sole argument.
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#527
  def do_open_confirmation(remote_id, max_window, max_packet); end

  # Invoked when the server failed to open the channel. If an #on_open_failed
  # callback was specified, it will be invoked with the channel, reason code,
  # and description as arguments. Otherwise, a ChannelOpenFailed exception
  # will be raised.
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#541
  def do_open_failed(reason_code, description); end

  # Invoked when the server sends a channel request. If any #on_request
  # callback has been registered for the specific type of this request,
  # it is invoked. If +want_reply+ is true, a packet will be sent of
  # either CHANNEL_SUCCESS or CHANNEL_FAILURE type. If there was no callback
  # to handle the request, CHANNEL_FAILURE will be sent. Otherwise,
  # CHANNEL_SUCCESS, unless the callback raised ChannelRequestFailed. The
  # callback should accept the channel as the first argument, and the
  # request-specific data as the second.
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#566
  def do_request(request, want_reply, data); end

  # Invokes the next pending request callback with +true+ as the second
  # argument.
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#626
  def do_success; end

  # Invoked when the server sends a CHANNEL_WINDOW_ADJUST packet, and
  # causes the remote window size to be adjusted upwards by the given
  # number of bytes. This has the effect of allowing more data to be sent
  # from the local end to the remote end of the channel.
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#553
  def do_window_adjust(bytes); end

  # Enqueues pending output at the connection as CHANNEL_DATA packets. This
  # does nothing if the channel has not yet been confirmed open (see
  # #do_open_confirmation). This is called automatically by #process, which
  # is called from the event loop (Connection::Session#process). You will
  # generally not need to invoke it directly.
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#503
  def enqueue_pending_output; end

  # Syntactic sugar for setting an environment variable in the remote
  # process' environment. Note that for security reasons, the server may
  # refuse to set certain environment variables, or all, at the server's
  # discretion. If you are connecting to an OpenSSH server, you will
  # need to update the AcceptEnv setting in the sshd_config to include the
  # environment variables you want to send.
  #
  #   channel.env "PATH", "/usr/local/bin"
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#190
  def env(variable_name, variable_value, &block); end

  # Tells the remote end of the channel that no more data is forthcoming
  # from this end of the channel. The remote end may still send data.
  # The CHANNEL_EOF packet will be sent once the output buffer is empty.
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#314
  def eof!; end

  # Returns true if the local end of the channel has declared that no more
  # data is forthcoming (see #eof!). Trying to send data via #send_data when
  # this is true will result in an exception being raised.
  #
  # @return [Boolean]
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#307
  def eof?; end

  # Syntactic sugar for executing a command. Sends a channel request asking
  # that the given command be invoked. If the block is given, it will be
  # called when the server responds. The first parameter will be the
  # channel, and the second will be true or false, indicating whether the
  # request succeeded or not. In this case, success means that the command
  # is being executed, not that it has completed, and failure means that the
  # command altogether failed to be executed.
  #
  #   channel.exec "ls -l /home" do |ch, success|
  #     if success
  #       puts "command has begun executing..."
  #       # this is a good place to hang callbacks like #on_data...
  #     else
  #       puts "alas! the command could not be invoked!"
  #     end
  #   end
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#161
  def exec(command, &block); end

  # True if we have sent CHANNEL_CLOSE to the remote server.
  #
  # @return [Boolean]
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#285
  def local_closed?; end

  # The local id for this channel, assigned by the Net::SSH::Connection::Session instance.
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#60
  def local_id; end

  # The maximum packet size that the local host can receive.
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#72
  def local_maximum_packet_size; end

  # The maximum amount of data that the local end of this channel can
  # receive. This is a total, not per-packet.
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#76
  def local_maximum_window_size; end

  # This is the remaining window size on the local end of this channel. When
  # this reaches zero, no more data can be received.
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#87
  def local_window_size; end

  # Registers a callback to be invoked when the server acknowledges that a
  # channel is closed. This is invoked with the channel as the sole argument.
  #
  #   channel.on_close do |ch|
  #     puts "remote end is closing!"
  #   end
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#401
  def on_close(&block); end

  # Registers a callback to be invoked when data packets are received by the
  # channel. The callback is called with the channel as the first argument,
  # and the data as the second.
  #
  #   channel.on_data do |ch, data|
  #     puts "got data: #{data.inspect}"
  #   end
  #
  # Data received this way is typically the data written by the remote
  # process to its +stdout+ stream.
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#348
  def on_data(&block); end

  # Registers a callback to be invoked when the server indicates that no more
  # data will be sent to the channel (although the channel can still send
  # data to the server). The channel is the sole argument to the callback.
  #
  #   channel.on_eof do |ch|
  #     puts "remote end is done sending data"
  #   end
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#413
  def on_eof(&block); end

  # Registers a callback to be invoked when extended data packets are received
  # by the channel. The callback is called with the channel as the first
  # argument, the data type (as an integer) as the second, and the data as
  # the third. Extended data is almost exclusively used to send +stderr+ data
  # (+type+ == 1). Other extended data types are not defined by the SSH
  # protocol.
  #
  #   channel.on_extended_data do |ch, type, data|
  #     puts "got stderr: #{data.inspect}"
  #   end
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#363
  def on_extended_data(&block); end

  # Registers a callback to be invoked when the server was unable to open
  # the requested channel. The channel itself will be passed to the block,
  # along with the integer "reason code" for the failure, and a textual
  # description of the failure from the server.
  #
  #   channel = session.open_channel do |ch|
  #     # ..
  #   end
  #
  #   channel.on_open_failed { |ch, code, desc| ... }
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#428
  def on_open_failed(&block); end

  # Registers a callback to be invoked for each pass of the event loop for
  # this channel. There are no guarantees on timeliness in the event loop,
  # but it will be called roughly once for each packet received by the
  # connection (not the channel). This callback is invoked with the channel
  # as the sole argument.
  #
  # Here's an example that accumulates the channel data into a variable on
  # the channel itself, and displays individual lines in the input one
  # at a time when the channel is processed:
  #
  #   channel[:data] = ""
  #
  #   channel.on_data do |ch, data|
  #     channel[:data] << data
  #   end
  #
  #   channel.on_process do |ch|
  #     if channel[:data] =~ /^.*?\n/
  #       puts $&
  #       channel[:data] = $'
  #     end
  #   end
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#390
  def on_process(&block); end

  # Registers a callback to be invoked when a channel request of the given
  # type is received. The callback will receive the channel as the first
  # argument, and the associated (unparsed) data as the second. The data
  # will be a Net::SSH::Buffer that you will need to parse, yourself,
  # according to the kind of request you are watching.
  #
  # By default, if the request wants a reply, Net::SSH will send a
  # CHANNEL_SUCCESS response for any request that was handled by a registered
  # callback, and CHANNEL_FAILURE for any that wasn't, but if you want your
  # registered callback to result in a CHANNEL_FAILURE response, just raise
  # Net::SSH::ChannelRequestFailed.
  #
  # Some common channel requests that your programs might want to listen
  # for are:
  #
  # * "exit-status" : the exit status of the remote process will be reported
  #   as a long integer in the data buffer, which you can grab via
  #   data.read_long.
  # * "exit-signal" : if the remote process died as a result of a signal
  #   being sent to it, the signal will be reported as a string in the
  #   data, via data.read_string. (Not all SSH servers support this channel
  #   request type.)
  #
  #     channel.on_request "exit-status" do |ch, data|
  #       puts "process terminated with exit status: #{data.read_long}"
  #     end
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#459
  def on_request(type, &block); end

  # The output buffer for this channel. Data written to the channel is
  # enqueued here, to be written as CHANNEL_DATA packets during each pass of
  # the event loop. See Connection::Session#process and #enqueue_pending_output.
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#100
  def output; end

  # The list of pending requests. Each time a request is sent which requires
  # a reply, the corresponding callback is pushed onto this queue. As responses
  # arrive, they are shifted off the front and handled.
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#105
  def pending_requests; end

  # If an #on_process handler has been set up, this will cause it to be
  # invoked (passing the channel itself as an argument). It also causes all
  # pending output to be enqueued as CHANNEL_DATA packets (see #enqueue_pending_output).
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#322
  def process; end

  # A hash of properties for this channel. These can be used to store state
  # information about this channel. See also #[] and #[]=.
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#95
  def properties; end

  # source://net-ssh//lib/net/ssh/connection/channel.rb#293
  def remote_closed!; end

  # @return [Boolean]
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#289
  def remote_closed?; end

  # The remote id for this channel, assigned by the remote host.
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#63
  def remote_id; end

  # The maximum packet size that the remote host can receive.
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#79
  def remote_maximum_packet_size; end

  # The maximum amount of data that the remote end of this channel can
  # receive. This is a total, not per-packet.
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#83
  def remote_maximum_window_size; end

  # This is the remaining window size on the remote end of this channel. When
  # this reaches zero, no more data can be sent.
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#91
  def remote_window_size; end

  # Requests that a pseudo-tty (or "pty") be made available for this channel.
  # This is useful when you want to invoke and interact with some kind of
  # screen-based program (e.g., vim, or some menuing system).
  #
  # Note, that without a pty some programs (e.g. sudo, or subversion) on
  # some systems, will not be able to run interactively, and will error
  # instead of prompt if they ever need some user interaction.
  #
  # Note, too, that when a pty is requested, user's shell configuration
  # scripts (.bashrc and such) are not run by default, whereas they are
  # run when a pty is not present.
  #
  #   channel.request_pty do |ch, success|
  #     if success
  #       puts "pty successfully obtained"
  #     else
  #       puts "could not obtain pty"
  #     end
  #   end
  #
  # @raise [ArgumentError]
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#221
  def request_pty(opts = T.unsafe(nil), &block); end

  # Sends a new channel request with the given name. The extra +data+
  # parameter must either be empty, or consist of an even number of
  # arguments. See Net::SSH::Buffer.from for a description of their format.
  # If a block is given, it is registered as a callback for a pending
  # request, and the packet will be flagged so that the server knows a
  # reply is required. If no block is given, the server will send no
  # response to this request. Responses, where required, will cause the
  # callback to be invoked with the channel as the first argument, and
  # either true or false as the second, depending on whether the request
  # succeeded or not. The meaning of "success" and "failure" in this context
  # is dependent on the specific request that was sent.
  #
  #   channel.send_channel_request "shell" do |ch, success|
  #     if success
  #       puts "user shell started successfully"
  #     else
  #       puts "could not start user shell"
  #     end
  #   end
  #
  # Most channel requests you'll want to send are already wrapped in more
  # convenient helper methods (see #exec and #subsystem).
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#486
  def send_channel_request(request_name, *data, &callback); end

  # Sends data to the channel's remote endpoint. This usually has the
  # effect of sending the given string to the remote process' stdin stream.
  # Note that it does not immediately send the data across the channel,
  # but instead merely appends the given data to the channel's output buffer,
  # preparatory to being packaged up and sent out the next time the connection
  # is accepting data. (A connection might not be accepting data if, for
  # instance, it has filled its data window and has not yet been resized by
  # the remote end-point.)
  #
  # This will raise an exception if the channel has previously declared
  # that no more data will be sent (see #eof!).
  #
  #   channel.send_data("the password\n")
  #
  # @raise [EOFError]
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#252
  def send_data(data); end

  # Syntactic sugar for requesting that a subsystem be started. Subsystems
  # are a way for other protocols (like SFTP) to be run, using SSH as
  # the transport. Generally, you'll never need to call this directly unless
  # you are the implementor of something that consumes an SSH subsystem, like
  # SFTP.
  #
  #   channel.subsystem("sftp") do |ch, success|
  #     if success
  #       puts "subsystem successfully started"
  #     else
  #       puts "subsystem could not be started"
  #     end
  #   end
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#178
  def subsystem(subsystem, &block); end

  # The type of this channel, usually "session".
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#66
  def type; end

  # Runs the SSH event loop until the channel is no longer active. This is
  # handy for blocking while you wait for some channel to finish.
  #
  #   channel.exec("grep ...") { ... }
  #   channel.wait
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#271
  def wait; end

  private

  # Gets an +Array+ of local environment variables in the remote process'
  # environment.
  # A variable name can either be described by a +Regexp+ or +String+.
  #
  #   channel.forward_local_env [/^GIT_.*$/, "LANG"]
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#668
  def forward_local_env(env_variable_patterns); end

  # Set a +Hash+ of environment variables in the remote process' environment.
  #
  #   channel.set_remote_env foo: 'bar', baz: 'whale'
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#685
  def set_remote_env(env); end

  # Updates the local window size by the given amount. If the window
  # size drops to less than half of the local maximum (an arbitrary
  # threshold), a CHANNEL_WINDOW_ADJUST message will be sent to the
  # server telling it that the window size has grown.
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#649
  def update_local_window_size(size); end

  # Runs the SSH event loop until the remote confirmed channel open
  # experimental api
  #
  # source://net-ssh//lib/net/ssh/connection/channel.rb#638
  def wait_until_open_confirmed; end
end

# source://net-ssh//lib/net/ssh/connection/channel.rb#643
Net::SSH::Connection::Channel::GOOD_LOCAL_MAXIUMUM_WINDOW_SIZE = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/connection/channel.rb#642
Net::SSH::Connection::Channel::LOCAL_WINDOW_SIZE_INCREMENT = T.let(T.unsafe(nil), Integer)

# A hash of the valid PTY options (see #request_pty).
#
# source://net-ssh//lib/net/ssh/connection/channel.rb#195
Net::SSH::Connection::Channel::VALID_PTY_OPTIONS = T.let(T.unsafe(nil), Hash)

# Definitions of constants that are specific to the connection layer of the
# SSH protocol.
#
# source://net-ssh//lib/net/ssh/connection/constants.rb#7
module Net::SSH::Connection::Constants; end

# source://net-ssh//lib/net/ssh/connection/constants.rb#28
Net::SSH::Connection::Constants::CHANNEL_CLOSE = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/connection/constants.rb#25
Net::SSH::Connection::Constants::CHANNEL_DATA = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/connection/constants.rb#27
Net::SSH::Connection::Constants::CHANNEL_EOF = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/connection/constants.rb#26
Net::SSH::Connection::Constants::CHANNEL_EXTENDED_DATA = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/connection/constants.rb#31
Net::SSH::Connection::Constants::CHANNEL_FAILURE = T.let(T.unsafe(nil), Integer)

# --
# Channel related messages
# ++
#
# source://net-ssh//lib/net/ssh/connection/constants.rb#21
Net::SSH::Connection::Constants::CHANNEL_OPEN = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/connection/constants.rb#22
Net::SSH::Connection::Constants::CHANNEL_OPEN_CONFIRMATION = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/connection/constants.rb#23
Net::SSH::Connection::Constants::CHANNEL_OPEN_FAILURE = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/connection/constants.rb#29
Net::SSH::Connection::Constants::CHANNEL_REQUEST = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/connection/constants.rb#30
Net::SSH::Connection::Constants::CHANNEL_SUCCESS = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/connection/constants.rb#24
Net::SSH::Connection::Constants::CHANNEL_WINDOW_ADJUST = T.let(T.unsafe(nil), Integer)

# --
# Connection protocol generic messages
# ++
#
# source://net-ssh//lib/net/ssh/connection/constants.rb#13
Net::SSH::Connection::Constants::GLOBAL_REQUEST = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/connection/constants.rb#15
Net::SSH::Connection::Constants::REQUEST_FAILURE = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/connection/constants.rb#14
Net::SSH::Connection::Constants::REQUEST_SUCCESS = T.let(T.unsafe(nil), Integer)

# EventLoop can be shared across multiple sessions
#
# one issue is with blocks passed to loop, etc.
# they should get current session as parameter, but in
# case you're using multiple sessions in an event loop it doesnt makes sense
# and we don't pass session.
#
# source://net-ssh//lib/net/ssh/connection/event_loop.rb#12
class Net::SSH::Connection::EventLoop
  include ::Net::SSH::Loggable

  # @return [EventLoop] a new instance of EventLoop
  #
  # source://net-ssh//lib/net/ssh/connection/event_loop.rb#15
  def initialize(logger = T.unsafe(nil)); end

  # Call preprocess on each session. If block given and that
  # block retuns false then we exit the processing
  #
  # source://net-ssh//lib/net/ssh/connection/event_loop.rb#47
  def ev_preprocess(&block); end

  # source://net-ssh//lib/net/ssh/connection/event_loop.rb#54
  def ev_select_and_postprocess(wait); end

  # process until timeout
  # if a block is given a session will be removed from loop
  # if block returns false for that session
  #
  # source://net-ssh//lib/net/ssh/connection/event_loop.rb#27
  def process(wait = T.unsafe(nil), &block); end

  # process the event loop but only for the sepcified session
  #
  # source://net-ssh//lib/net/ssh/connection/event_loop.rb#34
  def process_only(session, wait = T.unsafe(nil)); end

  # source://net-ssh//lib/net/ssh/connection/event_loop.rb#20
  def register(session); end
end

# source://net-ssh//lib/net/ssh/connection/keepalive.rb#6
class Net::SSH::Connection::Keepalive
  include ::Net::SSH::Loggable

  # @return [Keepalive] a new instance of Keepalive
  #
  # source://net-ssh//lib/net/ssh/connection/keepalive.rb#9
  def initialize(session); end

  # @return [Boolean]
  #
  # source://net-ssh//lib/net/ssh/connection/keepalive.rb#20
  def enabled?; end

  # source://net-ssh//lib/net/ssh/connection/keepalive.rb#24
  def interval; end

  # source://net-ssh//lib/net/ssh/connection/keepalive.rb#34
  def keepalive_maxcount; end

  # source://net-ssh//lib/net/ssh/connection/keepalive.rb#16
  def options; end

  # source://net-ssh//lib/net/ssh/connection/keepalive.rb#38
  def send_as_needed(was_events); end

  # @return [Boolean]
  #
  # source://net-ssh//lib/net/ssh/connection/keepalive.rb#28
  def should_send?; end
end

# A session class representing the connection service running on top of
# the SSH transport layer. It manages the creation of channels (see
# #open_channel), and the dispatching of messages to the various channels.
# It also encapsulates the SSH event loop (via #loop and #process),
# and serves as a central point-of-reference for all SSH-related services (e.g.
# port forwarding, SFTP, SCP, etc.).
#
# You will rarely (if ever) need to instantiate this class directly; rather,
# you'll almost always use Net::SSH.start to initialize a new network
# connection, authenticate a user, and return a new connection session,
# all in one call.
#
#   Net::SSH.start("localhost", "user") do |ssh|
#     # 'ssh' is an instance of Net::SSH::Connection::Session
#     ssh.exec! "/etc/init.d/some_process start"
#   end
#
# source://net-ssh//lib/net/ssh/connection/session.rb#28
class Net::SSH::Connection::Session
  include ::Net::SSH::Loggable
  include ::Net::SSH::Connection::Constants

  # Create a new connection service instance atop the given transport
  # layer. Initializes the listeners to be only the underlying socket object.
  #
  # @return [Session] a new instance of Session
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#69
  def initialize(transport, options = T.unsafe(nil)); end

  # Retrieves a custom property from this instance. This can be used to
  # store additional state in applications that must manage multiple
  # SSH connections.
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#95
  def [](key); end

  # Sets a custom property for this instance.
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#100
  def []=(key, value); end

  # Returns +true+ if there are any channels currently active on this
  # session. By default, this will not include "invisible" channels
  # (such as those created by forwarding ports and such), but if you pass
  # a +true+ value for +include_invisible+, then those will be counted.
  #
  # This can be useful for determining whether the event loop should continue
  # to be run.
  #
  #   ssh.loop { ssh.busy? }
  #
  # @return [Boolean]
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#153
  def busy?(include_invisible = T.unsafe(nil)); end

  # The map of specialized handlers for opening specific channel types. See
  # #on_open_channel.
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#52
  def channel_open_handlers; end

  # The map of channels, each key being the local-id for the channel.
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#45
  def channels; end

  # source://net-ssh//lib/net/ssh/connection/session.rb#521
  def cleanup_channel(channel); end

  # Closes the session gracefully, blocking until all channels have
  # successfully closed, and then closes the underlying transport layer
  # connection.
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#122
  def close; end

  # Returns true if the underlying transport has been closed. Note that
  # this can be a little misleading, since if the remote server has
  # closed the connection, the local end will still think it is open
  # until the next operation on the socket. Nevertheless, this method can
  # be useful if you just want to know if _you_ have closed the connection.
  #
  # @return [Boolean]
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#115
  def closed?; end

  # Returns the file descriptors the event loop should wait for read/write events,
  # we also return the max wait
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#254
  def ev_do_calculate_rw_wait(wait); end

  # It loops over the given arrays of reader IO's and writer IO's,
  # processing them as needed, and
  # then calls Net::SSH::Transport::Session#rekey_as_needed to allow the
  # transport layer to rekey. Then returns true.
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#269
  def ev_do_handle_events(readers, writers); end

  # calls Net::SSH::Transport::Session#rekey_as_needed to allow the
  # transport layer to rekey
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#288
  def ev_do_postprocess(was_events); end

  # Called by event loop to process available data before going to
  # event multiplexing
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#247
  def ev_preprocess(&block); end

  # A convenience method for executing a command and interacting with it. If
  # no block is given, all output is printed via $stdout and $stderr. Otherwise,
  # the block is called for each data and extended data packet, with three
  # arguments: the channel object, a symbol indicating the data type
  # (:stdout or :stderr), and the data (as a string).
  #
  # Note that this method returns immediately, and requires an event loop
  # (see Session#loop) in order for the command to actually execute.
  #
  # This is effectively identical to calling #open_channel, and then
  # Net::SSH::Connection::Channel#exec, and then setting up the channel
  # callbacks. However, for most uses, this will be sufficient.
  #
  #   ssh.exec "grep something /some/files" do |ch, stream, data|
  #     if stream == :stderr
  #       puts "ERROR: #{data}"
  #     else
  #       puts data
  #     end
  #   end
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#378
  def exec(command, status: T.unsafe(nil), &block); end

  # Same as #exec, except this will block until the command finishes. Also,
  # if no block is given, this will return all output (stdout and stderr)
  # as a single string.
  #
  #   matches = ssh.exec!("grep something /some/files")
  #
  # the returned string has an exitstatus method to query it's exit satus
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#419
  def exec!(command, status: T.unsafe(nil), &block); end

  # Returns a reference to the Net::SSH::Service::Forward service, which can
  # be used for forwarding ports over SSH.
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#492
  def forward; end

  # Returns the name of the host that was given to the transport layer to
  # connect to.
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#106
  def host; end

  # Adds an IO object for the event loop to listen to. If a callback
  # is given, it will be invoked when the io is ready to be read, otherwise,
  # the io will merely have its #fill method invoked.
  #
  # Any +io+ value passed to this method _must_ have mixed into it the
  # Net::SSH::BufferedIo functionality, typically by calling #extend on the
  # object.
  #
  # The following example executes a process on the remote server, opens
  # a socket to somewhere, and then pipes data from that socket to the
  # remote process' stdin stream:
  #
  #   channel = ssh.open_channel do |ch|
  #     ch.exec "/some/process/that/wants/input" do |ch, success|
  #       abort "can't execute!" unless success
  #
  #       io = TCPSocket.new(somewhere, port)
  #       io.extend(Net::SSH::BufferedIo)
  #       ssh.listen_to(io)
  #
  #       ch.on_process do
  #         if io.available > 0
  #           ch.send_data(io.read_available)
  #         end
  #       end
  #
  #       ch.on_close do
  #         ssh.stop_listening_to(io)
  #         io.close
  #       end
  #     end
  #   end
  #
  #   channel.wait
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#480
  def listen_to(io, &callback); end

  # The map of listeners that the event loop knows about. See #listen_to.
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#48
  def listeners; end

  # The main event loop. Calls #process until #process returns false. If a
  # block is given, it is passed to #process, otherwise a default proc is
  # used that just returns true if there are any channels active (see #busy?).
  # The # +wait+ parameter is also passed through to #process (where it is
  # interpreted as the maximum number of seconds to wait for IO.select to return).
  #
  #   # loop for as long as there are any channels active
  #   ssh.loop
  #
  #   # loop for as long as there are any channels active, but make sure
  #   # the event loop runs at least once per 0.1 second
  #   ssh.loop(0.1)
  #
  #   # loop until ctrl-C is pressed
  #   int_pressed = false
  #   trap("INT") { int_pressed = true }
  #   ssh.loop(0.1) { not int_pressed }
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#178
  def loop(wait = T.unsafe(nil), &block); end

  # If the #preprocess and #postprocess callbacks for this session need to run
  # periodically, this method returns the maximum number of seconds which may
  # pass between callbacks.
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#531
  def max_select_wait_time; end

  # Registers a handler to be invoked when the server sends a global request
  # of the given type. The callback receives the request data as the first
  # parameter, and true/false as the second (indicating whether a response
  # is required). If the callback sends the response, it should return
  # :sent. Otherwise, if it returns true, REQUEST_SUCCESS will be sent, and
  # if it returns false, REQUEST_FAILURE will be sent.
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#516
  def on_global_request(type, &block); end

  # Registers a handler to be invoked when the server wants to open a
  # channel on the client. The callback receives the connection object,
  # the new channel object, and the packet itself as arguments, and should
  # raise ChannelOpenFailed if it is unable to open the channel for some
  # reason. Otherwise, the channel will be opened and a confirmation message
  # sent to the server.
  #
  # This is used by the Net::SSH::Service::Forward service to open a channel
  # when a remote forwarded port receives a connection. However, you are
  # welcome to register handlers for other channel types, as needed.
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#506
  def on_open_channel(type, &block); end

  # Requests that a new channel be opened. By default, the channel will be
  # of type "session", but if you know what you're doing you can select any
  # of the channel types supported by the SSH protocol. The +extra+ parameters
  # must be even in number and conform to the same format as described for
  # Net::SSH::Buffer.from. If a callback is given, it will be invoked when
  # the server confirms that the channel opened successfully. The sole parameter
  # for the callback is the channel object itself.
  #
  # In general, you'll use #open_channel without any arguments; the only
  # time you'd want to set the channel type or pass additional initialization
  # data is if you were implementing an SSH extension.
  #
  #   channel = ssh.open_channel do |ch|
  #     ch.exec "grep something /some/files" do |ch, success|
  #       ...
  #     end
  #   end
  #
  #   channel.wait
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#337
  def open_channel(type = T.unsafe(nil), *extra, &on_confirm); end

  # The map of options that were used to initialize this instance.
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#39
  def options; end

  # The list of callbacks for pending requests. See #send_global_request.
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#55
  def pending_requests; end

  # This is called internally as part of #process.
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#261
  def postprocess(readers, writers); end

  # This is called internally as part of #process. It dispatches any
  # available incoming packets, and then runs Net::SSH::Connection::Channel#process
  # for any active channels. If a block is given, it is invoked at the
  # start of the method and again at the end, and if the block ever returns
  # false, this method returns false. Otherwise, it returns true.
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#238
  def preprocess(&block); end

  # The core of the event loop. It processes a single iteration of the event
  # loop. If a block is given, it should return false when the processing
  # should abort, which causes #process to return false. Otherwise,
  # #process returns true. The session itself is yielded to the block as its
  # only argument.
  #
  # If +wait+ is nil (the default), this method will block until any of the
  # monitored IO objects are ready to be read from or written to. If you want
  # it to not block, you can pass 0, or you can pass any other numeric value
  # to indicate that it should block for no more than that many seconds.
  # Passing 0 is a good way to poll the connection, but if you do it too
  # frequently it can make your CPU quite busy!
  #
  # This will also cause all active channels to be processed once each (see
  # Net::SSH::Connection::Channel#on_process).
  #
  # TODO revise example
  #
  #   # process multiple Net::SSH connections in parallel
  #   connections = [
  #     Net::SSH.start("host1", ...),
  #     Net::SSH.start("host2", ...)
  #   ]
  #
  #   connections.each do |ssh|
  #     ssh.exec "grep something /in/some/files"
  #   end
  #
  #   condition = Proc.new { |s| s.busy? }
  #
  #   loop do
  #     connections.delete_if { |ssh| !ssh.process(0.1, &condition) }
  #     break if connections.empty?
  #   end
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#226
  def process(wait = T.unsafe(nil), &block); end

  # The collection of custom properties for this instance. (See #[] and #[]=).
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#42
  def properties; end

  # Send a global request of the given type. The +extra+ parameters must
  # be even in number, and conform to the same format as described for
  # Net::SSH::Buffer.from. If a callback is not specified, the request will
  # not require a response from the server, otherwise the server is required
  # to respond and indicate whether the request was successful or not. This
  # success or failure is indicated by the callback being invoked, with the
  # first parameter being true or false (success, or failure), and the second
  # being the packet itself.
  #
  # Generally, Net::SSH will manage global requests that need to be sent
  # (e.g. port forward requests and such are handled in the Net::SSH::Service::Forward
  # class, for instance). However, there may be times when you need to
  # send a global request that isn't explicitly handled by Net::SSH, and so
  # this method is available to you.
  #
  #   ssh.send_global_request("keep-alive@openssh.com")
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#310
  def send_global_request(type, *extra, &callback); end

  # Enqueues a message to be sent to the server as soon as the socket is
  # available for writing. Most programs will never need to call this, but
  # if you are implementing an extension to the SSH protocol, or if you
  # need to send a packet that Net::SSH does not directly support, you can
  # use this to send it.
  #
  #  ssh.send_message(Buffer.from(:byte, REQUEST_SUCCESS).to_s)
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#442
  def send_message(message); end

  # source://net-sftp/3.0.0/lib/net/sftp.rb#71
  def sftp(wait = T.unsafe(nil)); end

  # Performs a "hard" shutdown of the connection. In general, this should
  # never be done, but it might be necessary (in a rescue clause, for instance,
  # when the connection needs to close but you don't know the status of the
  # underlying protocol's state).
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#137
  def shutdown!; end

  # Removes the given io object from the listeners collection, so that the
  # event loop will no longer monitor it.
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#486
  def stop_listening_to(io); end

  # The underlying transport layer abstraction (see Net::SSH::Transport::Session).
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#36
  def transport; end

  private

  # source://net-ssh//lib/net/ssh/connection/session.rb#681
  def channel_close(packet); end

  # source://net-ssh//lib/net/ssh/connection/session.rb#567
  def channel_closed(channel); end

  # source://net-ssh//lib/net/ssh/connection/session.rb#666
  def channel_data(packet); end

  # source://net-ssh//lib/net/ssh/connection/session.rb#676
  def channel_eof(packet); end

  # source://net-ssh//lib/net/ssh/connection/session.rb#671
  def channel_extended_data(packet); end

  # source://net-ssh//lib/net/ssh/connection/session.rb#693
  def channel_failure(packet); end

  # Called when the server wants to open a channel. If no registered
  # channel handler exists for the given channel type, CHANNEL_OPEN_FAILURE
  # is returned, otherwise the callback is invoked and everything proceeds
  # accordingly.
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#611
  def channel_open(packet); end

  # source://net-ssh//lib/net/ssh/connection/session.rb#644
  def channel_open_confirmation(packet); end

  # source://net-ssh//lib/net/ssh/connection/session.rb#650
  def channel_open_failure(packet); end

  # source://net-ssh//lib/net/ssh/connection/session.rb#661
  def channel_request(packet); end

  # source://net-ssh//lib/net/ssh/connection/session.rb#688
  def channel_success(packet); end

  # source://net-ssh//lib/net/ssh/connection/session.rb#656
  def channel_window_adjust(packet); end

  # Read all pending packets from the connection and dispatch them as
  # appropriate. Returns as soon as there are no more pending packets.
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#544
  def dispatch_incoming_packets(raise_disconnect_errors: T.unsafe(nil)); end

  # iterate channels with the posibility of callbacks opening new channels during the iteration
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#538
  def each_channel(&block); end

  # source://net-ssh//lib/net/ssh/connection/session.rb#561
  def force_channel_cleanup_on_close; end

  # Returns the next available channel id to be assigned, and increments
  # the counter.
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#557
  def get_next_channel_id; end

  # Invoked when a global request is received. The registered global
  # request callback will be invoked, if one exists, and the necessary
  # reply returned.
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#578
  def global_request(packet); end

  # source://net-ssh//lib/net/ssh/connection/session.rb#698
  def io_select_wait(wait); end

  # preserve a reference to Kernel#loop
  def loop_forever; end

  # Invokes the next pending request callback with +false+.
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#601
  def request_failure(packet); end

  # Invokes the next pending request callback with +true+.
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#594
  def request_success(packet); end
end

# Default IO.select timeout threshold
#
# source://net-ssh//lib/net/ssh/connection/session.rb#33
Net::SSH::Connection::Session::DEFAULT_IO_SELECT_TIMEOUT = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/connection/session.rb#702
Net::SSH::Connection::Session::MAP = T.let(T.unsafe(nil), Hash)

# source://net-ssh//lib/net/ssh/connection/session.rb#57
class Net::SSH::Connection::Session::NilChannel
  # @return [NilChannel] a new instance of NilChannel
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#58
  def initialize(session); end

  # source://net-ssh//lib/net/ssh/connection/session.rb#62
  def method_missing(sym, *args); end
end

# source://net-ssh//lib/net/ssh/connection/session.rb#349
class Net::SSH::Connection::Session::StringWithExitstatus < ::String
  # @return [StringWithExitstatus] a new instance of StringWithExitstatus
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#350
  def initialize(str, exitstatus); end

  # Returns the value of attribute exitstatus.
  #
  # source://net-ssh//lib/net/ssh/connection/session.rb#355
  def exitstatus; end
end

# optimized version for a single session
#
# source://net-ssh//lib/net/ssh/connection/event_loop.rb#95
class Net::SSH::Connection::SingleSessionEventLoop < ::Net::SSH::Connection::EventLoop
  # Compatibility for original single session event loops:
  # we call block with session as argument
  #
  # source://net-ssh//lib/net/ssh/connection/event_loop.rb#98
  def ev_preprocess(&block); end

  # source://net-ssh//lib/net/ssh/connection/event_loop.rb#105
  def ev_select_and_postprocess(wait); end
end

# These constants are used when requesting a pseudo-terminal (via
# Net::SSH::Connection::Channel#request_pty). The descriptions for each are
# taken directly from RFC 4254 ("The Secure Shell (SSH) Connection Protocol"),
# http://tools.ietf.org/html/rfc4254.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#9
module Net::SSH::Connection::Term; end

# 7 bit mode.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#162
Net::SSH::Connection::Term::CS7 = T.let(T.unsafe(nil), Integer)

# 8 bit mode.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#165
Net::SSH::Connection::Term::CS8 = T.let(T.unsafe(nil), Integer)

# Enable echoing.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#114
Net::SSH::Connection::Term::ECHO = T.let(T.unsafe(nil), Integer)

# Echo control characters as ^(Char).
#
# source://net-ssh//lib/net/ssh/connection/term.rb#135
Net::SSH::Connection::Term::ECHOCTL = T.let(T.unsafe(nil), Integer)

# Visually erase chars.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#117
Net::SSH::Connection::Term::ECHOE = T.let(T.unsafe(nil), Integer)

# Kill character discards current line.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#120
Net::SSH::Connection::Term::ECHOK = T.let(T.unsafe(nil), Integer)

# Visual erase for line kill.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#138
Net::SSH::Connection::Term::ECHOKE = T.let(T.unsafe(nil), Integer)

# Echo NL even if ECHO is off.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#123
Net::SSH::Connection::Term::ECHONL = T.let(T.unsafe(nil), Integer)

# Canonicalize input lines.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#107
Net::SSH::Connection::Term::ICANON = T.let(T.unsafe(nil), Integer)

# Map CR to NL on input.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#86
Net::SSH::Connection::Term::ICRNL = T.let(T.unsafe(nil), Integer)

# Enable extensions.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#132
Net::SSH::Connection::Term::IEXTEN = T.let(T.unsafe(nil), Integer)

# Ignore CR on input.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#83
Net::SSH::Connection::Term::IGNCR = T.let(T.unsafe(nil), Integer)

# The ignore parity flag. The parameter SHOULD be 0 if this flag is FALSE,
# and 1 if it is TRUE.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#68
Net::SSH::Connection::Term::IGNPAR = T.let(T.unsafe(nil), Integer)

# Ring bell on input queue full.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#101
Net::SSH::Connection::Term::IMAXBEL = T.let(T.unsafe(nil), Integer)

# Map NL into CR on input.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#80
Net::SSH::Connection::Term::INCLR = T.let(T.unsafe(nil), Integer)

# Enable checking of parity errors.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#74
Net::SSH::Connection::Term::INPCK = T.let(T.unsafe(nil), Integer)

# Enable signals INTR, QUIT, [D]SUSP.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#104
Net::SSH::Connection::Term::ISIG = T.let(T.unsafe(nil), Integer)

# Strip 8th bit off characters.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#77
Net::SSH::Connection::Term::ISTRIP = T.let(T.unsafe(nil), Integer)

# Translate uppercase characters to lowercase.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#89
Net::SSH::Connection::Term::IUCLC = T.let(T.unsafe(nil), Integer)

# Any char will restart after stop.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#95
Net::SSH::Connection::Term::IXANY = T.let(T.unsafe(nil), Integer)

# Enable input flow control.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#98
Net::SSH::Connection::Term::IXOFF = T.let(T.unsafe(nil), Integer)

# Enable output flow control.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#92
Net::SSH::Connection::Term::IXON = T.let(T.unsafe(nil), Integer)

# Don't flush after interrupt.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#126
Net::SSH::Connection::Term::NOFLSH = T.let(T.unsafe(nil), Integer)

# Translate carriage return to newline (output).
#
# source://net-ssh//lib/net/ssh/connection/term.rb#153
Net::SSH::Connection::Term::OCRNL = T.let(T.unsafe(nil), Integer)

# Convert lowercase to uppercase.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#147
Net::SSH::Connection::Term::OLCUC = T.let(T.unsafe(nil), Integer)

# Map NL to CR-NL.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#150
Net::SSH::Connection::Term::ONLCR = T.let(T.unsafe(nil), Integer)

# Newline performs a carriage return (output).
#
# source://net-ssh//lib/net/ssh/connection/term.rb#159
Net::SSH::Connection::Term::ONLRET = T.let(T.unsafe(nil), Integer)

# Translate newline to carriage return-newline (output).
#
# source://net-ssh//lib/net/ssh/connection/term.rb#156
Net::SSH::Connection::Term::ONOCR = T.let(T.unsafe(nil), Integer)

# Enable output processing.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#144
Net::SSH::Connection::Term::OPOST = T.let(T.unsafe(nil), Integer)

# Parity enable.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#168
Net::SSH::Connection::Term::PARENB = T.let(T.unsafe(nil), Integer)

# Mark parity and framing errors.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#71
Net::SSH::Connection::Term::PARMRK = T.let(T.unsafe(nil), Integer)

# Odd parity, else even.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#171
Net::SSH::Connection::Term::PARODD = T.let(T.unsafe(nil), Integer)

# Retype pending input.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#141
Net::SSH::Connection::Term::PENDIN = T.let(T.unsafe(nil), Integer)

# Stop background jobs from output.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#129
Net::SSH::Connection::Term::TOSTOP = T.let(T.unsafe(nil), Integer)

# Specifies the input baud rate in bits per second.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#174
Net::SSH::Connection::Term::TTY_OP_ISPEED = T.let(T.unsafe(nil), Integer)

# Specifies the output baud rate in bits per second.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#177
Net::SSH::Connection::Term::TTY_OP_OSPEED = T.let(T.unsafe(nil), Integer)

# Toggles the flushing of terminal output.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#64
Net::SSH::Connection::Term::VDISCARD = T.let(T.unsafe(nil), Integer)

# Another suspend character.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#42
Net::SSH::Connection::Term::VDSUSP = T.let(T.unsafe(nil), Integer)

# End-of-file character (sends EOF from the terminal).
#
# source://net-ssh//lib/net/ssh/connection/term.rb#24
Net::SSH::Connection::Term::VEOF = T.let(T.unsafe(nil), Integer)

# End-of-line character in addition to carriage return and/or linefeed.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#27
Net::SSH::Connection::Term::VEOL = T.let(T.unsafe(nil), Integer)

# Additional end-of-line character.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#30
Net::SSH::Connection::Term::VEOL2 = T.let(T.unsafe(nil), Integer)

# Erase the character to left of the cursor.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#18
Net::SSH::Connection::Term::VERASE = T.let(T.unsafe(nil), Integer)

# Character to flush output.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#55
Net::SSH::Connection::Term::VFLUSH = T.let(T.unsafe(nil), Integer)

# Interrupt character; 255 if none. Similarly for the other characters.
# Not all of these characters are supported on all systems.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#12
Net::SSH::Connection::Term::VINTR = T.let(T.unsafe(nil), Integer)

# Kill the current input line.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#21
Net::SSH::Connection::Term::VKILL = T.let(T.unsafe(nil), Integer)

# Enter the next character typed literally, even if it is a special
# character.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#52
Net::SSH::Connection::Term::VLNEXT = T.let(T.unsafe(nil), Integer)

# The quit character (sends SIGQUIT signal on POSIX systems).
#
# source://net-ssh//lib/net/ssh/connection/term.rb#15
Net::SSH::Connection::Term::VQUIT = T.let(T.unsafe(nil), Integer)

# Reprints the current input line.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#45
Net::SSH::Connection::Term::VREPRINT = T.let(T.unsafe(nil), Integer)

# Continues paused output (normally control-Q).
#
# source://net-ssh//lib/net/ssh/connection/term.rb#33
Net::SSH::Connection::Term::VSTART = T.let(T.unsafe(nil), Integer)

# Prints system status line (load, command, pid, etc).
#
# source://net-ssh//lib/net/ssh/connection/term.rb#61
Net::SSH::Connection::Term::VSTATUS = T.let(T.unsafe(nil), Integer)

# Pauses output (normally control-S).
#
# source://net-ssh//lib/net/ssh/connection/term.rb#36
Net::SSH::Connection::Term::VSTOP = T.let(T.unsafe(nil), Integer)

# Suspends the current program.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#39
Net::SSH::Connection::Term::VSUSP = T.let(T.unsafe(nil), Integer)

# Switch to a different shell layer.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#58
Net::SSH::Connection::Term::VSWITCH = T.let(T.unsafe(nil), Integer)

# Erases a word left of cursor.
#
# source://net-ssh//lib/net/ssh/connection/term.rb#48
Net::SSH::Connection::Term::VWERASE = T.let(T.unsafe(nil), Integer)

# Enable input and output of uppercase characters by preceding their
# lowercase equivalents with "\".
#
# source://net-ssh//lib/net/ssh/connection/term.rb#111
Net::SSH::Connection::Term::XCASE = T.let(T.unsafe(nil), Integer)

# This exception is raised when a connection attempt times out.
#
# source://net-ssh//lib/net/ssh/errors.rb#12
class Net::SSH::ConnectionTimeout < ::Net::SSH::Exception; end

# This exception is raised when the remote host has disconnected
# unexpectedly.
#
# source://net-ssh//lib/net/ssh/errors.rb#16
class Net::SSH::Disconnect < ::Net::SSH::Exception; end

# A general exception class, to act as the ancestor of all other Net::SSH
# exception classes.
#
# source://net-ssh//lib/net/ssh/errors.rb#5
class Net::SSH::Exception < ::RuntimeError; end

# Fixes for two issues by Miklós Fazekas:
#
#   * if client closes a forwarded connection, but the server is
#     reading, net-ssh terminates with IOError socket closed.
#   * if client force closes (RST) a forwarded connection, but
#     server is reading, net-ssh terminates with [an exception]
#
# See:
#
#    http://net-ssh.lighthouseapp.com/projects/36253/tickets/7
#    http://github.com/net-ssh/net-ssh/tree/portfwfix
#
# source://net-ssh//lib/net/ssh/buffered_io.rb#168
module Net::SSH::ForwardedBufferedIo
  # source://net-ssh//lib/net/ssh/buffered_io.rb#169
  def fill(n = T.unsafe(nil)); end

  # source://net-ssh//lib/net/ssh/buffered_io.rb#185
  def send_pending; end
end

# Base class for host key exceptions. When rescuing this exception, you can
# inspect the key fingerprint and, if you want to proceed anyway, simply call
# the remember_host! method on the exception, and then retry.
#
# source://net-ssh//lib/net/ssh/errors.rb#46
class Net::SSH::HostKeyError < ::Net::SSH::Exception
  # An accessor for getting at the data that was used to look up the host
  # (see also #fingerprint, #host, #port, #ip, and #key).
  #
  # source://net-ssh//lib/net/ssh/errors.rb#55
  def [](key); end

  # the callback to use when #remember_host! is called
  #
  # source://net-ssh//lib/net/ssh/errors.rb#48
  def callback=(_arg0); end

  # situation-specific data describing the host (see #host, #port, etc.)
  #
  # source://net-ssh//lib/net/ssh/errors.rb#51
  def data=(_arg0); end

  # Returns the fingerprint of the key for the host, which either was not
  # found or did not match.
  #
  # source://net-ssh//lib/net/ssh/errors.rb#61
  def fingerprint; end

  # Returns the host name for the remote host, as reported by the socket.
  #
  # source://net-ssh//lib/net/ssh/errors.rb#66
  def host; end

  # Returns the IP address of the remote host, as reported by the socket.
  #
  # source://net-ssh//lib/net/ssh/errors.rb#76
  def ip; end

  # Returns the key itself, as reported by the remote host.
  #
  # source://net-ssh//lib/net/ssh/errors.rb#81
  def key; end

  # Returns the port number for the remote host, as reported by the socket.
  #
  # source://net-ssh//lib/net/ssh/errors.rb#71
  def port; end

  # Tell Net::SSH to record this host and key in the known hosts file, so
  # that subsequent connections will remember them.
  #
  # source://net-ssh//lib/net/ssh/errors.rb#87
  def remember_host!; end
end

# Raised when the cached key for a particular host does not match the
# key given by the host, which can be indicative of a man-in-the-middle
# attack. When rescuing this exception, you can inspect the key fingerprint
# and, if you want to proceed anyway, simply call the remember_host!
# method on the exception, and then retry.
#
# source://net-ssh//lib/net/ssh/errors.rb#97
class Net::SSH::HostKeyMismatch < ::Net::SSH::HostKeyError; end

# Raised when there is no cached key for a particular host, which probably
# means that the host has simply not been seen before.
# When rescuing this exception, you can inspect the key fingerprint and, if
# you want to proceed anyway, simply call the remember_host! method on the
# exception, and then retry.
#
# source://net-ssh//lib/net/ssh/errors.rb#104
class Net::SSH::HostKeyUnknown < ::Net::SSH::HostKeyError; end

# Represents the result of a search in known hosts
# see search_for
#
# source://net-ssh//lib/net/ssh/known_hosts.rb#12
class Net::SSH::HostKeys
  include ::Enumerable

  # @return [HostKeys] a new instance of HostKeys
  #
  # source://net-ssh//lib/net/ssh/known_hosts.rb#16
  def initialize(host_keys, host, known_hosts, options = T.unsafe(nil)); end

  # source://net-ssh//lib/net/ssh/known_hosts.rb#23
  def add_host_key(key); end

  # source://net-ssh//lib/net/ssh/known_hosts.rb#28
  def each(&block); end

  # @return [Boolean]
  #
  # source://net-ssh//lib/net/ssh/known_hosts.rb#32
  def empty?; end

  # Returns the value of attribute host.
  #
  # source://net-ssh//lib/net/ssh/known_hosts.rb#14
  def host; end
end

# A factory class for returning new Key classes. It is used for obtaining
# OpenSSL key instances via their SSH names, and for loading both public and
# private keys. It used used primarily by Net::SSH itself, internally, and
# will rarely (if ever) be directly used by consumers of the library.
#
#   klass = Net::SSH::KeyFactory.get("rsa")
#   assert klass.is_a?(OpenSSL::PKey::RSA)
#
#   key = Net::SSH::KeyFactory.load_public_key("~/.ssh/id_dsa.pub")
#
# source://net-ssh//lib/net/ssh/key_factory.rb#18
class Net::SSH::KeyFactory
  class << self
    # Fetch an OpenSSL key instance by its SSH name. It will be a new,
    # empty key of the given type.
    #
    # source://net-ssh//lib/net/ssh/key_factory.rb#31
    def get(name); end

    # Loads a private key. It will correctly determine
    # whether the file describes an RSA or DSA key, and will load it
    # appropriately. The new key is returned. If the key itself is
    # encrypted (requiring a passphrase to use), the user will be
    # prompted to enter their password unless passphrase works.
    #
    # source://net-ssh//lib/net/ssh/key_factory.rb#50
    def load_data_private_key(data, passphrase = T.unsafe(nil), ask_passphrase = T.unsafe(nil), filename = T.unsafe(nil), prompt = T.unsafe(nil)); end

    # Loads a public key. It will correctly determine whether
    # the file describes an RSA or DSA key, and will load it
    # appropriately. The new public key is returned.
    #
    # @raise [Net::SSH::Exception]
    #
    # source://net-ssh//lib/net/ssh/key_factory.rb#90
    def load_data_public_key(data, filename = T.unsafe(nil)); end

    # Loads a private key from a file. It will correctly determine
    # whether the file describes an RSA or DSA key, and will load it
    # appropriately. The new key is returned. If the key itself is
    # encrypted (requiring a passphrase to use), the user will be
    # prompted to enter their password unless passphrase works.
    #
    # source://net-ssh//lib/net/ssh/key_factory.rb#40
    def load_private_key(filename, passphrase = T.unsafe(nil), ask_passphrase = T.unsafe(nil), prompt = T.unsafe(nil)); end

    # Loads a public key from a file. It will correctly determine whether
    # the file describes an RSA or DSA key, and will load it
    # appropriately. The new public key is returned.
    #
    # source://net-ssh//lib/net/ssh/key_factory.rb#82
    def load_public_key(filename); end

    private

    # Determine whether the file describes an RSA or DSA key, and return how load it
    # appropriately.
    #
    # source://net-ssh//lib/net/ssh/key_factory.rb#198
    def classify_key(data, filename); end
  end
end

# Specifies the mapping of SSH names to OpenSSL key classes.
#
# source://net-ssh//lib/net/ssh/key_factory.rb#20
Net::SSH::KeyFactory::MAP = T.let(T.unsafe(nil), Hash)

# Searches an OpenSSH-style known-host file for a given host, and returns all
# matching keys. This is used to implement host-key verification, as well as
# to determine what key a user prefers to use for a given host.
#
# This is used internally by Net::SSH, and will never need to be used directly
# by consumers of the library.
#
# source://net-ssh//lib/net/ssh/known_hosts.rb#43
class Net::SSH::KnownHosts
  # Instantiate a new KnownHosts instance that will search the given known-hosts
  # file. The path is expanded file File.expand_path.
  #
  # @return [KnownHosts] a new instance of KnownHosts
  #
  # source://net-ssh//lib/net/ssh/known_hosts.rb#106
  def initialize(source); end

  # Tries to append an entry to the current source file for the given host
  # and key. If it is unable to (because the file is not writable, for
  # instance), an exception will be raised.
  #
  # source://net-ssh//lib/net/ssh/known_hosts.rb#188
  def add(host, key); end

  # Returns an array of all keys that are known to be associatd with the
  # given host. The +host+ parameter is either the domain name or ip address
  # of the host, or both (comma-separated). Additionally, if a non-standard
  # port is being used, it may be specified by putting the host (or ip, or
  # both) in square brackets, and appending the port outside the brackets
  # after a colon. Possible formats for +host+, then, are;
  #
  #   "net.ssh.test"
  #   "1.2.3.4"
  #   "net.ssh.test,1.2.3.4"
  #   "[net.ssh.test]:5555"
  #   "[1,2,3,4]:5555"
  #   "[net.ssh.test]:5555,[1.2.3.4]:5555
  #
  # source://net-ssh//lib/net/ssh/known_hosts.rb#123
  def keys_for(host, options = T.unsafe(nil)); end

  # Indicates whether one of the entries matches an hostname that has been
  # stored as a HMAC-SHA1 hash in the known hosts.
  #
  # @return [Boolean]
  #
  # source://net-ssh//lib/net/ssh/known_hosts.rb#172
  def known_host_hash?(hostlist, entries); end

  # source://net-ssh//lib/net/ssh/known_hosts.rb#155
  def match(host, pattern); end

  # The host-key file name that this KnownHosts instance will use to search
  # for keys.
  #
  # source://net-ssh//lib/net/ssh/known_hosts.rb#102
  def source; end

  class << self
    # Looks in all user known host files (see KnownHosts.hostfiles) and tries to
    # add an entry for the given host and key to the first file it is able
    # to.
    #
    # source://net-ssh//lib/net/ssh/known_hosts.rb#88
    def add(host, key, options = T.unsafe(nil)); end

    # Looks in the given +options+ hash for the :user_known_hosts_file and
    # :global_known_hosts_file keys, and returns an array of all known
    # hosts files. If the :user_known_hosts_file key is not set, the
    # default is returned (~/.ssh/known_hosts and ~/.ssh/known_hosts2). If
    # :global_known_hosts_file is not set, the default is used
    # (/etc/ssh/ssh_known_hosts and /etc/ssh/ssh_known_hosts2).
    #
    # If you only want the user known host files, you can pass :user as
    # the second option.
    #
    # source://net-ssh//lib/net/ssh/known_hosts.rb#73
    def hostfiles(options, which = T.unsafe(nil)); end

    # Searches all known host files (see KnownHosts.hostfiles) for all keys
    # of the given host. Returns an enumerable of keys found.
    #
    # source://net-ssh//lib/net/ssh/known_hosts.rb#54
    def search_for(host, options = T.unsafe(nil)); end

    # Search for all known keys for the given host, in every file given in
    # the +files+ array. Returns the list of keys.
    #
    # source://net-ssh//lib/net/ssh/known_hosts.rb#60
    def search_in(files, host, options = T.unsafe(nil)); end
  end
end

# source://net-ssh//lib/net/ssh/known_hosts.rb#44
Net::SSH::KnownHosts::SUPPORTED_TYPE = T.let(T.unsafe(nil), Array)

# A simple module to make logging easier to deal with. It assumes that the
# logger instance (if not nil) quacks like a Logger object (in Ruby's
# standard library). Although used primarily internally by Net::SSH, it
# can easily be used to add Net::SSH-like logging to your own programs.
#
#   class MyClass
#     include Net::SSH::Loggable
#   end
#
#   Net::SSH.start(...) do |ssh|
#     obj = MyClass.new
#     obj.logger = ssh.logger
#     ...
#   end
#
# source://net-ssh//lib/net/ssh/loggable.rb#18
module Net::SSH::Loggable
  # Displays the result of yielding if the log level is Logger::DEBUG or
  # greater.
  #
  # source://net-ssh//lib/net/ssh/loggable.rb#25
  def debug; end

  # Displays the result of yielding if the log level is Logger:ERROR or
  # greater.
  #
  # source://net-ssh//lib/net/ssh/loggable.rb#43
  def error; end

  # Displays the result of yielding if the log level is Logger::FATAL or
  # greater.
  #
  # source://net-ssh//lib/net/ssh/loggable.rb#49
  def fatal; end

  # Displays the result of yielding if the log level is Logger::INFO or
  # greater.
  #
  # source://net-ssh//lib/net/ssh/loggable.rb#31
  def info; end

  # The logger instance that will be used to log messages. If nil, nothing
  # will be logged.
  #
  # source://net-ssh//lib/net/ssh/loggable.rb#21
  def logger; end

  # The logger instance that will be used to log messages. If nil, nothing
  # will be logged.
  #
  # source://net-ssh//lib/net/ssh/loggable.rb#21
  def logger=(_arg0); end

  # Displays the result of yielding if the log level is Logger::WARN or
  # greater. (Called lwarn to avoid shadowing with Kernel#warn.)
  #
  # source://net-ssh//lib/net/ssh/loggable.rb#37
  def lwarn; end

  private

  # Sets the "facility" value, used for reporting where a log message
  # originates. It defaults to the name of class with the object_id
  # appended.
  #
  # source://net-ssh//lib/net/ssh/loggable.rb#58
  def facility; end
end

# A specialization of Buffer that knows the format of certain common
# packet types. It auto-parses those packet types, and allows them to
# be accessed via the #[] accessor.
#
#   data = some_channel_request_packet
#   packet = Net::SSH::Packet.new(data)
#
#   p packet.type #-> 98 (CHANNEL_REQUEST)
#   p packet[:request]
#   p packet[:want_reply]
#
# This is used exclusively internally by Net::SSH, and unless you're doing
# protocol-level manipulation or are extending Net::SSH in some way, you'll
# never need to use this class directly.
#
# source://net-ssh//lib/net/ssh/packet.rb#23
class Net::SSH::Packet < ::Net::SSH::Buffer
  include ::Net::SSH::Connection::Constants
  include ::Net::SSH::Authentication::Constants
  include ::Net::SSH::Transport::Constants

  # Create a new packet from the given payload. This will automatically
  # parse the packet if it is one that has been previously registered with
  # Packet.register; otherwise, the packet will need to be manually parsed
  # using the methods provided in the Net::SSH::Buffer superclass.
  #
  # @return [Packet] a new instance of Packet
  #
  # source://net-ssh//lib/net/ssh/packet.rb#76
  def initialize(payload); end

  # Access one of the auto-parsed fields by name. Raises an error if no
  # element by the given name exists.
  #
  # @raise [ArgumentError]
  #
  # source://net-ssh//lib/net/ssh/packet.rb#85
  def [](name); end

  # The (integer) type of this packet.
  #
  # source://net-ssh//lib/net/ssh/packet.rb#70
  def type; end

  private

  # Parse the packet's contents and assign the named elements, as described
  # by the registered format for the packet.
  #
  # source://net-ssh//lib/net/ssh/packet.rb#95
  def instantiate!; end

  class << self
    # Register a new packet type that should be recognized and auto-parsed by
    # Net::SSH::Packet. Note that any packet type that is not preregistered
    # will not be autoparsed.
    #
    # The +pairs+ parameter must be either empty, or an array of two-element
    # tuples, where the first element of each tuple is the name of the field,
    # and the second is the type.
    #
    #   register DISCONNECT, [:reason_code, :long], [:description, :string], [:language, :string]
    #
    # source://net-ssh//lib/net/ssh/packet.rb#35
    def register(type, *pairs); end
  end
end

# Default prompt implementation, called for asking password from user.
# It will never be instantiated directly, but will instead be created for
# you automatically.
#
# A custom prompt objects can implement caching, or different UI. The prompt
# object should implemnted a start method, which should return something implementing
# ask and success. Net::SSH uses it like:
#
#   prompter = options[:password_prompt].start({type:'password'})
#   while !ok && max_retries < 3
#     user = prompter.ask("user: ", {}, true)
#     password = prompter.ask("password: ", {}, false)
#     ok = send(user, password)
#     prompter.sucess if ok
#   end
#
# source://net-ssh//lib/net/ssh/prompt.rb#22
class Net::SSH::Prompt
  # @return [Prompt] a new instance of Prompt
  #
  # source://net-ssh//lib/net/ssh/prompt.rb#28
  def initialize(options = T.unsafe(nil)); end

  # start password session. Multiple questions might be asked multiple times
  # on the returned object. Info hash tries to uniquely identify the password
  # session, so caching implementations can save passwords properly.
  #
  # source://net-ssh//lib/net/ssh/prompt.rb#58
  def start(info); end

  class << self
    # factory
    #
    # source://net-ssh//lib/net/ssh/prompt.rb#24
    def default(options = T.unsafe(nil)); end
  end
end

# default prompt object implementation. More sophisticated implemenetations
# might implement caching.
#
# source://net-ssh//lib/net/ssh/prompt.rb#32
class Net::SSH::Prompt::Prompter
  # @return [Prompter] a new instance of Prompter
  #
  # source://net-ssh//lib/net/ssh/prompt.rb#33
  def initialize(info); end

  # ask input from user, a prompter might ask for multiple inputs
  # (like user and password) in a single session.
  #
  # source://net-ssh//lib/net/ssh/prompt.rb#42
  def ask(prompt, echo = T.unsafe(nil)); end

  # success method will be called when the password was accepted
  # It's a good time to save password asked to a cache.
  #
  # source://net-ssh//lib/net/ssh/prompt.rb#52
  def success; end
end

# source://net-ssh//lib/net/ssh/service/forward.rb#5
module Net::SSH::Service; end

# This class implements various port forwarding services for use by
# Net::SSH clients. The Forward class should never need to be instantiated
# directly; instead, it should be accessed via the singleton instance
# returned by Connection::Session#forward:
#
#   ssh.forward.local(1234, "www.capify.org", 80)
#
# source://net-ssh//lib/net/ssh/service/forward.rb#13
class Net::SSH::Service::Forward
  include ::Net::SSH::Loggable

  # Instantiates a new Forward service instance atop the given connection
  # service session. This will register new channel open handlers to handle
  # the specialized channels that the SSH port forwarding protocols employ.
  #
  # @return [Forward] a new instance of Forward
  #
  # source://net-ssh//lib/net/ssh/service/forward.rb#26
  def initialize(session); end

  # Returns a list of all active locally forwarded sockets. The returned value
  # is an array of Unix domain socket file paths.
  #
  # source://net-ssh//lib/net/ssh/service/forward.rb#171
  def active_local_sockets; end

  # Returns a list of all active locally forwarded ports. The returned value
  # is an array of arrays, where each element is a two-element tuple
  # consisting of the local port and bind address corresponding to the
  # forwarding port.
  #
  # source://net-ssh//lib/net/ssh/service/forward.rb#120
  def active_locals; end

  # Returns all active remote forwarded ports and where they forward to. The
  # returned value is a hash from [<forwarding port on the local host>, <local forwarding address>]
  # to [<port on the remote host>, <remote bind address>].
  #
  # source://net-ssh//lib/net/ssh/service/forward.rb#272
  def active_remote_destinations; end

  # Returns all active forwarded remote ports. The returned value is an
  # array of two-element tuples, where the first element is the port on the
  # remote host and the second is the bind address.
  #
  # source://net-ssh//lib/net/ssh/service/forward.rb#265
  def active_remotes; end

  # Enables SSH agent forwarding on the given channel. The forwarded agent
  # will remain active even after the channel closes--the channel is only
  # used as the transport for enabling the forwarded connection. You should
  # never need to call this directly--it is called automatically the first
  # time a session channel is opened, when the connection was created with
  # :forward_agent set to true:
  #
  #    Net::SSH.start("remote.host", "me", :forward_agent => true) do |ssh|
  #      ssh.open_channel do |ch|
  #        # agent will be automatically forwarded by this point
  #      end
  #      ssh.loop
  #    end
  #
  # source://net-ssh//lib/net/ssh/service/forward.rb#291
  def agent(channel); end

  # Terminates an active local forwarded port.
  #
  #   ssh.forward.cancel_local(1234)
  #   ssh.forward.cancel_local(1234, "0.0.0.0")
  #
  # source://net-ssh//lib/net/ssh/service/forward.rb#109
  def cancel_local(port, bind_address = T.unsafe(nil)); end

  # Terminates an active local forwarded socket.
  #
  #   ssh.forward.cancel_local_socket('/tmp/foo.sock')
  #
  # source://net-ssh//lib/net/ssh/service/forward.rb#162
  def cancel_local_socket(local_socket_path); end

  # Requests that a remote forwarded port be cancelled. The remote forwarded
  # port on the remote host, bound to the given address on the remote host,
  # will be terminated, but not immediately. This method returns immediately
  # after queueing the request to be sent to the server. If for some reason
  # the port cannot be cancelled, an exception will be raised (asynchronously).
  #
  # If you want to know when the connection has been cancelled, it will no
  # longer be present in the #active_remotes list. If you want to block until
  # the port is no longer active, you could do something like this:
  #
  #   ssh.forward.cancel_remote(1234, "0.0.0.0")
  #   ssh.loop { ssh.forward.active_remotes.include?([1234, "0.0.0.0"]) }
  #
  # source://net-ssh//lib/net/ssh/service/forward.rb#252
  def cancel_remote(port, host = T.unsafe(nil)); end

  # Starts listening for connections on the local host, and forwards them
  # to the specified remote host/port via the SSH connection. This method
  # accepts either three or four arguments. When four arguments are given,
  # they are:
  #
  # * the local address to bind to
  # * the local port to listen on
  # * the remote host to forward connections to
  # * the port on the remote host to connect to
  #
  # If three arguments are given, it is as if the local bind address is
  # "127.0.0.1", and the rest are applied as above.
  #
  # To request an ephemeral port on the remote server, provide 0 (zero) for
  # the port number. In all cases, this method will return the port that
  # has been assigned.
  #
  #   ssh.forward.local(1234, "www.capify.org", 80)
  #   assigned_port = ssh.forward.local("0.0.0.0", 0, "www.capify.org", 80)
  #
  # source://net-ssh//lib/net/ssh/service/forward.rb#58
  def local(*args); end

  # Starts listening for connections on the local host, and forwards them
  # to the specified remote socket via the SSH connection. This will
  # (re)create the local socket file. The remote server needs to have the
  # socket file already available.
  #
  #   ssh.forward.local_socket('/tmp/local.sock', '/tmp/remote.sock')
  #
  # source://net-ssh//lib/net/ssh/service/forward.rb#130
  def local_socket(local_socket_path, remote_socket_path); end

  # Requests that all connections on the given remote-port be forwarded via
  # the local host to the given port/host. The last argument describes the
  # bind address on the remote host, and defaults to 127.0.0.1.
  #
  # This method will return immediately, but the port will not actually be
  # forwarded immediately. If the remote server is not able to begin the
  # listener for this request, an exception will be raised asynchronously.
  #
  # To request an ephemeral port on the remote server, provide 0 (zero) for
  # the port number. The assigned port will show up in the # #active_remotes
  # list.
  #
  # remote_host is interpreted by the server per RFC 4254, which has these
  # special values:
  #
  # - "" means that connections are to be accepted on all protocol
  #   families supported by the SSH implementation.
  # - "0.0.0.0" means to listen on all IPv4 addresses.
  # - "::" means to listen on all IPv6 addresses.
  # - "localhost" means to listen on all protocol families supported by
  #   the SSH implementation on loopback addresses only ([RFC3330] and
  #   [RFC3513]).
  # - "127.0.0.1" and "::1" indicate listening on the loopback
  #   interfaces for IPv4 and IPv6, respectively.
  #
  # You may pass a block that will be called when the the port forward
  # request receives a response.  This block will be passed the remote_port
  # that was actually bound to, or nil if the binding failed.  If the block
  # returns :no_exception, the "failed binding" exception will not be thrown.
  #
  # If you want to block until the port is active, you could do something
  # like this:
  #
  #   got_remote_port = nil
  #   remote(port, host, remote_port, remote_host) do |actual_remote_port|
  #     got_remote_port = actual_remote_port || :error
  #     :no_exception # will yield the exception on my own thread
  #   end
  #   session.loop { !got_remote_port }
  #   if got_remote_port == :error
  #     raise Net::SSH::Exception, "remote forwarding request failed"
  #   end
  #
  # source://net-ssh//lib/net/ssh/service/forward.rb#218
  def remote(port, host, remote_port, remote_host = T.unsafe(nil)); end

  # Requests that all connections on the given remote-port be forwarded via
  # the local host to the given port/host. The last argument describes the
  # bind address on the remote host, and defaults to 127.0.0.1.
  #
  # This method will return immediately, but the port will not actually be
  # forwarded immediately. If the remote server is not able to begin the
  # listener for this request, an exception will be raised asynchronously.
  #
  # To request an ephemeral port on the remote server, provide 0 (zero) for
  # the port number. The assigned port will show up in the # #active_remotes
  # list.
  #
  # remote_host is interpreted by the server per RFC 4254, which has these
  # special values:
  #
  # - "" means that connections are to be accepted on all protocol
  #   families supported by the SSH implementation.
  # - "0.0.0.0" means to listen on all IPv4 addresses.
  # - "::" means to listen on all IPv6 addresses.
  # - "localhost" means to listen on all protocol families supported by
  #   the SSH implementation on loopback addresses only ([RFC3330] and
  #   [RFC3513]).
  # - "127.0.0.1" and "::1" indicate listening on the loopback
  #   interfaces for IPv4 and IPv6, respectively.
  #
  # You may pass a block that will be called when the the port forward
  # request receives a response.  This block will be passed the remote_port
  # that was actually bound to, or nil if the binding failed.  If the block
  # returns :no_exception, the "failed binding" exception will not be thrown.
  #
  # If you want to block until the port is active, you could do something
  # like this:
  #
  #   got_remote_port = nil
  #   remote(port, host, remote_port, remote_host) do |actual_remote_port|
  #     got_remote_port = actual_remote_port || :error
  #     :no_exception # will yield the exception on my own thread
  #   end
  #   session.loop { !got_remote_port }
  #   if got_remote_port == :error
  #     raise Net::SSH::Exception, "remote forwarding request failed"
  #   end
  # an alias, for token backwards compatibility with the 1.x API
  #
  # source://net-ssh//lib/net/ssh/service/forward.rb#218
  def remote_to(port, host, remote_port, remote_host = T.unsafe(nil)); end

  # The underlying connection service instance that the port-forwarding
  # services employ.
  #
  # source://net-ssh//lib/net/ssh/service/forward.rb#18
  def session; end

  private

  # The callback used when an auth-agent channel is requested by the server.
  #
  # source://net-ssh//lib/net/ssh/service/forward.rb#406
  def auth_agent_channel(session, channel, packet); end

  # The callback used when a new "forwarded-tcpip" channel is requested
  # by the server.  This will open a new socket to the host/port specified
  # when the forwarded connection was first requested.
  #
  # source://net-ssh//lib/net/ssh/service/forward.rb#385
  def forwarded_tcpip(session, channel, packet); end

  # Perform setup operations that are common to all forwarded channels.
  # +client+ is a socket, +channel+ is the channel that was just created,
  # and +type+ is an arbitrary string describing the type of the channel.
  #
  # source://net-ssh//lib/net/ssh/service/forward.rb#315
  def prepare_client(client, channel, type); end

  # not a real socket, so use a simpler behaviour
  #
  # source://net-ssh//lib/net/ssh/service/forward.rb#365
  def prepare_simple_client(client, channel, type); end
end

# A simple class for representing a requested remote forwarded port.
#
# source://net-ssh//lib/net/ssh/service/forward.rb#21
class Net::SSH::Service::Forward::Remote < ::Struct
  # Returns the value of attribute host
  #
  # @return [Object] the current value of host
  def host; end

  # Sets the attribute host
  #
  # @param value [Object] the value to set the attribute host to.
  # @return [Object] the newly set value
  def host=(_); end

  # Returns the value of attribute port
  #
  # @return [Object] the current value of port
  def port; end

  # Sets the attribute port
  #
  # @param value [Object] the value to set the attribute port to.
  # @return [Object] the newly set value
  def port=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# This exception is raised when the remote host has disconnected/
# timeouted unexpectedly.
#
# source://net-ssh//lib/net/ssh/errors.rb#20
class Net::SSH::Timeout < ::Net::SSH::Disconnect; end

# source://net-ssh//lib/net/ssh/transport/ctr.rb#4
module Net::SSH::Transport; end

# Implements the higher-level logic behind an SSH key-exchange. It handles
# both the initial exchange, as well as subsequent re-exchanges (as needed).
# It also encapsulates the negotiation of the algorithms, and provides a
# single point of access to the negotiated algorithms.
#
# You will never instantiate or reference this directly. It is used
# internally by the transport layer.
#
# source://net-ssh//lib/net/ssh/transport/algorithms.rb#22
class Net::SSH::Transport::Algorithms
  include ::Net::SSH::Loggable
  include ::Net::SSH::Transport::Constants

  # Instantiates a new Algorithms object, and prepares the hash of preferred
  # algorithms based on the options parameter and the ALGORITHMS constant.
  #
  # @return [Algorithms] a new instance of Algorithms
  #
  # source://net-ssh//lib/net/ssh/transport/algorithms.rb#146
  def initialize(session, options = T.unsafe(nil)); end

  # A convenience method for accessing the list of preferred types for a
  # specific algorithm (see #algorithms).
  #
  # source://net-ssh//lib/net/ssh/transport/algorithms.rb#190
  def [](key); end

  # Called by the transport layer when a KEXINIT packet is received, indicating
  # that the server wants to exchange keys. This can be spontaneous, or it
  # can be in response to a client-initiated rekey request (see #rekey!). Either
  # way, this will block until the key exchange completes.
  #
  # source://net-ssh//lib/net/ssh/transport/algorithms.rb#177
  def accept_kexinit(packet); end

  # The hash of algorithms preferred by the client, which will be told to
  # the server during algorithm negotiation.
  #
  # source://net-ssh//lib/net/ssh/transport/algorithms.rb#132
  def algorithms; end

  # Returns true if no exchange is pending, and otherwise returns true or
  # false depending on whether the given packet is of a type that is allowed
  # during a key exchange.
  #
  # @return [Boolean]
  #
  # source://net-ssh//lib/net/ssh/transport/algorithms.rb#206
  def allow?(packet); end

  # The type of compression to use to compress packets being sent by the client.
  #
  # source://net-ssh//lib/net/ssh/transport/algorithms.rb#119
  def compression_client; end

  # The type of compression to use to decompress packets arriving from the server.
  #
  # source://net-ssh//lib/net/ssh/transport/algorithms.rb#122
  def compression_server; end

  # The type of the cipher to use to encrypt packets sent from the client to
  # the server.
  #
  # source://net-ssh//lib/net/ssh/transport/algorithms.rb#107
  def encryption_client; end

  # The type of the cipher to use to decrypt packets arriving from the server.
  #
  # source://net-ssh//lib/net/ssh/transport/algorithms.rb#110
  def encryption_server; end

  # The type of HMAC to use to sign packets sent by the client.
  #
  # source://net-ssh//lib/net/ssh/transport/algorithms.rb#113
  def hmac_client; end

  # The type of HMAC to use to validate packets arriving from the server.
  #
  # source://net-ssh//lib/net/ssh/transport/algorithms.rb#116
  def hmac_server; end

  # The type of host key that will be used for this session.
  #
  # source://net-ssh//lib/net/ssh/transport/algorithms.rb#103
  def host_key; end

  # source://net-ssh//lib/net/ssh/transport/algorithms.rb#215
  def host_key_format; end

  # Returns true if the algorithms have been negotiated at all.
  #
  # @return [Boolean]
  #
  # source://net-ssh//lib/net/ssh/transport/algorithms.rb#211
  def initialized?; end

  # The kex algorithm to use settled on between the client and server.
  #
  # source://net-ssh//lib/net/ssh/transport/algorithms.rb#100
  def kex; end

  # The language that will be used in messages sent by the client.
  #
  # source://net-ssh//lib/net/ssh/transport/algorithms.rb#125
  def language_client; end

  # The language that will be used in messages sent from the server.
  #
  # source://net-ssh//lib/net/ssh/transport/algorithms.rb#128
  def language_server; end

  # The hash of options used to initialize this object
  #
  # source://net-ssh//lib/net/ssh/transport/algorithms.rb#97
  def options; end

  # Returns +true+ if a key-exchange is pending. This will be true from the
  # moment either the client or server requests the key exchange, until the
  # exchange completes. While an exchange is pending, only a limited number
  # of packets are allowed, so event processing essentially stops during this
  # period.
  #
  # @return [Boolean]
  #
  # source://net-ssh//lib/net/ssh/transport/algorithms.rb#199
  def pending?; end

  # Request a rekey operation. This will return immediately, and does not
  # actually perform the rekey operation. It does cause the session to change
  # state, however--until the key exchange finishes, no new packets will be
  # processed.
  #
  # source://net-ssh//lib/net/ssh/transport/algorithms.rb#167
  def rekey!; end

  # The underlying transport layer session that supports this object
  #
  # source://net-ssh//lib/net/ssh/transport/algorithms.rb#94
  def session; end

  # The session-id for this session, as decided during the initial key exchange.
  #
  # source://net-ssh//lib/net/ssh/transport/algorithms.rb#135
  def session_id; end

  # Start the algorithm negotation
  #
  # @raise [ArgumentError]
  #
  # source://net-ssh//lib/net/ssh/transport/algorithms.rb#157
  def start; end

  private

  # Given the #algorithms map of preferred algorithm types, this constructs
  # a KEXINIT packet to send to the server. It does not actually send it,
  # it simply builds the packet and returns it.
  #
  # source://net-ssh//lib/net/ssh/transport/algorithms.rb#360
  def build_client_algorithm_packet; end

  # Composes the list of algorithms by taking supported algorithms and matching with supplied options.
  #
  # source://net-ssh//lib/net/ssh/transport/algorithms.rb#287
  def compose_algorithm_list(supported, option, append_all_supported_algorithms = T.unsafe(nil)); end

  # Instantiates one of the Transport::Kex classes (based on the negotiated
  # kex algorithm), and uses it to exchange keys. Then, the ciphers and
  # HMACs are initialized and fed to the transport layer, to be used in
  # further communication with the server.
  #
  # source://net-ssh//lib/net/ssh/transport/algorithms.rb#434
  def exchange_keys; end

  # Considers the sizes of the keys and block-sizes for the selected ciphers,
  # and the lengths of the hmacs, and returns the largest as the byte requirement
  # for the key-exchange algorithm.
  #
  # source://net-ssh//lib/net/ssh/transport/algorithms.rb#418
  def kex_byte_requirement; end

  # Negotiates a single algorithm based on the preferences reported by the
  # server and those set by the client. This is called by
  # #negotiate_algorithms.
  #
  # source://net-ssh//lib/net/ssh/transport/algorithms.rb#403
  def negotiate(algorithm); end

  # Given the parsed server KEX packet, and the client's preferred algorithm
  # lists in #algorithms, determine which preferred algorithms each has
  # in common and set those as the selected algorithms. If, for any algorithm,
  # no type can be settled on, an exception is raised.
  #
  # source://net-ssh//lib/net/ssh/transport/algorithms.rb#379
  def negotiate_algorithms; end

  # Given the SSH name for some compression algorithm, return a normalized
  # name as a symbol.
  #
  # source://net-ssh//lib/net/ssh/transport/algorithms.rb#488
  def normalize_compression_name(name); end

  # Parses a KEXINIT packet from the server.
  #
  # source://net-ssh//lib/net/ssh/transport/algorithms.rb#333
  def parse_server_algorithm_packet(packet); end

  # Prepares the list of preferred algorithms, based on the options hash
  # that was given when the object was constructed, and the ALGORITHMS
  # constant. Also, when determining the host_key type to use, the known
  # hosts files are examined to see if the host has ever sent a host_key
  # before, and if so, that key type is used as the preferred type for
  # communicating with this server.
  #
  # source://net-ssh//lib/net/ssh/transport/algorithms.rb#255
  def prepare_preferred_algorithms!; end

  # After both client and server have sent their KEXINIT packets, this
  # will do the algorithm negotiation and key exchange. Once both finish,
  # the object leaves the pending state and the method returns.
  #
  # source://net-ssh//lib/net/ssh/transport/algorithms.rb#242
  def proceed!; end

  # Sends a KEXINIT packet to the server. If a server KEXINIT has already
  # been received, this will then invoke #proceed! to proceed with the key
  # exchange, otherwise it returns immediately (but sets the object to the
  # pending state).
  #
  # source://net-ssh//lib/net/ssh/transport/algorithms.rb#230
  def send_kexinit; end

  class << self
    # Returns true if the given packet can be processed during a key-exchange.
    #
    # @return [Boolean]
    #
    # source://net-ssh//lib/net/ssh/transport/algorithms.rb#138
    def allowed_packet?(packet); end
  end
end

# Define all algorithms, with the deprecated, supported by Net::SSH.
#
# source://net-ssh//lib/net/ssh/transport/algorithms.rb#66
Net::SSH::Transport::Algorithms::ALGORITHMS = T.let(T.unsafe(nil), Hash)

# Define the default algorithms, in order of preference, supported by Net::SSH.
#
# source://net-ssh//lib/net/ssh/transport/algorithms.rb#27
Net::SSH::Transport::Algorithms::DEFAULT_ALGORITHMS = T.let(T.unsafe(nil), Hash)

# Pure-Ruby implementation of Stateful Decryption Counter(SDCTR) Mode
# for Block Ciphers. See RFC4344 for detail.
#
# source://net-ssh//lib/net/ssh/transport/ctr.rb#32
module Net::SSH::Transport::CTR
  class << self
    # @private
    #
    # source://net-ssh//lib/net/ssh/transport/ctr.rb#33
    def extended(orig); end
  end
end

# Implements a factory of OpenSSL cipher algorithms.
#
# source://net-ssh//lib/net/ssh/transport/cipher_factory.rb#11
class Net::SSH::Transport::CipherFactory
  class << self
    # Retrieves a new instance of the named algorithm. The new instance
    # will be initialized using an iv and key generated from the given
    # iv, key, shared, hash and digester values. Additionally, the
    # cipher will be put into encryption or decryption mode, based on the
    # value of the +encrypt+ parameter.
    #
    # source://net-ssh//lib/net/ssh/transport/cipher_factory.rb#46
    def get(name, options = T.unsafe(nil)); end

    # Returns a two-element array containing the [ key-length,
    # block-size ] for the named cipher algorithm. If the cipher
    # algorithm is unknown, or is "none", 0 is returned for both elements
    # of the tuple.
    # if :iv_len option is supplied the third return value will be ivlen
    #
    # source://net-ssh//lib/net/ssh/transport/cipher_factory.rb#76
    def get_lengths(name, options = T.unsafe(nil)); end

    # Returns true if the underlying OpenSSL library supports the given cipher,
    # and false otherwise.
    #
    # @return [Boolean]
    #
    # source://net-ssh//lib/net/ssh/transport/cipher_factory.rb#35
    def supported?(name); end
  end
end

# Maps the SSH name of a cipher to it's corresponding OpenSSL name
#
# source://net-ssh//lib/net/ssh/transport/cipher_factory.rb#13
Net::SSH::Transport::CipherFactory::SSH_TO_OSSL = T.let(T.unsafe(nil), Hash)

# source://net-ssh//lib/net/ssh/transport/constants.rb#4
module Net::SSH::Transport::Constants; end

# source://net-ssh//lib/net/ssh/transport/constants.rb#12
Net::SSH::Transport::Constants::DEBUG = T.let(T.unsafe(nil), Integer)

# --
# Transport layer generic messages
# ++
#
# source://net-ssh//lib/net/ssh/transport/constants.rb#9
Net::SSH::Transport::Constants::DISCONNECT = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/transport/constants.rb#10
Net::SSH::Transport::Constants::IGNORE = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/transport/constants.rb#33
Net::SSH::Transport::Constants::KEXDH_GEX_GROUP = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/transport/constants.rb#34
Net::SSH::Transport::Constants::KEXDH_GEX_INIT = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/transport/constants.rb#35
Net::SSH::Transport::Constants::KEXDH_GEX_REPLY = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/transport/constants.rb#36
Net::SSH::Transport::Constants::KEXDH_GEX_REQUEST = T.let(T.unsafe(nil), Integer)

# --
# Key exchange method specific messages
# ++
#
# source://net-ssh//lib/net/ssh/transport/constants.rb#27
Net::SSH::Transport::Constants::KEXDH_INIT = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/transport/constants.rb#28
Net::SSH::Transport::Constants::KEXDH_REPLY = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/transport/constants.rb#30
Net::SSH::Transport::Constants::KEXECDH_INIT = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/transport/constants.rb#31
Net::SSH::Transport::Constants::KEXECDH_REPLY = T.let(T.unsafe(nil), Integer)

# --
# Algorithm negotiation messages
# ++
#
# source://net-ssh//lib/net/ssh/transport/constants.rb#20
Net::SSH::Transport::Constants::KEXINIT = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/transport/constants.rb#21
Net::SSH::Transport::Constants::NEWKEYS = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/transport/constants.rb#14
Net::SSH::Transport::Constants::SERVICE_ACCEPT = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/transport/constants.rb#13
Net::SSH::Transport::Constants::SERVICE_REQUEST = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/transport/constants.rb#11
Net::SSH::Transport::Constants::UNIMPLEMENTED = T.let(T.unsafe(nil), Integer)

# Implements a simple factory interface for fetching hmac implementations, or
# for finding the key lengths for hmac implementations.s
#
# source://net-ssh//lib/net/ssh/transport/hmac/abstract.rb#7
module Net::SSH::Transport::HMAC
  class << self
    # Retrieves a new hmac instance of the given SSH type (+name+). If +key+ is
    # given, the new instance will be initialized with that key.
    #
    # source://net-ssh//lib/net/ssh/transport/hmac.rb#37
    def get(name, key = T.unsafe(nil), parameters = T.unsafe(nil)); end

    # Retrieves the key length for the hmac of the given SSH type (+name+).
    #
    # source://net-ssh//lib/net/ssh/transport/hmac.rb#43
    def key_length(name); end
  end
end

# The base class of all OpenSSL-based HMAC algorithm wrappers.
#
# source://net-ssh//lib/net/ssh/transport/hmac/abstract.rb#10
class Net::SSH::Transport::HMAC::Abstract
  # @return [Abstract] a new instance of Abstract
  #
  # source://net-ssh//lib/net/ssh/transport/hmac/abstract.rb#80
  def initialize(key = T.unsafe(nil)); end

  # Compute the HMAC digest for the given data string.
  #
  # source://net-ssh//lib/net/ssh/transport/hmac/abstract.rb#91
  def digest(data); end

  # source://net-ssh//lib/net/ssh/transport/hmac/abstract.rb#73
  def digest_class; end

  # source://net-ssh//lib/net/ssh/transport/hmac/abstract.rb#61
  def etm; end

  # The key in use for this instance.
  #
  # source://net-ssh//lib/net/ssh/transport/hmac/abstract.rb#78
  def key; end

  # Sets the key to the given value, truncating it so that it is the correct
  # length.
  #
  # source://net-ssh//lib/net/ssh/transport/hmac/abstract.rb#86
  def key=(value); end

  # source://net-ssh//lib/net/ssh/transport/hmac/abstract.rb#65
  def key_length; end

  # source://net-ssh//lib/net/ssh/transport/hmac/abstract.rb#69
  def mac_length; end

  class << self
    # source://net-ssh//lib/net/ssh/transport/hmac/abstract.rb#48
    def digest_class(*v); end

    # source://net-ssh//lib/net/ssh/transport/hmac/abstract.rb#12
    def etm(*v); end

    # source://net-ssh//lib/net/ssh/transport/hmac/abstract.rb#24
    def key_length(*v); end

    # source://net-ssh//lib/net/ssh/transport/hmac/abstract.rb#36
    def mac_length(*v); end
  end
end

# The mapping of SSH hmac algorithms to their implementations
#
# source://net-ssh//lib/net/ssh/transport/hmac.rb#19
Net::SSH::Transport::HMAC::MAP = T.let(T.unsafe(nil), Hash)

# The MD5 HMAC algorithm.
#
# source://net-ssh//lib/net/ssh/transport/hmac/md5.rb#6
class Net::SSH::Transport::HMAC::MD5 < ::Net::SSH::Transport::HMAC::Abstract; end

# The MD5-96 HMAC algorithm. This returns only the first 12 bytes of
# the digest.
#
# source://net-ssh//lib/net/ssh/transport/hmac/md5_96.rb#7
class Net::SSH::Transport::HMAC::MD5_96 < ::Net::SSH::Transport::HMAC::MD5; end

# The "none" algorithm. This has a key and mac length of 0.
#
# source://net-ssh//lib/net/ssh/transport/hmac/none.rb#6
class Net::SSH::Transport::HMAC::None < ::Net::SSH::Transport::HMAC::Abstract
  # source://net-ssh//lib/net/ssh/transport/hmac/none.rb#10
  def digest(data); end
end

# The RIPEMD-160 HMAC algorithm. This has a mac and key length of 20, and
# uses the RIPEMD-160 digest algorithm.
#
# source://net-ssh//lib/net/ssh/transport/hmac/ripemd160.rb#7
class Net::SSH::Transport::HMAC::RIPEMD160 < ::Net::SSH::Transport::HMAC::Abstract; end

# The SHA1 HMAC algorithm. This has a mac and key length of 20, and
# uses the SHA1 digest algorithm.
#
# source://net-ssh//lib/net/ssh/transport/hmac/sha1.rb#7
class Net::SSH::Transport::HMAC::SHA1 < ::Net::SSH::Transport::HMAC::Abstract; end

# The SHA1-96 HMAC algorithm. This returns only the first 12 bytes of
# the digest.
#
# source://net-ssh//lib/net/ssh/transport/hmac/sha1_96.rb#7
class Net::SSH::Transport::HMAC::SHA1_96 < ::Net::SSH::Transport::HMAC::SHA1; end

# The SHA-256 HMAC algorithm. This has a mac and key length of 32, and
# uses the SHA-256 digest algorithm.
#
# source://net-ssh//lib/net/ssh/transport/hmac/sha2_256.rb#6
class Net::SSH::Transport::HMAC::SHA2_256 < ::Net::SSH::Transport::HMAC::Abstract; end

# The SHA256-96 HMAC algorithm. This returns only the first 12 bytes of
# the digest.
#
# source://net-ssh//lib/net/ssh/transport/hmac/sha2_256_96.rb#6
class Net::SSH::Transport::HMAC::SHA2_256_96 < ::Net::SSH::Transport::HMAC::SHA2_256; end

# The SHA-256 Encrypt-Then-Mac HMAC algorithm. This has a mac and
# key length of 32, and uses the SHA-256 digest algorithm.
#
# source://net-ssh//lib/net/ssh/transport/hmac/sha2_256_etm.rb#6
class Net::SSH::Transport::HMAC::SHA2_256_Etm < ::Net::SSH::Transport::HMAC::Abstract; end

# The SHA-512 HMAC algorithm. This has a mac and key length of 64, and
# uses the SHA-512 digest algorithm.
#
# source://net-ssh//lib/net/ssh/transport/hmac/sha2_512.rb#6
class Net::SSH::Transport::HMAC::SHA2_512 < ::Net::SSH::Transport::HMAC::Abstract; end

# The SHA2-512-96 HMAC algorithm. This returns only the first 12 bytes of
# the digest.
#
# source://net-ssh//lib/net/ssh/transport/hmac/sha2_512_96.rb#6
class Net::SSH::Transport::HMAC::SHA2_512_96 < ::Net::SSH::Transport::HMAC::SHA2_512; end

# The SHA-512 Encrypt-Then-Mac HMAC algorithm. This has a mac and
# key length of 64, and uses the SHA-512 digest algorithm.
#
# source://net-ssh//lib/net/ssh/transport/hmac/sha2_512_etm.rb#6
class Net::SSH::Transport::HMAC::SHA2_512_Etm < ::Net::SSH::Transport::HMAC::Abstract; end

# A cipher that does nothing but pass the data through, unchanged. This
# keeps things in the code nice and clean when a cipher has not yet been
# determined (i.e., during key exchange).
#
# source://net-ssh//lib/net/ssh/transport/identity_cipher.rb#8
class Net::SSH::Transport::IdentityCipher
  class << self
    # A default block size of 8 is required by the SSH2 protocol.
    #
    # source://net-ssh//lib/net/ssh/transport/identity_cipher.rb#11
    def block_size; end

    # Does nothing. Returns self.
    #
    # source://net-ssh//lib/net/ssh/transport/identity_cipher.rb#26
    def decrypt; end

    # Does nothing. Returns self.
    #
    # source://net-ssh//lib/net/ssh/transport/identity_cipher.rb#21
    def encrypt; end

    # Returns the empty string.
    #
    # source://net-ssh//lib/net/ssh/transport/identity_cipher.rb#36
    def final; end

    # Does nothing. Returns nil.
    #
    # source://net-ssh//lib/net/ssh/transport/identity_cipher.rb#46
    def iv=(v); end

    # Returns an arbitrary integer.
    #
    # source://net-ssh//lib/net/ssh/transport/identity_cipher.rb#16
    def iv_len; end

    # The name of this cipher, which is "identity".
    #
    # source://net-ssh//lib/net/ssh/transport/identity_cipher.rb#41
    def name; end

    # Does nothing. Returns self.
    #
    # source://net-ssh//lib/net/ssh/transport/identity_cipher.rb#51
    def reset; end

    # Passes its single argument through unchanged.
    #
    # source://net-ssh//lib/net/ssh/transport/identity_cipher.rb#31
    def update(text); end
  end
end

# source://net-ssh//lib/net/ssh/transport/kex/abstract.rb#10
module Net::SSH::Transport::Kex; end

# Abstract class that implement Diffie-Hellman Key Exchange
# See https://tools.ietf.org/html/rfc4253#page-21
#
# source://net-ssh//lib/net/ssh/transport/kex/abstract.rb#13
class Net::SSH::Transport::Kex::Abstract
  include ::Net::SSH::Loggable
  include ::Net::SSH::Transport::Constants

  # Create a new instance of the Diffie-Hellman Key Exchange algorithm.
  # The Diffie-Hellman (DH) key exchange provides a shared secret that
  # cannot be determined by either party alone.  The key exchange is
  # combined with a signature with the host key to provide host
  # authentication.
  #
  # @return [Abstract] a new instance of Abstract
  #
  # source://net-ssh//lib/net/ssh/transport/kex/abstract.rb#27
  def initialize(algorithms, connection, data); end

  # Returns the value of attribute algorithms.
  #
  # source://net-ssh//lib/net/ssh/transport/kex/abstract.rb#17
  def algorithms; end

  # Returns the value of attribute connection.
  #
  # source://net-ssh//lib/net/ssh/transport/kex/abstract.rb#18
  def connection; end

  # Returns the value of attribute data.
  #
  # source://net-ssh//lib/net/ssh/transport/kex/abstract.rb#19
  def data; end

  # Returns the value of attribute dh.
  #
  # source://net-ssh//lib/net/ssh/transport/kex/abstract.rb#20
  def dh; end

  # @raise [NotImplementedError]
  #
  # source://net-ssh//lib/net/ssh/transport/kex/abstract.rb#61
  def digester; end

  # Perform the key-exchange for the given session, with the given
  # data. This method will return a hash consisting of the
  # following keys:
  #
  # * :session_id
  # * :server_key
  # * :shared_secret
  # * :hashing_algorithm
  #
  # The caller is expected to be able to understand how to use these
  # deliverables.
  #
  # source://net-ssh//lib/net/ssh/transport/kex/abstract.rb#47
  def exchange_keys; end

  private

  # Send the NEWKEYS message, and expect the NEWKEYS message in
  # reply.
  #
  # @raise [Net::SSH::Exception]
  #
  # source://net-ssh//lib/net/ssh/transport/kex/abstract.rb#109
  def confirm_newkeys; end

  # source://net-ssh//lib/net/ssh/transport/kex/abstract.rb#82
  def generate_key_fingerprint(key); end

  # Verify that the given key is of the expected type, and that it
  # really is the key for the session's host. Raise Net::SSH::Exception
  # if it is not.
  #
  # source://net-ssh//lib/net/ssh/transport/kex/abstract.rb#70
  def verify_server_key(key); end

  # Verify the signature that was received. Raise Net::SSH::Exception
  # if the signature could not be verified. Otherwise, return the new
  # session-id.
  #
  # source://net-ssh//lib/net/ssh/transport/kex/abstract.rb#95
  def verify_signature(result); end
end

# Implement key-exchange algorithm from Elliptic Curve Algorithm Integration
# in the Secure Shell Transport Layer (RFC 5656)
#
# source://net-ssh//lib/net/ssh/transport/kex/abstract5656.rb#9
class Net::SSH::Transport::Kex::Abstract5656 < ::Net::SSH::Transport::Kex::Abstract
  # @raise [NotImplementedError]
  #
  # source://net-ssh//lib/net/ssh/transport/kex/abstract5656.rb#12
  def curve_name; end

  # source://net-ssh//lib/net/ssh/transport/kex/abstract.rb#20
  def ecdh; end

  private

  # source://net-ssh//lib/net/ssh/transport/kex/abstract5656.rb#22
  def build_signature_buffer(result); end

  # source://net-ssh//lib/net/ssh/transport/kex/abstract5656.rb#18
  def get_message_types; end

  # @raise [Net::SSH::Exception]
  #
  # source://net-ssh//lib/net/ssh/transport/kex/abstract5656.rb#35
  def send_kexinit; end
end

# Loads Curve25519Sha256 support which requires optinal dependencies
#
# source://net-ssh//lib/net/ssh/transport/kex/curve25519_sha256_loader.rb#6
module Net::SSH::Transport::Kex::Curve25519Sha256Loader
  class << self
    # source://net-ssh//lib/net/ssh/transport/kex/curve25519_sha256_loader.rb#22
    def dependenciesRequiredForX25519; end

    # @raise [NotImplementedError]
    #
    # source://net-ssh//lib/net/ssh/transport/kex/curve25519_sha256_loader.rb#16
    def raiseUnlessLoaded(message); end
  end
end

# source://net-ssh//lib/net/ssh/transport/kex/curve25519_sha256_loader.rb#12
Net::SSH::Transport::Kex::Curve25519Sha256Loader::ERROR = T.let(T.unsafe(nil), Gem::LoadError)

# source://net-ssh//lib/net/ssh/transport/kex/curve25519_sha256_loader.rb#13
Net::SSH::Transport::Kex::Curve25519Sha256Loader::LOADED = T.let(T.unsafe(nil), FalseClass)

# A key-exchange service implementing the "diffie-hellman-group14-sha1"
# key-exchange algorithm. (defined in RFC 4253)
#
# source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group14_sha1.rb#9
class Net::SSH::Transport::Kex::DiffieHellmanGroup14SHA1 < ::Net::SSH::Transport::Kex::DiffieHellmanGroup1SHA1; end

# The group constant
#
# source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group14_sha1.rb#32
Net::SSH::Transport::Kex::DiffieHellmanGroup14SHA1::G = T.let(T.unsafe(nil), Integer)

# The radix in which P_s represents the value of P
#
# source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group14_sha1.rb#29
Net::SSH::Transport::Kex::DiffieHellmanGroup14SHA1::P_r = T.let(T.unsafe(nil), Integer)

# The value of 'P', as a string, in hexadecimal
#
# source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group14_sha1.rb#11
Net::SSH::Transport::Kex::DiffieHellmanGroup14SHA1::P_s = T.let(T.unsafe(nil), String)

# A key-exchange service implementing the "diffie-hellman-group1-sha1"
# key-exchange algorithm.
#
# source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group1_sha1.rb#9
class Net::SSH::Transport::Kex::DiffieHellmanGroup1SHA1 < ::Net::SSH::Transport::Kex::Abstract
  # source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group1_sha1.rb#26
  def digester; end

  private

  # Build the signature buffer to use when verifying a signature from
  # the server.
  #
  # source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group1_sha1.rb#47
  def build_signature_buffer(result); end

  # Generate a DH key with a private key consisting of the given
  # number of bytes.
  #
  # source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group1_sha1.rb#62
  def generate_key; end

  # Returns the INIT/REPLY constants used by this algorithm.
  #
  # source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group1_sha1.rb#41
  def get_message_types; end

  # Returns the DH key parameters for the current connection. [p, q]
  #
  # source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group1_sha1.rb#33
  def get_parameters; end

  # Send the KEXDH_INIT message, and expect the KEXDH_REPLY. Return the
  # resulting buffer.
  #
  # Parse the buffer from a KEXDH_REPLY message, returning a hash of
  # the extracted values.
  #
  # @raise [Net::SSH::Exception]
  #
  # source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group1_sha1.rb#89
  def send_kexinit; end
end

# The group constant
#
# source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group1_sha1.rb#24
Net::SSH::Transport::Kex::DiffieHellmanGroup1SHA1::G = T.let(T.unsafe(nil), Integer)

# The radix in which P_s represents the value of P
#
# source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group1_sha1.rb#21
Net::SSH::Transport::Kex::DiffieHellmanGroup1SHA1::P_r = T.let(T.unsafe(nil), Integer)

# The value of 'P', as a string, in hexadecimal
#
# source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group1_sha1.rb#11
Net::SSH::Transport::Kex::DiffieHellmanGroup1SHA1::P_s = T.let(T.unsafe(nil), String)

# A key-exchange service implementing the
# "diffie-hellman-group-exchange-sha1" key-exchange algorithm.
#
# source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group_exchange_sha1.rb#8
class Net::SSH::Transport::Kex::DiffieHellmanGroupExchangeSHA1 < ::Net::SSH::Transport::Kex::DiffieHellmanGroup1SHA1
  private

  # Build the signature buffer to use when verifying a signature from
  # the server.
  #
  # source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group_exchange_sha1.rb#56
  def build_signature_buffer(result); end

  # Compute the number of bits needed for the given number of bytes.
  #
  # source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group_exchange_sha1.rb#15
  def compute_need_bits; end

  # Returns the INIT/REPLY constants used by this algorithm.
  #
  # source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group_exchange_sha1.rb#50
  def get_message_types; end

  # Returns the DH key parameters for the given session.
  #
  # @raise [Net::SSH::Exception]
  #
  # source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group_exchange_sha1.rb#32
  def get_parameters; end
end

# source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group_exchange_sha1.rb#10
Net::SSH::Transport::Kex::DiffieHellmanGroupExchangeSHA1::MAXIMUM_BITS = T.let(T.unsafe(nil), Integer)

# source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group_exchange_sha1.rb#9
Net::SSH::Transport::Kex::DiffieHellmanGroupExchangeSHA1::MINIMUM_BITS = T.let(T.unsafe(nil), Integer)

# A key-exchange service implementing the
# "diffie-hellman-group-exchange-sha256" key-exchange algorithm.
#
# source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group_exchange_sha256.rb#6
class Net::SSH::Transport::Kex::DiffieHellmanGroupExchangeSHA256 < ::Net::SSH::Transport::Kex::DiffieHellmanGroupExchangeSHA1
  # source://net-ssh//lib/net/ssh/transport/kex/diffie_hellman_group_exchange_sha256.rb#7
  def digester; end
end

# A key-exchange service implementing the "ecdh-sha2-nistp256"
# key-exchange algorithm. (defined in RFC 5656)
#
# source://net-ssh//lib/net/ssh/transport/kex/ecdh_sha2_nistp256.rb#9
class Net::SSH::Transport::Kex::EcdhSHA2NistP256 < ::Net::SSH::Transport::Kex::Abstract5656
  # source://net-ssh//lib/net/ssh/transport/kex/ecdh_sha2_nistp256.rb#14
  def curve_name; end

  # source://net-ssh//lib/net/ssh/transport/kex/ecdh_sha2_nistp256.rb#10
  def digester; end

  private

  # compute shared secret from server's public key and client's private key
  #
  # source://net-ssh//lib/net/ssh/transport/kex/ecdh_sha2_nistp256.rb#25
  def compute_shared_secret(server_ecdh_pubkey); end

  # string   Q_C, client's ephemeral public key octet string
  #
  # source://net-ssh//lib/net/ssh/transport/kex/ecdh_sha2_nistp256.rb#32
  def ecdh_public_key_bytes; end

  # source://net-ssh//lib/net/ssh/transport/kex/ecdh_sha2_nistp256.rb#20
  def generate_key; end
end

# A key-exchange service implementing the "ecdh-sha2-nistp256"
# key-exchange algorithm. (defined in RFC 5656)
#
# source://net-ssh//lib/net/ssh/transport/kex/ecdh_sha2_nistp384.rb#9
class Net::SSH::Transport::Kex::EcdhSHA2NistP384 < ::Net::SSH::Transport::Kex::EcdhSHA2NistP256
  # source://net-ssh//lib/net/ssh/transport/kex/ecdh_sha2_nistp384.rb#14
  def curve_name; end

  # source://net-ssh//lib/net/ssh/transport/kex/ecdh_sha2_nistp384.rb#10
  def digester; end
end

# A key-exchange service implementing the "ecdh-sha2-nistp521"
# key-exchange algorithm. (defined in RFC 5656)
#
# source://net-ssh//lib/net/ssh/transport/kex/ecdh_sha2_nistp521.rb#9
class Net::SSH::Transport::Kex::EcdhSHA2NistP521 < ::Net::SSH::Transport::Kex::EcdhSHA2NistP256
  # source://net-ssh//lib/net/ssh/transport/kex/ecdh_sha2_nistp521.rb#14
  def curve_name; end

  # source://net-ssh//lib/net/ssh/transport/kex/ecdh_sha2_nistp521.rb#10
  def digester; end
end

# Maps the supported key-exchange algorithms as named by the SSH protocol
# to their corresponding implementors.
#
# source://net-ssh//lib/net/ssh/transport/kex.rb#14
Net::SSH::Transport::Kex::MAP = T.let(T.unsafe(nil), Hash)

# source://net-ssh//lib/net/ssh/transport/key_expander.rb#4
module Net::SSH::Transport::KeyExpander
  class << self
    # Generate a key value in accordance with the SSH2 specification.
    # (RFC4253 7.2. "Output from Key Exchange")
    #
    # source://net-ssh//lib/net/ssh/transport/key_expander.rb#8
    def expand_key(bytes, start, options = T.unsafe(nil)); end
  end
end

# source://net-ssh//lib/net/ssh/transport/ctr.rb#6
class Net::SSH::Transport::OpenSSLAESCTR < ::SimpleDelegator
  # @return [OpenSSLAESCTR] a new instance of OpenSSLAESCTR
  #
  # source://net-ssh//lib/net/ssh/transport/ctr.rb#7
  def initialize(original); end

  # source://net-ssh//lib/net/ssh/transport/ctr.rb#12
  def block_size; end

  # source://net-ssh//lib/net/ssh/transport/ctr.rb#24
  def iv=(iv_s); end

  # source://net-ssh//lib/net/ssh/transport/ctr.rb#20
  def reset; end

  class << self
    # source://net-ssh//lib/net/ssh/transport/ctr.rb#16
    def block_size; end
  end
end

# A module that builds additional functionality onto the Net::SSH::BufferedIo
# module. It adds SSH encryption, compression, and packet validation, as
# per the SSH2 protocol. It also adds an abstraction for polling packets,
# to allow for both blocking and non-blocking reads.
#
# source://net-ssh//lib/net/ssh/transport/packet_stream.rb#16
module Net::SSH::Transport::PacketStream
  include ::Net::SSH::Loggable
  include ::Net::SSH::BufferedIo

  # Returns true if the IO is available for reading, and false otherwise.
  #
  # @return [Boolean]
  #
  # source://net-ssh//lib/net/ssh/transport/packet_stream.rb#74
  def available_for_read?; end

  # Performs any pending cleanup necessary on the IO and its associated
  # state objects. (See State#cleanup).
  #
  # source://net-ssh//lib/net/ssh/transport/packet_stream.rb#185
  def cleanup; end

  # The client state object, which encapsulates the algorithms used to build
  # packets to send to the server.
  #
  # source://net-ssh//lib/net/ssh/transport/packet_stream.rb#37
  def client; end

  # The name of the client (local) end of the socket, as reported by the
  # socket.
  #
  # source://net-ssh//lib/net/ssh/transport/packet_stream.rb#41
  def client_name; end

  # Enqueues a packet to be sent, but does not immediately send the packet.
  # The given payload is pre-processed according to the algorithms specified
  # in the client state (compression, cipher, and hmac).
  #
  # source://net-ssh//lib/net/ssh/transport/packet_stream.rb#127
  def enqueue_packet(payload); end

  # The map of "hints" that can be used to modify the behavior of the packet
  # stream. For instance, when authentication succeeds, an "authenticated"
  # hint is set, which is used to determine whether or not to compress the
  # data when using the "delayed" compression algorithm.
  #
  # source://net-ssh//lib/net/ssh/transport/packet_stream.rb#29
  def hints; end

  # If the IO object requires a rekey operation (as indicated by either its
  # client or server state objects, see State#needs_rekey?), this will
  # yield. Otherwise, this does nothing.
  #
  # @return [Boolean]
  #
  # source://net-ssh//lib/net/ssh/transport/packet_stream.rb#193
  def if_needs_rekey?; end

  # Returns the next full packet. If the mode parameter is :nonblock (the
  # default), then this will return immediately, whether a packet is
  # available or not, and will return nil if there is no packet ready to be
  # returned. If the mode parameter is :block, then this method will block
  # until a packet is available or timeout seconds have passed.
  #
  # source://net-ssh//lib/net/ssh/transport/packet_stream.rb#84
  def next_packet(mode = T.unsafe(nil), timeout = T.unsafe(nil)); end

  # The IP address of the peer (remote) end of the socket, as reported by
  # the socket.
  #
  # source://net-ssh//lib/net/ssh/transport/packet_stream.rb#63
  def peer_ip; end

  # Enqueues a packet to be sent, and blocks until the entire packet is
  # sent.
  #
  # source://net-ssh//lib/net/ssh/transport/packet_stream.rb#119
  def send_packet(payload); end

  # The server state object, which encapsulates the algorithms used to interpret
  # packets coming from the server.
  #
  # source://net-ssh//lib/net/ssh/transport/packet_stream.rb#33
  def server; end

  protected

  # Called when this module is used to extend an object. It initializes
  # the states and generally prepares the object for use as a packet stream.
  #
  # source://net-ssh//lib/net/ssh/transport/packet_stream.rb#205
  def initialize_ssh; end

  # Tries to read the next packet. If there is insufficient data to read
  # an entire packet, this returns immediately, otherwise the packet is
  # read, post-processed according to the cipher, hmac, and compression
  # algorithms specified in the server state object, and returned as a
  # new Packet object.
  #
  # @raise [Net::SSH::Exception]
  #
  # source://net-ssh//lib/net/ssh/transport/packet_stream.rb#219
  def poll_next_packet; end

  class << self
    # @private
    #
    # source://net-ssh//lib/net/ssh/transport/packet_stream.rb#21
    def extended(object); end
  end
end

# source://net-ssh//lib/net/ssh/transport/packet_stream.rb#17
Net::SSH::Transport::PacketStream::PROXY_COMMAND_HOST_IP = T.let(T.unsafe(nil), String)

# Negotiates the SSH protocol version and trades information about server
# and client. This is never used directly--it is always called by the
# transport layer as part of the initialization process of the transport
# layer.
#
# Note that this class also encapsulates the negotiated version, and acts as
# the authoritative reference for any queries regarding the version in effect.
#
# source://net-ssh//lib/net/ssh/transport/server_version.rb#16
class Net::SSH::Transport::ServerVersion
  include ::Net::SSH::Loggable

  # Instantiates a new ServerVersion and immediately (and synchronously)
  # negotiates the SSH protocol in effect, using the given socket.
  #
  # @return [ServerVersion] a new instance of ServerVersion
  #
  # source://net-ssh//lib/net/ssh/transport/server_version.rb#30
  def initialize(socket, logger, timeout = T.unsafe(nil)); end

  # Any header text sent by the server prior to sending the version.
  #
  # source://net-ssh//lib/net/ssh/transport/server_version.rb#23
  def header; end

  # The version string reported by the server.
  #
  # source://net-ssh//lib/net/ssh/transport/server_version.rb#26
  def version; end

  private

  # Negotiates the SSH protocol to use, via the given socket. If the server
  # reports an incompatible SSH version (e.g., SSH1), this will raise an
  # exception.
  #
  # @raise [Net::SSH::ConnectionTimeout]
  #
  # source://net-ssh//lib/net/ssh/transport/server_version.rb#42
  def negotiate!(socket, timeout); end
end

# The SSH version string as reported by Net::SSH
#
# source://net-ssh//lib/net/ssh/transport/server_version.rb#20
Net::SSH::Transport::ServerVersion::PROTO_VERSION = T.let(T.unsafe(nil), String)

# The transport layer represents the lowest level of the SSH protocol, and
# implements basic message exchanging and protocol initialization. It will
# never be instantiated directly (unless you really know what you're about),
# but will instead be created for you automatically when you create a new
# SSH session via Net::SSH.start.
#
# source://net-ssh//lib/net/ssh/transport/session.rb#24
class Net::SSH::Transport::Session
  include ::Net::SSH::Loggable
  include ::Net::SSH::Transport::Constants

  # Instantiates a new transport layer abstraction. This will block until
  # the initial key exchange completes, leaving you with a ready-to-use
  # transport session.
  #
  # @return [Session] a new instance of Session
  #
  # source://net-ssh//lib/net/ssh/transport/session.rb#59
  def initialize(host, options = T.unsafe(nil)); end

  # The Algorithms instance used to perform key exchanges.
  #
  # source://net-ssh//lib/net/ssh/transport/session.rb#47
  def algorithms; end

  # Cleans up (see PacketStream#cleanup) and closes the underlying socket.
  #
  # source://net-ssh//lib/net/ssh/transport/session.rb#128
  def close; end

  # Returns true if the underlying socket has been closed.
  #
  # @return [Boolean]
  #
  # source://net-ssh//lib/net/ssh/transport/session.rb#123
  def closed?; end

  # Configure's the packet stream's client state with the given set of
  # options. This is typically used to define the cipher, compression, and
  # hmac algorithms to use when sending packets to the server.
  #
  # source://net-ssh//lib/net/ssh/transport/session.rb#253
  def configure_client(options = T.unsafe(nil)); end

  # Configure's the packet stream's server state with the given set of
  # options. This is typically used to define the cipher, compression, and
  # hmac algorithms to use when reading packets from the server.
  #
  # source://net-ssh//lib/net/ssh/transport/session.rb#260
  def configure_server(options = T.unsafe(nil)); end

  # Enqueues the given message, such that it will be sent at the earliest
  # opportunity. This does not block, but returns immediately.
  #
  # source://net-ssh//lib/net/ssh/transport/session.rb#246
  def enqueue_message(message); end

  # Sets a new hint for the packet stream, which the packet stream may use
  # to change its behavior. (See PacketStream#hints).
  #
  # source://net-ssh//lib/net/ssh/transport/session.rb#266
  def hint(which, value = T.unsafe(nil)); end

  # The host to connect to, as given to the constructor.
  #
  # source://net-ssh//lib/net/ssh/transport/session.rb#32
  def host; end

  # Returns the host (and possibly IP address) in a format compatible with
  # SSH known-host files.
  #
  # source://net-ssh//lib/net/ssh/transport/session.rb#104
  def host_as_string; end

  # The host-key verifier object used to verify host keys, to ensure that
  # the connection is not being spoofed.
  #
  # source://net-ssh//lib/net/ssh/transport/session.rb#51
  def host_key_verifier; end

  # source://net-ssh//lib/net/ssh/transport/session.rb#95
  def host_keys; end

  # Blocks until a new packet is available to be read, and returns that
  # packet. See #poll_message.
  #
  # source://net-ssh//lib/net/ssh/transport/session.rb#174
  def next_message; end

  # The hash of options that were given to the object at initialization.
  #
  # source://net-ssh//lib/net/ssh/transport/session.rb#54
  def options; end

  # Returns a hash of information about the peer (remote) side of the socket,
  # including :ip, :port, :host, and :canonized (see #host_as_string).
  #
  # source://net-ssh//lib/net/ssh/transport/session.rb#168
  def peer; end

  # Tries to read the next packet from the socket. If mode is :nonblock (the
  # default), this will not block and will return nil if there are no packets
  # waiting to be read. Otherwise, this will block until a packet is
  # available. Note that some packet types (DISCONNECT, IGNORE, UNIMPLEMENTED,
  # DEBUG, and KEXINIT) are handled silently by this method, and will never
  # be returned.
  #
  # If a key-exchange is in process and a disallowed packet type is
  # received, it will be enqueued and otherwise ignored. When a key-exchange
  # is not in process, and consume_queue is true, packets will be first
  # read from the queue before the socket is queried.
  #
  # source://net-ssh//lib/net/ssh/transport/session.rb#189
  def poll_message(mode = T.unsafe(nil), consume_queue = T.unsafe(nil)); end

  # The port number to connect to, as given in the options to the constructor.
  # If no port number was given, this will default to DEFAULT_PORT.
  #
  # source://net-ssh//lib/net/ssh/transport/session.rb#36
  def port; end

  # Adds the given packet to the packet queue. If the queue is non-empty,
  # #poll_message will return packets from the queue in the order they
  # were received.
  #
  # source://net-ssh//lib/net/ssh/transport/session.rb#234
  def push(packet); end

  # this method is primarily for use in tests
  #
  # source://net-ssh//lib/net/ssh/transport/session.rb#273
  def queue; end

  # Requests a rekey operation, and blocks until the operation completes.
  # If a rekey is already pending, this returns immediately, having no
  # effect.
  #
  # source://net-ssh//lib/net/ssh/transport/session.rb#151
  def rekey!; end

  # Returns immediately if a rekey is already in process. Otherwise, if a
  # rekey is needed (as indicated by the socket, see PacketStream#if_needs_rekey?)
  # one is performed, causing this method to block until it completes.
  #
  # source://net-ssh//lib/net/ssh/transport/session.rb#161
  def rekey_as_needed; end

  # Sends the given message via the packet stream, blocking until the
  # entire message has been sent.
  #
  # source://net-ssh//lib/net/ssh/transport/session.rb#240
  def send_message(message); end

  # The ServerVersion instance that encapsulates the negotiated protocol
  # version.
  #
  # source://net-ssh//lib/net/ssh/transport/session.rb#44
  def server_version; end

  # Returns a new service_request packet for the given service name, ready
  # for sending to the server.
  #
  # source://net-ssh//lib/net/ssh/transport/session.rb#144
  def service_request(service); end

  # Performs a "hard" shutdown of the connection. In general, this should
  # never be done, but it might be necessary (in a rescue clause, for instance,
  # when the connection needs to close but you don't know the status of the
  # underlying protocol's state).
  #
  # source://net-ssh//lib/net/ssh/transport/session.rb#137
  def shutdown!; end

  # The underlying socket object being used to communicate with the remote
  # host.
  #
  # source://net-ssh//lib/net/ssh/transport/session.rb#40
  def socket; end

  # Waits (blocks) until the given block returns true. If no block is given,
  # this just waits long enough to see if there are any pending packets. Any
  # packets read are enqueued (see #push).
  #
  # source://net-ssh//lib/net/ssh/transport/session.rb#222
  def wait; end

  private

  # Instantiates a new host-key verification class, based on the value of
  # the parameter.
  #
  # Usually, the argument is a symbol like `:never` which corresponds to
  # a verifier, like `::Net::SSH::Verifiers::Never`.
  #
  # - :never (very insecure)
  # - :accept_new_or_local_tunnel (insecure)
  # - :accept_new (insecure)
  # - :always (secure)
  #
  # If the argument happens to respond to :verify and :verify_signature,
  # it is returned directly. Otherwise, an exception is raised.
  #
  # Values false, true, and :very were deprecated in
  # [#595](https://github.com/net-ssh/net-ssh/pull/595)
  #
  # source://net-ssh//lib/net/ssh/transport/session.rb#310
  def select_host_key_verifier(verifier); end
end

# Compatibility verifier which allows users to keep using
# custom verifier code without adding new :verify_signature
# method.
#
# source://net-ssh//lib/net/ssh/transport/session.rb#280
class Net::SSH::Transport::Session::CompatibleVerifier
  # @return [CompatibleVerifier] a new instance of CompatibleVerifier
  #
  # source://net-ssh//lib/net/ssh/transport/session.rb#281
  def initialize(verifier); end

  # source://net-ssh//lib/net/ssh/transport/session.rb#285
  def verify(arguments); end

  # source://net-ssh//lib/net/ssh/transport/session.rb#289
  def verify_signature(&block); end
end

# The standard port for the SSH protocol.
#
# source://net-ssh//lib/net/ssh/transport/session.rb#29
Net::SSH::Transport::Session::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)

# Encapsulates state information about one end of an SSH connection. Such
# state includes the packet sequence number, the algorithms in use, how
# many packets and blocks have been processed since the last reset, and so
# forth. This class will never be instantiated directly, but is used as
# part of the internal state of the PacketStream module.
#
# source://net-ssh//lib/net/ssh/transport/state.rb#14
class Net::SSH::Transport::State
  # Creates a new state object, belonging to the given socket. Initializes
  # the algorithms to "none".
  #
  # @return [State] a new instance of State
  #
  # source://net-ssh//lib/net/ssh/transport/state.rb#59
  def initialize(socket, role); end

  # The block size for the cipher
  #
  # source://net-ssh//lib/net/ssh/transport/state.rb#40
  def block_size; end

  # The number of data blocks processed since the last call to #reset!
  #
  # source://net-ssh//lib/net/ssh/transport/state.rb#34
  def blocks; end

  # The cipher algorithm in use for this socket endpoint.
  #
  # source://net-ssh//lib/net/ssh/transport/state.rb#37
  def cipher; end

  # Closes any the compressor and/or decompressor objects that have been
  # instantiated.
  #
  # source://net-ssh//lib/net/ssh/transport/state.rb#167
  def cleanup; end

  # Compresses the data. If no compression is in effect, this will just return
  # the data unmodified, otherwise it uses #compressor to compress the data.
  #
  # source://net-ssh//lib/net/ssh/transport/state.rb#122
  def compress(data); end

  # The compression algorithm in use for this endpoint.
  #
  # source://net-ssh//lib/net/ssh/transport/state.rb#25
  def compression; end

  # Returns true if data compression/decompression is enabled. This will
  # return true if :standard compression is selected, or if :delayed
  # compression is selected and the :authenticated hint has been received
  # by the socket.
  #
  # @return [Boolean]
  #
  # source://net-ssh//lib/net/ssh/transport/state.rb#116
  def compression?; end

  # The compression level to use when compressing data (or nil, for the default).
  #
  # source://net-ssh//lib/net/ssh/transport/state.rb#28
  def compression_level; end

  # The compressor object to use when compressing data. This takes into account
  # the desired compression level.
  #
  # source://net-ssh//lib/net/ssh/transport/state.rb#103
  def compressor; end

  # Deompresses the data. If no compression is in effect, this will just return
  # the data unmodified, otherwise it uses #decompressor to decompress the data.
  #
  # source://net-ssh//lib/net/ssh/transport/state.rb#130
  def decompress(data); end

  # The decompressor object to use when decompressing data.
  #
  # source://net-ssh//lib/net/ssh/transport/state.rb#108
  def decompressor; end

  # source://net-ssh//lib/net/ssh/transport/state.rb#86
  def final_cipher; end

  # The hmac algorithm in use for this endpoint.
  #
  # source://net-ssh//lib/net/ssh/transport/state.rb#22
  def hmac; end

  # Increments the counters. The sequence number is incremented (and remapped
  # so it always fits in a 32-bit integer). The number of packets and blocks
  # are also incremented.
  #
  # source://net-ssh//lib/net/ssh/transport/state.rb#95
  def increment(packet_length); end

  # The maximum number of blocks that this endpoint wants to process before
  # needing a rekey.
  #
  # source://net-ssh//lib/net/ssh/transport/state.rb#51
  def max_blocks; end

  # The maximum number of blocks that this endpoint wants to process before
  # needing a rekey.
  #
  # source://net-ssh//lib/net/ssh/transport/state.rb#51
  def max_blocks=(_arg0); end

  # The maximum number of packets that this endpoint wants to process before
  # needing a rekey.
  #
  # source://net-ssh//lib/net/ssh/transport/state.rb#47
  def max_packets; end

  # The maximum number of packets that this endpoint wants to process before
  # needing a rekey.
  #
  # source://net-ssh//lib/net/ssh/transport/state.rb#47
  def max_packets=(_arg0); end

  # Returns true if the number of packets processed exceeds the maximum
  # number of packets, or if the number of blocks processed exceeds the
  # maximum number of blocks.
  #
  # @return [Boolean]
  #
  # source://net-ssh//lib/net/ssh/transport/state.rb#186
  def needs_rekey?; end

  # The number of packets processed since the last call to #reset!
  #
  # source://net-ssh//lib/net/ssh/transport/state.rb#31
  def packets; end

  # The user-specified maximum number of bytes that this endpoint ought to
  # process before needing a rekey.
  #
  # source://net-ssh//lib/net/ssh/transport/state.rb#55
  def rekey_limit; end

  # The user-specified maximum number of bytes that this endpoint ought to
  # process before needing a rekey.
  #
  # source://net-ssh//lib/net/ssh/transport/state.rb#55
  def rekey_limit=(_arg0); end

  # Resets the counters on the state object, but leaves the sequence_number
  # unchanged. It also sets defaults for and recomputes the max_packets and
  # max_blocks values.
  #
  # source://net-ssh//lib/net/ssh/transport/state.rb#139
  def reset!; end

  # The role that this state plays (either :client or :server)
  #
  # source://net-ssh//lib/net/ssh/transport/state.rb#43
  def role; end

  # The next packet sequence number for this socket endpoint.
  #
  # source://net-ssh//lib/net/ssh/transport/state.rb#19
  def sequence_number; end

  # A convenience method for quickly setting multiple values in a single
  # command.
  #
  # source://net-ssh//lib/net/ssh/transport/state.rb#73
  def set(values); end

  # The socket object that owns this state object.
  #
  # source://net-ssh//lib/net/ssh/transport/state.rb#16
  def socket; end

  # source://net-ssh//lib/net/ssh/transport/state.rb#80
  def update_cipher(data); end

  private

  # source://net-ssh//lib/net/ssh/transport/state.rb#193
  def update_next_iv(data, reset = T.unsafe(nil)); end
end

# This is the set of options that Net::SSH.start recognizes. See
# Net::SSH.start for a description of each option.
#
# source://net-ssh//lib/net/ssh.rb#66
Net::SSH::VALID_OPTIONS = T.let(T.unsafe(nil), Array)

# source://net-ssh//lib/net/ssh/verifiers/always.rb#6
module Net::SSH::Verifiers; end

# Does a strict host verification, looking the server up in the known
# host files to see if a key has already been seen for this server. If this
# server does not appear in any host file, this will silently add the
# server. If the server does appear at least once, but the key given does
# not match any known for the server, an exception will be raised (HostKeyMismatch).
# Otherwise, this returns true.
#
# source://net-ssh//lib/net/ssh/verifiers/accept_new.rb#15
class Net::SSH::Verifiers::AcceptNew < ::Net::SSH::Verifiers::Always
  # source://net-ssh//lib/net/ssh/verifiers/accept_new.rb#16
  def verify(arguments); end

  # source://net-ssh//lib/net/ssh/verifiers/accept_new.rb#25
  def verify_signature(&block); end
end

# Basically the same as the AcceptNew verifier, but does not try to actually
# verify a connection if the server is the localhost and the port is a
# nonstandard port number. Those two conditions will typically mean the
# connection is being tunnelled through a forwarded port, so the known-hosts
# file will not be helpful (in general).
#
# source://net-ssh//lib/net/ssh/verifiers/accept_new_or_local_tunnel.rb#12
class Net::SSH::Verifiers::AcceptNewOrLocalTunnel < ::Net::SSH::Verifiers::AcceptNew
  # Tries to determine if the connection is being tunnelled, and if so,
  # returns true. Otherwise, performs the standard strict verification.
  #
  # source://net-ssh//lib/net/ssh/verifiers/accept_new_or_local_tunnel.rb#15
  def verify(arguments); end

  private

  # A connection is potentially being tunnelled if the port is not 22,
  # and the ip refers to the localhost.
  #
  # @return [Boolean]
  #
  # source://net-ssh//lib/net/ssh/verifiers/accept_new_or_local_tunnel.rb#24
  def tunnelled?(args); end
end

# Does a strict host verification, looking the server up in the known
# host files to see if a key has already been seen for this server. If this
# server does not appear in any host file, an exception will be raised
# (HostKeyUnknown). This is in contrast to the "Strict" class, which will
# silently add the key to your known_hosts file. If the server does appear at
# least once, but the key given does not match any known for the server, an
# exception will be raised (HostKeyMismatch).
# Otherwise, this returns true.
#
# source://net-ssh//lib/net/ssh/verifiers/always.rb#16
class Net::SSH::Verifiers::Always
  # source://net-ssh//lib/net/ssh/verifiers/always.rb#17
  def verify(arguments); end

  # source://net-ssh//lib/net/ssh/verifiers/always.rb#37
  def verify_signature(&block); end

  private

  # source://net-ssh//lib/net/ssh/verifiers/always.rb#43
  def process_cache_miss(host_keys, args, exc_class, message); end
end

# This host key verifier simply allows every key it sees, without
# any verification. This is simple, but very insecure because it
# exposes you to MiTM attacks.
#
# source://net-ssh//lib/net/ssh/verifiers/never.rb#8
class Net::SSH::Verifiers::Never
  # Returns true.
  #
  # source://net-ssh//lib/net/ssh/verifiers/never.rb#10
  def verify(arguments); end

  # source://net-ssh//lib/net/ssh/verifiers/never.rb#14
  def verify_signature(&block); end
end

# A class for describing the current version of a library. The version
# consists of three parts: the +major+ number, the +minor+ number, and the
# +tiny+ (or +patch+) number.
#
# Two Version instances may be compared, so that you can test that a version
# of a library is what you require:
#
#   require 'net/ssh/version'
#
#   if Net::SSH::Version::CURRENT < Net::SSH::Version[2,1,0]
#     abort "your software is too old!"
#   end
#
# source://net-ssh//lib/net/ssh/version.rb#15
class Net::SSH::Version
  include ::Comparable

  # Create a new Version object with the given components.
  #
  # @return [Version] a new instance of Version
  #
  # source://net-ssh//lib/net/ssh/version.rb#27
  def initialize(major, minor, tiny, pre = T.unsafe(nil)); end

  # Compare this version to the given +version+ object.
  #
  # source://net-ssh//lib/net/ssh/version.rb#32
  def <=>(version); end

  # Returns the value of attribute major.
  #
  # source://net-ssh//lib/net/ssh/version.rb#24
  def major; end

  # Returns the value of attribute minor.
  #
  # source://net-ssh//lib/net/ssh/version.rb#24
  def minor; end

  # Returns the value of attribute tiny.
  #
  # source://net-ssh//lib/net/ssh/version.rb#24
  def tiny; end

  # Converts this version to a canonical integer that may be compared
  # against other version objects.
  #
  # source://net-ssh//lib/net/ssh/version.rb#44
  def to_i; end

  # Converts this version object to a string, where each of the three
  # version components are joined by the '.' character. E.g., 2.0.0.
  #
  # source://net-ssh//lib/net/ssh/version.rb#38
  def to_s; end

  class << self
    # A convenience method for instantiating a new Version instance with the
    # given +major+, +minor+, and +tiny+ components.
    #
    # source://net-ssh//lib/net/ssh/version.rb#20
    def [](major, minor, tiny, pre = T.unsafe(nil)); end
  end
end

# The current version of the Net::SSH library as a Version instance
#
# source://net-ssh//lib/net/ssh/version.rb#62
Net::SSH::Version::CURRENT = T.let(T.unsafe(nil), Net::SSH::Version)

# The major component of this version of the Net::SSH library
#
# source://net-ssh//lib/net/ssh/version.rb#49
Net::SSH::Version::MAJOR = T.let(T.unsafe(nil), Integer)

# The minor component of this version of the Net::SSH library
#
# source://net-ssh//lib/net/ssh/version.rb#52
Net::SSH::Version::MINOR = T.let(T.unsafe(nil), Integer)

# The prerelease component of this version of the Net::SSH library
# nil allowed
#
# source://net-ssh//lib/net/ssh/version.rb#59
Net::SSH::Version::PRE = T.let(T.unsafe(nil), T.untyped)

# The current version of the Net::SSH library as a String
#
# source://net-ssh//lib/net/ssh/version.rb#65
Net::SSH::Version::STRING = T.let(T.unsafe(nil), String)

# The tiny component of this version of the Net::SSH library
#
# source://net-ssh//lib/net/ssh/version.rb#55
Net::SSH::Version::TINY = T.let(T.unsafe(nil), Integer)

# This class is originally defined in the OpenSSL module. As needed, methods
# have been added to it by the Net::SSH module for convenience in dealing with
# SSH functionality.
#
# source://net-ssh//lib/net/ssh/transport/openssl.rb#9
class OpenSSL::BN
  # Converts a BN object to a string. The format used is that which is
  # required by the SSH2 protocol.
  #
  # source://net-ssh//lib/net/ssh/transport/openssl.rb#12
  def to_ssh; end
end

# This class is originally defined in the OpenSSL module. As needed, methods
# have been added to it by the Net::SSH module for convenience in dealing
# with SSH functionality.
#
# source://net-ssh//lib/net/ssh/transport/openssl.rb#35
class OpenSSL::PKey::DH < ::OpenSSL::PKey::PKey
  # Determines whether the pub_key for this key is valid. (This algorithm
  # lifted more-or-less directly from OpenSSH, dh.c, dh_pub_is_valid.)
  #
  # @return [Boolean]
  #
  # source://net-ssh//lib/net/ssh/transport/openssl.rb#38
  def valid?; end
end

# This class is originally defined in the OpenSSL module. As needed, methods
# have been added to it by the Net::SSH module for convenience in dealing
# with SSH functionality.
#
# source://net-ssh//lib/net/ssh/transport/openssl.rb#79
class OpenSSL::PKey::DSA < ::OpenSSL::PKey::PKey
  # Signs the given data.
  #
  # @raise [OpenSSL::PKey::DSAError]
  #
  # source://net-ssh//lib/net/ssh/transport/openssl.rb#108
  def ssh_do_sign(data); end

  # Verifies the given signature matches the given data.
  #
  # source://net-ssh//lib/net/ssh/transport/openssl.rb#97
  def ssh_do_verify(sig, data); end

  # source://net-ssh//lib/net/ssh/transport/openssl.rb#86
  def ssh_signature_type; end

  # Returns "ssh-dss", which is the description of this key type used by the
  # SSH2 protocol.
  #
  # source://net-ssh//lib/net/ssh/transport/openssl.rb#82
  def ssh_type; end

  # Converts the key to a blob, according to the SSH2 protocol.
  #
  # source://net-ssh//lib/net/ssh/transport/openssl.rb#91
  def to_blob; end
end

# This class is originally defined in the OpenSSL module. As needed, methods
# have been added to it by the Net::SSH module for convenience in dealing
# with SSH functionality.
#
# source://net-ssh//lib/net/ssh/transport/openssl.rb#127
class OpenSSL::PKey::EC < ::OpenSSL::PKey::PKey
  # Returns the signature for the given data.
  #
  # source://net-ssh//lib/net/ssh/transport/openssl.rb#221
  def ssh_do_sign(data); end

  # Verifies the given signature matches the given data.
  #
  # source://net-ssh//lib/net/ssh/transport/openssl.rb#195
  def ssh_do_verify(sig, data); end

  # source://net-ssh//lib/net/ssh/transport/openssl.rb#166
  def ssh_signature_type; end

  # Returns the description of this key type used by the
  # SSH2 protocol, like "ecdsa-sha2-nistp256"
  #
  # source://net-ssh//lib/net/ssh/transport/openssl.rb#162
  def ssh_type; end

  # Converts the key to a blob, according to the SSH2 protocol.
  #
  # source://net-ssh//lib/net/ssh/transport/openssl.rb#187
  def to_blob; end

  private

  # source://net-ssh//lib/net/ssh/transport/openssl.rb#170
  def digester; end

  class << self
    # source://net-ssh//lib/net/ssh/transport/openssl.rb#140
    def read_keyblob(curve_name_in_type, buffer); end
  end
end

# source://net-ssh//lib/net/ssh/transport/openssl.rb#128
OpenSSL::PKey::EC::CurveNameAlias = T.let(T.unsafe(nil), Hash)

# source://net-ssh//lib/net/ssh/transport/openssl.rb#134
OpenSSL::PKey::EC::CurveNameAliasInv = T.let(T.unsafe(nil), Hash)

# source://net-ssh//lib/net/ssh/transport/openssl.rb#232
class OpenSSL::PKey::EC::Point
  # Returns the description of this key type used by the
  # SSH2 protocol, like "ecdsa-sha2-nistp256"
  #
  # source://net-ssh//lib/net/ssh/transport/openssl.rb#235
  def ssh_type; end

  # Converts the key to a blob, according to the SSH2 protocol.
  #
  # source://net-ssh//lib/net/ssh/transport/openssl.rb#240
  def to_blob; end
end

# source://net-ssh//lib/net/ssh/transport/openssl.rb#28
class OpenSSL::PKey::PKey
  include ::Net::SSH::Authentication::PubKeyFingerprint
end

# This class is originally defined in the OpenSSL module. As needed, methods
# have been added to it by the Net::SSH module for convenience in dealing
# with SSH functionality.
#
# source://net-ssh//lib/net/ssh/transport/openssl.rb#49
class OpenSSL::PKey::RSA < ::OpenSSL::PKey::PKey
  # Returns the signature for the given data.
  #
  # source://net-ssh//lib/net/ssh/transport/openssl.rb#71
  def ssh_do_sign(data); end

  # Verifies the given signature matches the given data.
  #
  # source://net-ssh//lib/net/ssh/transport/openssl.rb#66
  def ssh_do_verify(sig, data); end

  # source://net-ssh//lib/net/ssh/transport/openssl.rb#56
  def ssh_signature_type; end

  # Returns "ssh-rsa", which is the description of this key type used by the
  # SSH2 protocol.
  #
  # source://net-ssh//lib/net/ssh/transport/openssl.rb#52
  def ssh_type; end

  # Converts the key to a blob, according to the SSH2 protocol.
  #
  # source://net-ssh//lib/net/ssh/transport/openssl.rb#61
  def to_blob; end
end
