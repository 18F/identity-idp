# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `shoulda-matchers` gem.
# Please instead update this file by running `bin/tapioca gem shoulda-matchers`.


# source://shoulda-matchers//lib/shoulda/matchers/configuration.rb#1
module Shoulda; end

# source://shoulda-matchers//lib/shoulda/matchers/configuration.rb#2
module Shoulda::Matchers
  extend ::Shoulda::Matchers::WordWrap

  class << self
    # @private
    #
    # source://shoulda-matchers//lib/shoulda/matchers.rb#21
    def assertion_exception_class; end

    # @private
    #
    # source://shoulda-matchers//lib/shoulda/matchers.rb#21
    def assertion_exception_class=(_arg0); end

    # @private
    #
    # source://shoulda-matchers//lib/shoulda/matchers/configuration.rb#14
    def configuration; end

    # @private
    # @yield [configuration]
    #
    # source://shoulda-matchers//lib/shoulda/matchers/configuration.rb#4
    def configure; end

    # @private
    #
    # source://shoulda-matchers//lib/shoulda/matchers/configuration.rb#9
    def integrations; end

    # @private
    #
    # source://shoulda-matchers//lib/shoulda/matchers/warn.rb#7
    def warn(message); end

    # @private
    #
    # source://shoulda-matchers//lib/shoulda/matchers/warn.rb#21
    def warn_about_deprecated_method(old_method, new_method); end
  end
end

# This module provides matchers that are used to test behavior within
# controllers.
#
# source://shoulda-matchers//lib/shoulda/matchers/action_controller/filter_param_matcher.rb#3
module Shoulda::Matchers::ActionController
  # The `filter_param` matcher is used to test parameter filtering
  # configuration. Specifically, it asserts that the given parameter is
  # present in `config.filter_parameters`.
  #
  #     class MyApplication < Rails::Application
  #       config.filter_parameters << :secret_key
  #     end
  #
  #     # RSpec
  #     RSpec.describe ApplicationController, type: :controller do
  #       it { should filter_param(:secret_key) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class ApplicationControllerTest < ActionController::TestCase
  #       should filter_param(:secret_key)
  #     end
  #
  # @return [FilterParamMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/filter_param_matcher.rb#24
  def filter_param(key); end

  # The `permit` matcher tests that an action in your controller receives a
  # whitelist of parameters using Rails' Strong Parameters feature
  # (specifically that `permit` was called with the correct arguments).
  #
  # Here's an example:
  #
  #     class UsersController < ApplicationController
  #       def create
  #         user = User.create(user_params)
  #         # ...
  #       end
  #
  #       private
  #
  #       def user_params
  #         params.require(:user).permit(
  #           :first_name,
  #           :last_name,
  #           :email,
  #           :password
  #         )
  #       end
  #     end
  #
  #     # RSpec
  #     RSpec.describe UsersController, type: :controller do
  #       it do
  #         params = {
  #           user: {
  #             first_name: 'John',
  #             last_name: 'Doe',
  #             email: 'johndoe@example.com',
  #             password: 'password'
  #           }
  #         }
  #         should permit(:first_name, :last_name, :email, :password).
  #           for(:create, params: params).
  #           on(:user)
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class UsersControllerTest < ActionController::TestCase
  #       should "(for POST #create) restrict parameters on :user to first_name, last_name, email, and password" do
  #         params = {
  #           user: {
  #             first_name: 'John',
  #             last_name: 'Doe',
  #             email: 'johndoe@example.com',
  #             password: 'password'
  #           }
  #         }
  #         matcher = permit(:first_name, :last_name, :email, :password).
  #           for(:create, params: params).
  #           on(:user)
  #         assert_accepts matcher, subject
  #       end
  #     end
  #
  # If your action requires query parameters in order to work, then you'll
  # need to supply them:
  #
  #     class UsersController < ApplicationController
  #       def update
  #         user = User.find(params[:id])
  #
  #         if user.update_attributes(user_params)
  #           # ...
  #         else
  #           # ...
  #         end
  #       end
  #
  #       private
  #
  #       def user_params
  #         params.require(:user).permit(
  #           :first_name,
  #           :last_name,
  #           :email,
  #           :password
  #         )
  #       end
  #     end
  #
  #     # RSpec
  #     RSpec.describe UsersController, type: :controller do
  #       before do
  #         create(:user, id: 1)
  #       end
  #
  #       it do
  #         params = {
  #           id: 1,
  #           user: {
  #             first_name: 'Jon',
  #             last_name: 'Doe',
  #             email: 'jondoe@example.com',
  #             password: 'password'
  #           }
  #         }
  #         should permit(:first_name, :last_name, :email, :password).
  #           for(:update, params: params).
  #           on(:user)
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class UsersControllerTest < ActionController::TestCase
  #       setup do
  #         create(:user, id: 1)
  #       end
  #
  #       should "(for PATCH #update) restrict parameters on :user to :first_name, :last_name, :email, and :password" do
  #         params = {
  #           id: 1,
  #           user: {
  #             first_name: 'Jon',
  #             last_name: 'Doe',
  #             email: 'jondoe@example.com',
  #             password: 'password'
  #           }
  #         }
  #         matcher = permit(:first_name, :last_name, :email, :password).
  #           for(:update, params: params).
  #           on(:user)
  #         assert_accepts matcher, subject
  #       end
  #     end
  #
  # Finally, if you have an action that isn't one of the seven resourceful
  # actions, then you'll need to provide the HTTP verb that it responds to:
  #
  #     Rails.application.routes.draw do
  #       resources :users do
  #         member do
  #           put :toggle
  #         end
  #       end
  #     end
  #
  #     class UsersController < ApplicationController
  #       def toggle
  #         user = User.find(params[:id])
  #
  #         if user.update_attributes(user_params)
  #           # ...
  #         else
  #           # ...
  #         end
  #       end
  #
  #       private
  #
  #       def user_params
  #         params.require(:user).permit(:activated)
  #       end
  #     end
  #
  #     # RSpec
  #     RSpec.describe UsersController, type: :controller do
  #       before do
  #         create(:user, id: 1)
  #       end
  #
  #       it do
  #         params = { id: 1, user: { activated: true } }
  #         should permit(:activated).
  #           for(:toggle, params: params, verb: :put).
  #           on(:user)
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class UsersControllerTest < ActionController::TestCase
  #       setup do
  #         create(:user, id: 1)
  #       end
  #
  #       should "(for PUT #toggle) restrict parameters on :user to :activated" do
  #         params = { id: 1, user: { activated: true } }
  #         matcher = permit(:activated).
  #           for(:toggle, params: params, verb: :put).
  #           on(:user)
  #         assert_accepts matcher, subject
  #       end
  #     end
  #
  # @return [PermitMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#203
  def permit(*params); end

  # The `redirect_to` matcher tests that an action redirects to a certain
  # location. In a test suite using RSpec, it is very similar to
  # rspec-rails's `redirect_to` matcher. In a test suite using Minitest +
  # Shoulda, it provides a more expressive syntax over
  # `assert_redirected_to`.
  #
  #     class PostsController < ApplicationController
  #       def show
  #         redirect_to :index
  #       end
  #     end
  #
  #     # RSpec
  #     RSpec.describe PostsController, type: :controller do
  #       describe 'GET #show' do
  #         before { get :show }
  #
  #         it { should redirect_to(posts_path) }
  #         it { should redirect_to(action: :index) }
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PostsControllerTest < ActionController::TestCase
  #       context 'GET #show' do
  #         setup { get :show }
  #
  #         should redirect_to('/posts') { posts_path }
  #         should redirect_to(action: :index)
  #       end
  #     end
  #
  # @return [RedirectToMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/redirect_to_matcher.rb#38
  def redirect_to(url_or_description, &block); end

  # The `render_template` matcher tests that an action renders a template
  # or partial. In RSpec, it is very similar to rspec-rails's
  # `render_template` matcher. In a test suite using Minitest + Shoulda, it
  # provides a more expressive syntax over `assert_template`.
  #
  #     class PostsController < ApplicationController
  #       def show
  #       end
  #     end
  #
  #     # app/views/posts/show.html.erb
  #     <%= render 'sidebar' %>
  #
  #     # RSpec
  #     RSpec.describe PostsController, type: :controller do
  #       describe 'GET #show' do
  #         before { get :show }
  #
  #         it { should render_template('show') }
  #         it { should render_template(partial: '_sidebar') }
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PostsControllerTest < ActionController::TestCase
  #       context 'GET #show' do
  #         setup { get :show }
  #
  #         should render_template('show')
  #         should render_template(partial: '_sidebar')
  #       end
  #     end
  #
  # @return [RenderTemplateMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/render_template_matcher.rb#39
  def render_template(options = T.unsafe(nil), message = T.unsafe(nil)); end

  # The `render_with_layout` matcher asserts that an action is rendered with
  # a particular layout.
  #
  #     class PostsController < ApplicationController
  #       def show
  #         render layout: 'posts'
  #       end
  #     end
  #
  #     # RSpec
  #     RSpec.describe PostsController, type: :controller do
  #       describe 'GET #show' do
  #         before { get :show }
  #
  #         it { should render_with_layout('posts') }
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PostsControllerTest < ActionController::TestCase
  #       context 'GET #show' do
  #         setup { get :show }
  #
  #         should render_with_layout('posts')
  #       end
  #     end
  #
  # It can also be used to assert that the action is not rendered with a
  # layout at all:
  #
  #     class PostsController < ApplicationController
  #       def sidebar
  #         render layout: false
  #       end
  #     end
  #
  #     # RSpec
  #     RSpec.describe PostsController, type: :controller do
  #       describe 'GET #sidebar' do
  #         before { get :sidebar }
  #
  #         it { should_not render_with_layout }
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PostsControllerTest < ActionController::TestCase
  #       context 'GET #sidebar' do
  #         setup { get :sidebar }
  #
  #         should_not render_with_layout
  #       end
  #     end
  #
  # @return [RenderWithLayoutMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/render_with_layout_matcher.rb#60
  def render_with_layout(expected_layout = T.unsafe(nil)); end

  # The `rescue_from` matcher tests usage of the `rescue_from` macro. It
  # asserts that an exception and method are present in the list of
  # exception handlers, and that the handler method exists.
  #
  #     class ApplicationController < ActionController::Base
  #       rescue_from ActiveRecord::RecordNotFound, with: :handle_not_found
  #
  #       private
  #
  #       def handle_not_found
  #         # ...
  #       end
  #     end
  #
  #     # RSpec
  #     RSpec.describe ApplicationController, type: :controller do
  #       it do
  #         should rescue_from(ActiveRecord::RecordNotFound).
  #           with(:handle_not_found)
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class ApplicationControllerTest < ActionController::TestCase
  #       should rescue_from(ActiveRecord::RecordNotFound).
  #         with(:handle_not_found)
  #     end
  #
  # @return [RescueFromMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/rescue_from_matcher.rb#34
  def rescue_from(exception); end

  # The `respond_with` matcher tests that an action responds with a certain
  # status code.
  #
  # You can specify that the status should be a number:
  #
  #     class PostsController < ApplicationController
  #       def index
  #         render status: 403
  #       end
  #     end
  #
  #     # RSpec
  #     RSpec.describe PostsController, type: :controller do
  #       describe 'GET #index' do
  #         before { get :index }
  #
  #         it { should respond_with(403) }
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PostsControllerTest < ActionController::TestCase
  #       context 'GET #index' do
  #         setup { get :index }
  #
  #         should respond_with(403)
  #       end
  #     end
  #
  # You can specify that the status should be within a range of numbers:
  #
  #     class PostsController < ApplicationController
  #       def destroy
  #         render status: 508
  #       end
  #     end
  #
  #     # RSpec
  #     RSpec.describe PostsController, type: :controller do
  #       describe 'DELETE #destroy' do
  #         before { delete :destroy }
  #
  #         it { should respond_with(500..600) }
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PostsControllerTest < ActionController::TestCase
  #       context 'DELETE #destroy' do
  #         setup { delete :destroy }
  #
  #         should respond_with(500..600)
  #       end
  #     end
  #
  # Finally, you can specify that the status should be a symbol:
  #
  #     class PostsController < ApplicationController
  #       def show
  #         render status: :locked
  #       end
  #     end
  #
  #     # RSpec
  #     RSpec.describe PostsController, type: :controller do
  #       describe 'GET #show' do
  #         before { get :show }
  #
  #         it { should respond_with(:locked) }
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PostsControllerTest < ActionController::TestCase
  #       context 'GET #show' do
  #         setup { get :show }
  #
  #         should respond_with(:locked)
  #       end
  #     end
  #
  # @return [RespondWithMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/respond_with_matcher.rb#87
  def respond_with(status); end

  # The `route` matcher tests that a route resolves to a controller,
  # action, and params; and that the controller, action, and params
  # generates the same route. For an RSpec suite, this is like using a
  # combination of `route_to` and `be_routable`. In a test suite using
  # Minitest + Shoulda, it provides a more expressive syntax over
  # `assert_routing`.
  #
  # You can use this matcher either in a controller test case or in a
  # routing test case. For instance, given these routes:
  #
  #     My::Application.routes.draw do
  #       get '/posts', to: 'posts#index'
  #       get '/posts/:id', to: 'posts#show'
  #     end
  #
  # You could choose to write tests for these routes alongside other tests
  # for PostsController:
  #
  #     class PostsController < ApplicationController
  #       # ...
  #     end
  #
  #     # RSpec
  #     RSpec.describe PostsController, type: :controller do
  #       it { should route(:get, '/posts').to(action: :index) }
  #       it { should route(:get, '/posts/1').to(action: :show, id: 1) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PostsControllerTest < ActionController::TestCase
  #       should route(:get, '/posts').to(action: 'index')
  #       should route(:get, '/posts/1').to(action: :show, id: 1)
  #     end
  #
  # Or you could place the tests along with other route tests:
  #
  #     # RSpec
  #     describe 'Routing', type: :routing do
  #       it do
  #         should route(:get, '/posts').
  #           to(controller: :posts, action: :index)
  #       end
  #
  #       it do
  #         should route(:get, '/posts/1').
  #           to('posts#show', id: 1)
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class RoutesTest < ActionController::IntegrationTest
  #       should route(:get, '/posts').
  #         to(controller: :posts, action: :index)
  #
  #       should route(:get, '/posts/1').
  #         to('posts#show', id: 1)
  #     end
  #
  # Notice that in the former case, as we are inside of a test case for
  # PostsController, we do not have to specify that the routes resolve to
  # this controller. In the latter case we specify this using the
  # `controller` key passed to the `to` qualifier.
  #
  # #### Specifying a port
  #
  # If the route you're testing has a constraint on it that limits the route
  # to a particular port, you can specify it by passing a `port` option to
  # the matcher:
  #
  #     class PortConstraint
  #       def initialize(port)
  #         @port = port
  #       end
  #
  #       def matches?(request)
  #         request.port == @port
  #       end
  #     end
  #
  #     My::Application.routes.draw do
  #       get '/posts',
  #         to: 'posts#index',
  #         constraints: PortConstraint.new(12345)
  #     end
  #
  #     # RSpec
  #     describe 'Routing', type: :routing do
  #       it do
  #         should route(:get, '/posts', port: 12345).
  #           to('posts#index')
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class RoutesTest < ActionController::IntegrationTest
  #       should route(:get, '/posts', port: 12345).
  #         to('posts#index')
  #     end
  #
  # #### Qualifiers
  #
  # ##### to
  #
  # Use `to` to specify the action (along with the controller, if needed)
  # that the route resolves to.
  #
  # `to` takes either keyword arguments (`controller` and `action`) or a
  # string that represents the controller/action pair:
  #
  #     route(:get, '/posts').to(action: index)
  #     route(:get, '/posts').to(controller: :posts, action: index)
  #     route(:get, '/posts').to('posts#index')
  #
  # If there are parameters in your route, then specify those too:
  #
  #     route(:get, '/posts/1').to('posts#show', id: 1)
  #
  # You may also specify special parameters such as `:format`:
  #
  #     route(:get, '/posts').to('posts#index', format: :json)
  #
  # @return [RouteMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/route_matcher.rb#127
  def route(method, path, port: T.unsafe(nil)); end

  # The `set_flash` matcher is used to make assertions about the
  # `flash` hash.
  #
  #     class PostsController < ApplicationController
  #       def index
  #         flash[:foo] = 'A candy bar'
  #       end
  #
  #       def destroy
  #       end
  #     end
  #
  #     # RSpec
  #     RSpec.describe PostsController, type: :controller do
  #       describe 'GET #index' do
  #         before { get :index }
  #
  #         it { should set_flash }
  #       end
  #
  #       describe 'DELETE #destroy' do
  #         before { delete :destroy }
  #
  #         it { should_not set_flash }
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PostsControllerTest < ActionController::TestCase
  #       context 'GET #index' do
  #         setup { get :index }
  #
  #         should set_flash
  #       end
  #
  #       context 'DELETE #destroy' do
  #         setup { delete :destroy }
  #
  #         should_not set_flash
  #       end
  #     end
  #
  # #### Qualifiers
  #
  # ##### []
  #
  # Use `[]` to narrow the scope of the matcher to a particular key.
  #
  #     class PostsController < ApplicationController
  #       def index
  #         flash[:foo] = 'A candy bar'
  #       end
  #     end
  #
  #     # RSpec
  #     RSpec.describe PostsController, type: :controller do
  #       describe 'GET #index' do
  #         before { get :index }
  #
  #         it { should set_flash[:foo] }
  #         it { should_not set_flash[:bar] }
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PostsControllerTest < ActionController::TestCase
  #       context 'GET #index' do
  #         setup { get :show }
  #
  #         should set_flash[:foo]
  #         should_not set_flash[:bar]
  #       end
  #     end
  #
  # ##### to
  #
  # Use `to` to assert that some key was set to a particular value, or that
  # some key matches a particular regex.
  #
  #     class PostsController < ApplicationController
  #       def index
  #         flash[:foo] = 'A candy bar'
  #       end
  #     end
  #
  #     # RSpec
  #     RSpec.describe PostsController, type: :controller do
  #       describe 'GET #index' do
  #         before { get :index }
  #
  #         it { should set_flash.to('A candy bar') }
  #         it { should set_flash.to(/bar/) }
  #         it { should set_flash[:foo].to('bar') }
  #         it { should_not set_flash[:foo].to('something else') }
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PostsControllerTest < ActionController::TestCase
  #       context 'GET #index' do
  #         setup { get :show }
  #
  #         should set_flash.to('A candy bar')
  #         should set_flash.to(/bar/)
  #         should set_flash[:foo].to('bar')
  #         should_not set_flash[:foo].to('something else')
  #       end
  #     end
  #
  # ##### now
  #
  # Use `now` to change the scope of the matcher to use the "now" hash
  # instead of the usual "future" hash.
  #
  #     class PostsController < ApplicationController
  #       def show
  #         flash.now[:foo] = 'bar'
  #       end
  #     end
  #
  #     # RSpec
  #     RSpec.describe PostsController, type: :controller do
  #       describe 'GET #show' do
  #         before { get :show }
  #
  #         it { should set_flash.now }
  #         it { should set_flash.now[:foo] }
  #         it { should set_flash.now[:foo].to('bar') }
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PostsControllerTest < ActionController::TestCase
  #       context 'GET #index' do
  #         setup { get :show }
  #
  #         should set_flash.now
  #         should set_flash.now[:foo]
  #         should set_flash.now[:foo].to('bar')
  #       end
  #     end
  #
  # @return [SetFlashMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_flash_matcher.rb#150
  def set_flash; end

  # The `set_session` matcher is used to make assertions about the
  # `session` hash.
  #
  #     class PostsController < ApplicationController
  #       def index
  #         session[:foo] = 'A candy bar'
  #       end
  #
  #       def destroy
  #       end
  #     end
  #
  #     # RSpec
  #     RSpec.describe PostsController, type: :controller do
  #       describe 'GET #index' do
  #         before { get :index }
  #
  #         it { should set_session }
  #       end
  #
  #       describe 'DELETE #destroy' do
  #         before { delete :destroy }
  #
  #         it { should_not set_session }
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PostsControllerTest < ActionController::TestCase
  #       context 'GET #index' do
  #         setup { get :index }
  #
  #         should set_session
  #       end
  #
  #       context 'DELETE #destroy' do
  #         setup { delete :destroy }
  #
  #         should_not set_session
  #       end
  #     end
  #
  # #### Qualifiers
  #
  # ##### []
  #
  # Use `[]` to narrow the scope of the matcher to a particular key.
  #
  #     class PostsController < ApplicationController
  #       def index
  #         session[:foo] = 'A candy bar'
  #       end
  #     end
  #
  #     # RSpec
  #     RSpec.describe PostsController, type: :controller do
  #       describe 'GET #index' do
  #         before { get :index }
  #
  #         it { should set_session[:foo] }
  #         it { should_not set_session[:bar] }
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PostsControllerTest < ActionController::TestCase
  #       context 'GET #index' do
  #         setup { get :show }
  #
  #         should set_session[:foo]
  #         should_not set_session[:bar]
  #       end
  #     end
  #
  # ##### to
  #
  # Use `to` to assert that some key was set to a particular value, or that
  # some key matches a particular regex.
  #
  #     class PostsController < ApplicationController
  #       def index
  #         session[:foo] = 'A candy bar'
  #       end
  #     end
  #
  #     # RSpec
  #     RSpec.describe PostsController, type: :controller do
  #       describe 'GET #index' do
  #         before { get :index }
  #
  #         it { should set_session.to('A candy bar') }
  #         it { should set_session.to(/bar/) }
  #         it { should set_session[:foo].to('bar') }
  #         it { should_not set_session[:foo].to('something else') }
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PostsControllerTest < ActionController::TestCase
  #       context 'GET #index' do
  #         setup { get :show }
  #
  #         should set_session.to('A candy bar')
  #         should set_session.to(/bar/)
  #         should set_session[:foo].to('bar')
  #         should_not set_session[:foo].to('something else')
  #       end
  #     end
  #
  # @return [SetSessionMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_session_matcher.rb#117
  def set_session; end

  # The `use_after_action` matcher is used to test that an after_action
  # callback is defined within your controller.
  #
  #     class IssuesController < ApplicationController
  #       after_action :log_activity
  #     end
  #
  #     # RSpec
  #     RSpec.describe IssuesController, type: :controller do
  #       it { should use_after_action(:log_activity) }
  #       it { should_not use_after_action(:destroy_user) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class IssuesControllerTest < ActionController::TestCase
  #       should use_after_action(:log_activity)
  #       should_not use_after_action(:destroy_user)
  #     end
  #
  # @return [CallbackMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/callback_matcher.rb#108
  def use_after_action(callback); end

  # The `use_around_action` matcher is used to test that an around_action
  # callback is defined within your controller.
  #
  #     class ChangesController < ApplicationController
  #       around_action :wrap_in_transaction
  #     end
  #
  #     # RSpec
  #     RSpec.describe ChangesController, type: :controller do
  #       it { should use_around_action(:wrap_in_transaction) }
  #       it { should_not use_around_action(:save_view_context) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class ChangesControllerTest < ActionController::TestCase
  #       should use_around_action(:wrap_in_transaction)
  #       should_not use_around_action(:save_view_context)
  #     end
  #
  # @return [CallbackMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/callback_matcher.rb#162
  def use_around_action(callback); end

  # The `use_before_action` matcher is used to test that a before_action
  # callback is defined within your controller.
  #
  #     class UsersController < ApplicationController
  #       before_action :authenticate_user!
  #     end
  #
  #     # RSpec
  #     RSpec.describe UsersController, type: :controller do
  #       it { should use_before_action(:authenticate_user!) }
  #       it { should_not use_before_action(:prevent_ssl) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class UsersControllerTest < ActionController::TestCase
  #       should use_before_action(:authenticate_user!)
  #       should_not use_before_action(:prevent_ssl)
  #     end
  #
  # @return [CallbackMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/callback_matcher.rb#83
  def use_before_action(callback); end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/action_controller/callback_matcher.rb#167
class Shoulda::Matchers::ActionController::CallbackMatcher
  # @return [CallbackMatcher] a new instance of CallbackMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/callback_matcher.rb#168
  def initialize(method_name, kind, callback_type); end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/callback_matcher.rb#191
  def description; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/callback_matcher.rb#181
  def failure_message; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/callback_matcher.rb#186
  def failure_message_when_negated; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/callback_matcher.rb#174
  def matches?(controller); end

  protected

  # Returns the value of attribute callback_type.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/callback_matcher.rb#203
  def callback_type; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/callback_matcher.rb#197
  def callbacks; end

  # Returns the value of attribute controller.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/callback_matcher.rb#203
  def controller; end

  # Returns the value of attribute controller_class.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/callback_matcher.rb#203
  def controller_class; end

  # Returns the value of attribute kind.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/callback_matcher.rb#203
  def kind; end

  # Returns the value of attribute method_name.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/callback_matcher.rb#203
  def method_name; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/action_controller/filter_param_matcher.rb#29
class Shoulda::Matchers::ActionController::FilterParamMatcher
  # @return [FilterParamMatcher] a new instance of FilterParamMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/filter_param_matcher.rb#30
  def initialize(key); end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/filter_param_matcher.rb#47
  def description; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/filter_param_matcher.rb#38
  def failure_message; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/filter_param_matcher.rb#43
  def failure_message_when_negated; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/filter_param_matcher.rb#34
  def matches?(_controller); end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/filter_param_matcher.rb#64
  def filtered_keys; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/filter_param_matcher.rb#53
  def filters_key?; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/action_controller/flash_store.rb#5
class Shoulda::Matchers::ActionController::FlashStore
  # @return [FlashStore] a new instance of FlashStore
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/flash_store.rb#16
  def initialize; end

  # Returns the value of attribute controller.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/flash_store.rb#14
  def controller; end

  # Sets the attribute controller
  #
  # @param value the value to set the attribute controller to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/flash_store.rb#14
  def controller=(_arg0); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/flash_store.rb#38
  def empty?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/flash_store.rb#28
  def has_key?(key); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/flash_store.rb#32
  def has_value?(expected_value); end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/flash_store.rb#20
  def name; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/flash_store.rb#42
  def use_now!; end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/flash_store.rb#65
  def copy_discard_if_necessary(original_flash, new_flash); end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/flash_store.rb#60
  def copy_flashes(original_flash, new_flash); end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/flash_store.rb#53
  def copy_of_flash_from_controller; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/flash_store.rb#49
  def flash; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/flash_store.rb#74
  def keys_to_discard; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/flash_store.rb#70
  def set_values; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/flash_store.rb#78
  def values_to_check; end

  class << self
    # source://shoulda-matchers//lib/shoulda/matchers/action_controller/flash_store.rb#6
    def future; end

    # source://shoulda-matchers//lib/shoulda/matchers/action_controller/flash_store.rb#10
    def now; end
  end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#208
class Shoulda::Matchers::ActionController::PermitMatcher
  # @return [PermitMatcher] a new instance of PermitMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#211
  def initialize(expected_permitted_parameter_names); end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#228
  def add_params(params); end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#243
  def description; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#265
  def failure_message; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#270
  def failure_message_when_negated; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#221
  def for(action, options = T.unsafe(nil)); end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#238
  def in_context(context); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#247
  def matches?(controller); end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#233
  def on(subparameter_name); end

  # Sets the attribute stubbed_params
  #
  # @param value the value to set the attribute stubbed_params to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#209
  def stubbed_params=(_arg0); end

  protected

  # Returns the value of attribute action.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#277
  def action; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#308
  def actual_permitted_parameter_names; end

  # Returns the value of attribute context.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#277
  def context; end

  # Returns the value of attribute controller.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#277
  def controller; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#334
  def default_verb; end

  # Returns the value of attribute double_collections_by_parameter_name.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#277
  def double_collections_by_parameter_name; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#324
  def ensure_action_and_verb_present!; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#281
  def expectation; end

  # Returns the value of attribute expected_permitted_parameter_names.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#277
  def expected_permitted_parameter_names; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#304
  def format_parameter_names(parameter_names); end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#341
  def parameter_names_as_sentence; end

  # Returns the value of attribute parameters_double_registry.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#277
  def parameters_double_registry; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#294
  def reality; end

  # Returns the value of attribute request_params.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#277
  def request_params; end

  # Returns the value of attribute subparameter_name.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#277
  def subparameter_name; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#320
  def unpermitted_parameter_names; end

  # Returns the value of attribute verb.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#277
  def verb; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#434
class Shoulda::Matchers::ActionController::PermitMatcher::ActionNotDefinedError < ::StandardError
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#435
  def message; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#346
class Shoulda::Matchers::ActionController::PermitMatcher::CompositeParametersDoubleRegistry
  # @return [CompositeParametersDoubleRegistry] a new instance of CompositeParametersDoubleRegistry
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#347
  def initialize; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#363
  def permitted_parameter_names(options = T.unsafe(nil)); end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#351
  def register; end

  protected

  # Returns the value of attribute parameters_double_registries.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#371
  def parameters_double_registries; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#375
class Shoulda::Matchers::ActionController::PermitMatcher::ParametersDoubleRegistry
  # @return [ParametersDoubleRegistry] a new instance of ParametersDoubleRegistry
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#382
  def initialize(params); end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#391
  def permitted_parameter_names(args = T.unsafe(nil)); end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#387
  def register; end

  protected

  # Returns the value of attribute double_collections_by_parameter_name.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#405
  def double_collections_by_parameter_name; end

  # Returns the value of attribute params.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#405
  def params; end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#409
  def register_double_for_permit_against(params, subparameter_name); end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#420
  def register_double_for_permit_on(double_collection); end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#424
  def register_double_for_require_on(double_collection); end

  class << self
    # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#378
    def permitted_parameter_names_within(double_collection); end
  end
end

# source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#376
Shoulda::Matchers::ActionController::PermitMatcher::ParametersDoubleRegistry::TOP_LEVEL = T.let(T.unsafe(nil), Object)

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#441
class Shoulda::Matchers::ActionController::PermitMatcher::VerbNotDefinedError < ::StandardError
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/permit_matcher.rb#442
  def message; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/action_controller/redirect_to_matcher.rb#43
class Shoulda::Matchers::ActionController::RedirectToMatcher
  # @return [RedirectToMatcher] a new instance of RedirectToMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/redirect_to_matcher.rb#46
  def initialize(url_or_description, context, &block); end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/redirect_to_matcher.rb#71
  def description; end

  # Returns the value of attribute failure_message.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/redirect_to_matcher.rb#44
  def failure_message; end

  # Returns the value of attribute failure_message_when_negated.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/redirect_to_matcher.rb#44
  def failure_message_when_negated; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/redirect_to_matcher.rb#61
  def in_context(context); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/redirect_to_matcher.rb#66
  def matches?(controller); end

  private

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/redirect_to_matcher.rb#77
  def redirects_to_url?; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/redirect_to_matcher.rb#86
  def url; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/action_controller/render_template_matcher.rb#44
class Shoulda::Matchers::ActionController::RenderTemplateMatcher
  # @return [RenderTemplateMatcher] a new instance of RenderTemplateMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/render_template_matcher.rb#47
  def initialize(options, message, context); end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/render_template_matcher.rb#62
  def description; end

  # Returns the value of attribute failure_message.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/render_template_matcher.rb#45
  def failure_message; end

  # Returns the value of attribute failure_message_when_negated.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/render_template_matcher.rb#45
  def failure_message_when_negated; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/render_template_matcher.rb#66
  def in_context(context); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/render_template_matcher.rb#57
  def matches?(controller); end

  private

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/render_template_matcher.rb#73
  def renders_template?; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/action_controller/render_with_layout_matcher.rb#65
class Shoulda::Matchers::ActionController::RenderWithLayoutMatcher
  # @return [RenderWithLayoutMatcher] a new instance of RenderWithLayoutMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/render_with_layout_matcher.rb#66
  def initialize(expected_layout); end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/render_with_layout_matcher.rb#96
  def description; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/render_with_layout_matcher.rb#88
  def failure_message; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/render_with_layout_matcher.rb#92
  def failure_message_when_negated; end

  # Used to provide access to layouts recorded by
  # ActionController::TemplateAssertions in Rails 3
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/render_with_layout_matcher.rb#78
  def in_context(context); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/render_with_layout_matcher.rb#83
  def matches?(controller); end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/render_with_layout_matcher.rb#135
  def expectation; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/render_with_layout_matcher.rb#127
  def recorded_layouts; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/render_with_layout_matcher.rb#121
  def rendered_layouts; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/render_with_layout_matcher.rb#113
  def rendered_with_expected_layout?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/render_with_layout_matcher.rb#109
  def rendered_with_layout?; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/render_with_layout_matcher.rb#139
  def result; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/action_controller/rescue_from_matcher.rb#39
class Shoulda::Matchers::ActionController::RescueFromMatcher
  # @return [RescueFromMatcher] a new instance of RescueFromMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/rescue_from_matcher.rb#40
  def initialize(exception); end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/rescue_from_matcher.rb#56
  def description; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/rescue_from_matcher.rb#62
  def failure_message; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/rescue_from_matcher.rb#66
  def failure_message_when_negated; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/rescue_from_matcher.rb#51
  def matches?(controller); end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/rescue_from_matcher.rb#46
  def with(method); end

  protected

  # Returns the value of attribute controller.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/rescue_from_matcher.rb#72
  def controller; end

  # Returns the value of attribute exception.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/rescue_from_matcher.rb#72
  def exception; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/rescue_from_matcher.rb#74
  def expectation; end

  # Returns the value of attribute expected_method.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/rescue_from_matcher.rb#72
  def expected_method; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/rescue_from_matcher.rb#105
  def handler_exists?; end

  # Returns the value of attribute handlers.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/rescue_from_matcher.rb#72
  def handlers; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/rescue_from_matcher.rb#95
  def method_name_matches?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/rescue_from_matcher.rb#88
  def rescues_from_exception?; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/action_controller/respond_with_matcher.rb#92
class Shoulda::Matchers::ActionController::RespondWithMatcher
  # @return [RespondWithMatcher] a new instance of RespondWithMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/respond_with_matcher.rb#93
  def initialize(status); end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/respond_with_matcher.rb#110
  def description; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/respond_with_matcher.rb#102
  def failure_message; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/respond_with_matcher.rb#106
  def failure_message_when_negated; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/respond_with_matcher.rb#97
  def matches?(controller); end

  protected

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/respond_with_matcher.rb#116
  def correct_status_code?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/respond_with_matcher.rb#120
  def correct_status_code_range?; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/respond_with_matcher.rb#142
  def expectation; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/respond_with_matcher.rb#125
  def response_code; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/respond_with_matcher.rb#129
  def symbol_to_status_code(potential_symbol); end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/action_controller/route_matcher.rb#132
class Shoulda::Matchers::ActionController::RouteMatcher
  # @return [RouteMatcher] a new instance of RouteMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/route_matcher.rb#133
  def initialize(context, method, path, port: T.unsafe(nil)); end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/route_matcher.rb#158
  def description; end

  # Returns the value of attribute failure_message.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/route_matcher.rb#140
  def failure_message; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/route_matcher.rb#162
  def failure_message_when_negated; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/route_matcher.rb#147
  def in_context(context); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/route_matcher.rb#152
  def matches?(controller); end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/route_matcher.rb#142
  def to(*args); end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/route_matcher.rb#178
  def add_port_to_path(path, port); end

  # Returns the value of attribute context.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/route_matcher.rb#168
  def context; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/route_matcher.rb#186
  def guess_controller_if_necessary(controller); end

  # Returns the value of attribute method.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/route_matcher.rb#168
  def method; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/route_matcher.rb#170
  def normalize_path(path); end

  # Returns the value of attribute params.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/route_matcher.rb#168
  def params; end

  # Returns the value of attribute path.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/route_matcher.rb#168
  def path; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/route_matcher.rb#190
  def route_recognized?; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/action_controller/route_params.rb#5
class Shoulda::Matchers::ActionController::RouteParams
  # @return [RouteParams] a new instance of RouteParams
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/route_params.rb#8
  def initialize(args); end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/route_params.rb#12
  def normalize; end

  protected

  # Returns the value of attribute args.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/route_params.rb#22
  def args; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/route_params.rb#24
  def controller_and_action_given_as_string?; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/route_params.rb#28
  def extract_params_from_string; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/route_params.rb#38
  def normalize_values(hash); end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/route_params.rb#52
  def stringify(value); end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/route_params.rb#34
  def stringify_params; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/route_params.rb#44
  def symbolize_or_stringify(key, value); end
end

# source://shoulda-matchers//lib/shoulda/matchers/action_controller/route_params.rb#6
Shoulda::Matchers::ActionController::RouteParams::PARAMS_TO_SYMBOLIZE = T.let(T.unsafe(nil), Array)

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/action_controller/session_store.rb#5
class Shoulda::Matchers::ActionController::SessionStore
  # Returns the value of attribute controller.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/session_store.rb#6
  def controller; end

  # Sets the attribute controller
  #
  # @param value the value to set the attribute controller to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/session_store.rb#6
  def controller=(_arg0); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/session_store.rb#22
  def empty?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/session_store.rb#12
  def has_key?(key); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/session_store.rb#16
  def has_value?(expected_value); end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/session_store.rb#8
  def name; end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/session_store.rb#28
  def session; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_flash_matcher.rb#155
class Shoulda::Matchers::ActionController::SetFlashMatcher
  extend ::Forwardable

  # @return [SetFlashMatcher] a new instance of SetFlashMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_flash_matcher.rb#170
  def initialize; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_flash_matcher.rb#190
  def [](key); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def description(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def failure_message(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def failure_message_for_should(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def failure_message_for_should_not(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def failure_message_when_negated(*args, **_arg1, &block); end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_flash_matcher.rb#185
  def in_context(context); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def matches?(*args, **_arg1, &block); end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_flash_matcher.rb#175
  def now; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_flash_matcher.rb#196
  def to(expected_value = T.unsafe(nil), &block); end

  protected

  # Returns the value of attribute expected_value.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_flash_matcher.rb#204
  def expected_value; end

  # Returns the value of attribute key.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_flash_matcher.rb#204
  def key; end

  # Returns the value of attribute underlying_matcher.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_flash_matcher.rb#204
  def underlying_matcher; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_flash_matcher.rb#207
class Shoulda::Matchers::ActionController::SetFlashMatcher::QualifierOrderError < ::StandardError
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_flash_matcher.rb#208
  def message; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_session_matcher.rb#122
class Shoulda::Matchers::ActionController::SetSessionMatcher
  extend ::Forwardable

  # @return [SetSessionMatcher] a new instance of SetSessionMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_session_matcher.rb#137
  def initialize; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_session_matcher.rb#147
  def [](key); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def description(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def failure_message(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def failure_message_for_should(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def failure_message_for_should_not(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def failure_message_when_negated(*args, **_arg1, &block); end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_session_matcher.rb#142
  def in_context(context); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def matches?(*args, **_arg1, &block); end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_session_matcher.rb#152
  def to(expected_value = T.unsafe(nil), &block); end

  protected

  # Returns the value of attribute underlying_matcher.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_session_matcher.rb#159
  def underlying_matcher; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_session_or_flash_matcher.rb#5
class Shoulda::Matchers::ActionController::SetSessionOrFlashMatcher
  # @return [SetSessionOrFlashMatcher] a new instance of SetSessionOrFlashMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_session_or_flash_matcher.rb#6
  def initialize(store); end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_session_or_flash_matcher.rb#15
  def [](key); end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_session_or_flash_matcher.rb#37
  def description; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_session_or_flash_matcher.rb#46
  def failure_message; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_session_or_flash_matcher.rb#46
  def failure_message_for_should; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_session_or_flash_matcher.rb#52
  def failure_message_for_should_not; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_session_or_flash_matcher.rb#52
  def failure_message_when_negated; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_session_or_flash_matcher.rb#10
  def in_context(context); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_session_or_flash_matcher.rb#41
  def matches?(controller); end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_session_or_flash_matcher.rb#20
  def to(expected_value = T.unsafe(nil), &block); end

  protected

  # Returns the value of attribute context.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_session_or_flash_matcher.rb#61
  def context; end

  # Returns the value of attribute controller.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_session_or_flash_matcher.rb#61
  def controller; end

  # Returns the value of attribute expected_value.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_session_or_flash_matcher.rb#61
  def expected_value; end

  # Returns the value of attribute key.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_session_or_flash_matcher.rb#61
  def key; end

  # Returns the value of attribute store.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_session_or_flash_matcher.rb#61
  def store; end

  private

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_session_or_flash_matcher.rb#65
  def context_set?; end

  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_session_or_flash_matcher.rb#85
  def expectation_description; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_session_or_flash_matcher.rb#81
  def expected_value_matches?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_session_or_flash_matcher.rb#73
  def expected_value_set?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_session_or_flash_matcher.rb#77
  def key_matches?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/action_controller/set_session_or_flash_matcher.rb#69
  def key_set?; end
end

# This module provides matchers that are used to test behavior within
# ActiveModel or ActiveRecord classes.
#
# ### Testing conditional validations
#
# If your model defines a validation conditionally -- meaning that the
# validation is declared with an `:if` or `:unless` option -- how do you
# test it? You might expect the validation matchers here to have
# corresponding `if` or `unless` qualifiers, but this isn't what you use.
# Instead, before using the matcher in question, you place the record
# you're testing in a state such that the validation you're also testing
# will be run. A common way to do this is to make a new `context` and
# override the subject to populate the record accordingly. You'll also want
# to make sure to test that the validation is *not* run when the
# conditional fails.
#
# Here's an example to illustrate what we mean:
#
#     class User
#       include ActiveModel::Model
#
#       attr_accessor :role, :admin
#
#       validates_presence_of :role, if: :admin
#     end
#
#     # RSpec
#     RSpec.describe User, type: :model do
#       context "when an admin" do
#         subject { User.new(admin: true) }
#
#         it { should validate_presence_of(:role) }
#       end
#
#       context "when not an admin" do
#         subject { User.new(admin: false) }
#
#         it { should_not validate_presence_of(:role) }
#       end
#     end
#
#     # Minitest (Shoulda)
#     class UserTest < ActiveSupport::TestCase
#       context "when an admin" do
#         subject { User.new(admin: true) }
#
#         should validate_presence_of(:role)
#       end
#
#       context "when not an admin" do
#         subject { User.new(admin: false) }
#
#         should_not validate_presence_of(:role)
#       end
#     end
#
# source://shoulda-matchers//lib/shoulda/matchers/active_model/helpers.rb#3
module Shoulda::Matchers::ActiveModel
  # The `allow_mass_assignment_of` matcher tests usage of Rails 3's
  # `attr_accessible` and `attr_protected` macros, asserting that an
  # attribute in your model is contained in either the whitelist or
  # blacklist and thus can or cannot be set via mass assignment.
  #
  #     class Post
  #       include ActiveModel::Model
  #       include ActiveModel::MassAssignmentSecurity
  #       attr_accessor :title
  #
  #       attr_accessible :title
  #     end
  #
  #     class User
  #       include ActiveModel::Model
  #       include ActiveModel::MassAssignmentSecurity
  #       attr_accessor :encrypted_password
  #
  #       attr_protected :encrypted_password
  #     end
  #
  #     # RSpec
  #     RSpec.describe Post, type: :model do
  #       it { should allow_mass_assignment_of(:title) }
  #     end
  #
  #     RSpec.describe User, type: :model do
  #       it { should_not allow_mass_assignment_of(:encrypted_password) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PostTest < ActiveSupport::TestCase
  #       should allow_mass_assignment_of(:title)
  #     end
  #
  #     class UserTest < ActiveSupport::TestCase
  #       should_not allow_mass_assignment_of(:encrypted_password)
  #     end
  #
  # #### Optional qualifiers
  #
  # ##### as
  #
  # Use `as` if your mass-assignment rules apply only under a certain role
  # *(Rails >= 3.1 only)*.
  #
  #     class Post
  #       include ActiveModel::Model
  #       include ActiveModel::MassAssignmentSecurity
  #       attr_accessor :title
  #
  #       attr_accessible :title, as: :admin
  #     end
  #
  #     # RSpec
  #     RSpec.describe Post, type: :model do
  #       it { should allow_mass_assignment_of(:title).as(:admin) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PostTest < ActiveSupport::TestCase
  #       should allow_mass_assignment_of(:title).as(:admin)
  #     end
  #
  # @return [AllowMassAssignmentOfMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_mass_assignment_of_matcher.rb#70
  def allow_mass_assignment_of(value); end

  # The `allow_value` matcher (or its alias, `allow_values`) is used to
  # ensure that an attribute is valid or invalid if set to one or more
  # values.
  #
  # Take this model for example:
  #
  #     class UserProfile
  #       include ActiveModel::Model
  #       attr_accessor :website_url
  #
  #       validates_format_of :website_url, with: URI.regexp
  #     end
  #
  # You can use `allow_value` to test one value at a time:
  #
  #     # RSpec
  #     RSpec.describe UserProfile, type: :model do
  #       it { should allow_value('https://foo.com').for(:website_url) }
  #       it { should allow_value('https://bar.com').for(:website_url) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class UserProfileTest < ActiveSupport::TestCase
  #       should allow_value('https://foo.com').for(:website_url)
  #       should allow_value('https://bar.com').for(:website_url)
  #     end
  #
  # You can also test multiple values in one go, if you like. In the
  # positive sense, this makes an assertion that none of the values cause the
  # record to be invalid. In the negative sense, this makes an assertion
  # that none of the values cause the record to be valid:
  #
  #     # RSpec
  #     RSpec.describe UserProfile, type: :model do
  #       it do
  #         should allow_values('https://foo.com', 'https://bar.com').
  #           for(:website_url)
  #       end
  #
  #       it do
  #         should_not allow_values('foo', 'buz').
  #           for(:website_url)
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class UserProfileTest < ActiveSupport::TestCase
  #       should allow_values('https://foo.com', 'https://bar.com/baz').
  #         for(:website_url)
  #
  #       should_not allow_values('foo', 'buz').
  #         for(:website_url)
  #     end
  #
  # #### Caveats
  #
  # When using `allow_value` or any matchers that depend on it, you may
  # encounter an AttributeChangedValueError. This exception is raised if the
  # matcher, in attempting to set a value on the attribute, detects that
  # the value set is different from the value that the attribute returns
  # upon reading it back.
  #
  # This usually happens if the writer method (`foo=`, `bar=`, etc.) for
  # that attribute has custom logic to ignore certain incoming values or
  # change them in any way. Here are three examples we've seen:
  #
  # * You're attempting to assert that an attribute should not allow nil,
  #   yet the attribute's writer method contains a conditional to do nothing
  #   if the attribute is set to nil:
  #
  #         class Foo
  #           include ActiveModel::Model
  #
  #           attr_reader :bar
  #
  #           def bar=(value)
  #             return if value.nil?
  #             @bar = value
  #           end
  #         end
  #
  #         RSpec.describe Foo, type: :model do
  #           it do
  #             foo = Foo.new
  #             foo.bar = "baz"
  #             # This will raise an AttributeChangedValueError since `foo.bar` is now "123"
  #             expect(foo).not_to allow_value(nil).for(:bar)
  #           end
  #         end
  #
  # * You're attempting to assert that a numeric attribute should not allow
  #   a string that contains non-numeric characters, yet the writer method
  #   for that attribute strips out non-numeric characters:
  #
  #         class Foo
  #           include ActiveModel::Model
  #
  #           attr_reader :bar
  #
  #           def bar=(value)
  #             @bar = value.gsub(/\D+/, '')
  #           end
  #         end
  #
  #         RSpec.describe Foo, type: :model do
  #           it do
  #             foo = Foo.new
  #             # This will raise an AttributeChangedValueError since `foo.bar` is now "123"
  #             expect(foo).not_to allow_value("abc123").for(:bar)
  #           end
  #         end
  #
  # * You're passing a value to `allow_value` that the model typecasts into
  #   another value:
  #
  #         RSpec.describe Foo, type: :model do
  #           # Assume that `attr` is a string
  #           # This will raise an AttributeChangedValueError since `attr` typecasts `[]` to `"[]"`
  #           it { should_not allow_value([]).for(:attr) }
  #         end
  #
  # Fortunately, if you understand why this is happening, and wish to get
  # around this exception, it is possible to do so. You can use the
  # `ignoring_interference_by_writer` qualifier like so:
  #
  #         it do
  #           should_not allow_value([]).
  #             for(:attr).
  #             ignoring_interference_by_writer
  #         end
  #
  # Please note, however, that this qualifier won't magically cause your
  # test to pass. It may just so happen that the final value that ends up
  # being set causes the model to fail validation. In that case, you'll have
  # to figure out what to do. You may need to write your own test, or
  # perhaps even remove your test altogether.
  #
  # #### Qualifiers
  #
  # ##### on
  #
  # Use `on` if your validation applies only under a certain context.
  #
  #     class UserProfile
  #       include ActiveModel::Model
  #       attr_accessor :birthday_as_string
  #
  #       validates_format_of :birthday_as_string,
  #         with: /^(\d+)-(\d+)-(\d+)$/,
  #         on: :create
  #     end
  #
  #     # RSpec
  #     RSpec.describe UserProfile, type: :model do
  #       it do
  #         should allow_value('2013-01-01').
  #           for(:birthday_as_string).
  #           on(:create)
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class UserProfileTest < ActiveSupport::TestCase
  #       should allow_value('2013-01-01').
  #         for(:birthday_as_string).
  #         on(:create)
  #     end
  #
  # ##### with_message
  #
  # Use `with_message` if you are using a custom validation message.
  #
  #     class UserProfile
  #       include ActiveModel::Model
  #       attr_accessor :state
  #
  #       validates_format_of :state,
  #         with: /^(open|closed)$/,
  #         message: 'State must be open or closed'
  #     end
  #
  #     # RSpec
  #     RSpec.describe UserProfile, type: :model do
  #       it do
  #         should allow_value('open', 'closed').
  #           for(:state).
  #           with_message('State must be open or closed')
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class UserProfileTest < ActiveSupport::TestCase
  #       should allow_value('open', 'closed').
  #         for(:state).
  #         with_message('State must be open or closed')
  #     end
  #
  # Use `with_message` with a regexp to perform a partial match:
  #
  #     class UserProfile
  #       include ActiveModel::Model
  #       attr_accessor :state
  #
  #       validates_format_of :state,
  #         with: /^(open|closed)$/,
  #         message: 'State must be open or closed'
  #     end
  #
  #     # RSpec
  #     RSpec.describe UserProfile, type: :model do
  #       it do
  #         should allow_value('open', 'closed').
  #           for(:state).
  #           with_message(/open or closed/)
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class UserProfileTest < ActiveSupport::TestCase
  #       should allow_value('open', 'closed').
  #         for(:state).
  #         with_message(/open or closed/)
  #     end
  #
  # Use `with_message` with the `:against` option if the attribute the
  # validation message is stored under is different from the attribute
  # being validated:
  #
  #     class UserProfile
  #       include ActiveModel::Model
  #       attr_accessor :sports_team
  #
  #       validate :sports_team_must_be_valid
  #
  #       private
  #
  #       def sports_team_must_be_valid
  #         if sports_team !~ /^(Broncos|Titans)$/i
  #           self.errors.add :chosen_sports_team,
  #             'Must be either a Broncos fan or a Titans fan'
  #         end
  #       end
  #     end
  #
  #     # RSpec
  #     RSpec.describe UserProfile, type: :model do
  #       it do
  #         should allow_value('Broncos', 'Titans').
  #           for(:sports_team).
  #           with_message('Must be either a Broncos or Titans fan',
  #             against: :chosen_sports_team
  #           )
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class UserProfileTest < ActiveSupport::TestCase
  #       should allow_value('Broncos', 'Titans').
  #         for(:sports_team).
  #         with_message('Must be either a Broncos or Titans fan',
  #           against: :chosen_sports_team
  #         )
  #     end
  #
  # ##### ignoring_interference_by_writer
  #
  # Use `ignoring_interference_by_writer` to bypass an
  # AttributeChangedValueError that you have encountered. Please read the
  # Caveats section above for more information.
  #
  #     class Address < ActiveRecord::Base
  #       # Address has a zip_code field which is a string
  #     end
  #
  #     # RSpec
  #     RSpec.describe Address, type: :model do
  #       it do
  #         should_not allow_value([]).
  #           for(:zip_code).
  #           ignoring_interference_by_writer
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class AddressTest < ActiveSupport::TestCase
  #       should_not allow_value([]).
  #         for(:zip_code).
  #         ignoring_interference_by_writer
  #     end
  #
  # @return [AllowValueMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#296
  def allow_value(*values); end

  # The `allow_value` matcher (or its alias, `allow_values`) is used to
  # ensure that an attribute is valid or invalid if set to one or more
  # values.
  #
  # Take this model for example:
  #
  #     class UserProfile
  #       include ActiveModel::Model
  #       attr_accessor :website_url
  #
  #       validates_format_of :website_url, with: URI.regexp
  #     end
  #
  # You can use `allow_value` to test one value at a time:
  #
  #     # RSpec
  #     RSpec.describe UserProfile, type: :model do
  #       it { should allow_value('https://foo.com').for(:website_url) }
  #       it { should allow_value('https://bar.com').for(:website_url) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class UserProfileTest < ActiveSupport::TestCase
  #       should allow_value('https://foo.com').for(:website_url)
  #       should allow_value('https://bar.com').for(:website_url)
  #     end
  #
  # You can also test multiple values in one go, if you like. In the
  # positive sense, this makes an assertion that none of the values cause the
  # record to be invalid. In the negative sense, this makes an assertion
  # that none of the values cause the record to be valid:
  #
  #     # RSpec
  #     RSpec.describe UserProfile, type: :model do
  #       it do
  #         should allow_values('https://foo.com', 'https://bar.com').
  #           for(:website_url)
  #       end
  #
  #       it do
  #         should_not allow_values('foo', 'buz').
  #           for(:website_url)
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class UserProfileTest < ActiveSupport::TestCase
  #       should allow_values('https://foo.com', 'https://bar.com/baz').
  #         for(:website_url)
  #
  #       should_not allow_values('foo', 'buz').
  #         for(:website_url)
  #     end
  #
  # #### Caveats
  #
  # When using `allow_value` or any matchers that depend on it, you may
  # encounter an AttributeChangedValueError. This exception is raised if the
  # matcher, in attempting to set a value on the attribute, detects that
  # the value set is different from the value that the attribute returns
  # upon reading it back.
  #
  # This usually happens if the writer method (`foo=`, `bar=`, etc.) for
  # that attribute has custom logic to ignore certain incoming values or
  # change them in any way. Here are three examples we've seen:
  #
  # * You're attempting to assert that an attribute should not allow nil,
  #   yet the attribute's writer method contains a conditional to do nothing
  #   if the attribute is set to nil:
  #
  #         class Foo
  #           include ActiveModel::Model
  #
  #           attr_reader :bar
  #
  #           def bar=(value)
  #             return if value.nil?
  #             @bar = value
  #           end
  #         end
  #
  #         RSpec.describe Foo, type: :model do
  #           it do
  #             foo = Foo.new
  #             foo.bar = "baz"
  #             # This will raise an AttributeChangedValueError since `foo.bar` is now "123"
  #             expect(foo).not_to allow_value(nil).for(:bar)
  #           end
  #         end
  #
  # * You're attempting to assert that a numeric attribute should not allow
  #   a string that contains non-numeric characters, yet the writer method
  #   for that attribute strips out non-numeric characters:
  #
  #         class Foo
  #           include ActiveModel::Model
  #
  #           attr_reader :bar
  #
  #           def bar=(value)
  #             @bar = value.gsub(/\D+/, '')
  #           end
  #         end
  #
  #         RSpec.describe Foo, type: :model do
  #           it do
  #             foo = Foo.new
  #             # This will raise an AttributeChangedValueError since `foo.bar` is now "123"
  #             expect(foo).not_to allow_value("abc123").for(:bar)
  #           end
  #         end
  #
  # * You're passing a value to `allow_value` that the model typecasts into
  #   another value:
  #
  #         RSpec.describe Foo, type: :model do
  #           # Assume that `attr` is a string
  #           # This will raise an AttributeChangedValueError since `attr` typecasts `[]` to `"[]"`
  #           it { should_not allow_value([]).for(:attr) }
  #         end
  #
  # Fortunately, if you understand why this is happening, and wish to get
  # around this exception, it is possible to do so. You can use the
  # `ignoring_interference_by_writer` qualifier like so:
  #
  #         it do
  #           should_not allow_value([]).
  #             for(:attr).
  #             ignoring_interference_by_writer
  #         end
  #
  # Please note, however, that this qualifier won't magically cause your
  # test to pass. It may just so happen that the final value that ends up
  # being set causes the model to fail validation. In that case, you'll have
  # to figure out what to do. You may need to write your own test, or
  # perhaps even remove your test altogether.
  #
  # #### Qualifiers
  #
  # ##### on
  #
  # Use `on` if your validation applies only under a certain context.
  #
  #     class UserProfile
  #       include ActiveModel::Model
  #       attr_accessor :birthday_as_string
  #
  #       validates_format_of :birthday_as_string,
  #         with: /^(\d+)-(\d+)-(\d+)$/,
  #         on: :create
  #     end
  #
  #     # RSpec
  #     RSpec.describe UserProfile, type: :model do
  #       it do
  #         should allow_value('2013-01-01').
  #           for(:birthday_as_string).
  #           on(:create)
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class UserProfileTest < ActiveSupport::TestCase
  #       should allow_value('2013-01-01').
  #         for(:birthday_as_string).
  #         on(:create)
  #     end
  #
  # ##### with_message
  #
  # Use `with_message` if you are using a custom validation message.
  #
  #     class UserProfile
  #       include ActiveModel::Model
  #       attr_accessor :state
  #
  #       validates_format_of :state,
  #         with: /^(open|closed)$/,
  #         message: 'State must be open or closed'
  #     end
  #
  #     # RSpec
  #     RSpec.describe UserProfile, type: :model do
  #       it do
  #         should allow_value('open', 'closed').
  #           for(:state).
  #           with_message('State must be open or closed')
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class UserProfileTest < ActiveSupport::TestCase
  #       should allow_value('open', 'closed').
  #         for(:state).
  #         with_message('State must be open or closed')
  #     end
  #
  # Use `with_message` with a regexp to perform a partial match:
  #
  #     class UserProfile
  #       include ActiveModel::Model
  #       attr_accessor :state
  #
  #       validates_format_of :state,
  #         with: /^(open|closed)$/,
  #         message: 'State must be open or closed'
  #     end
  #
  #     # RSpec
  #     RSpec.describe UserProfile, type: :model do
  #       it do
  #         should allow_value('open', 'closed').
  #           for(:state).
  #           with_message(/open or closed/)
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class UserProfileTest < ActiveSupport::TestCase
  #       should allow_value('open', 'closed').
  #         for(:state).
  #         with_message(/open or closed/)
  #     end
  #
  # Use `with_message` with the `:against` option if the attribute the
  # validation message is stored under is different from the attribute
  # being validated:
  #
  #     class UserProfile
  #       include ActiveModel::Model
  #       attr_accessor :sports_team
  #
  #       validate :sports_team_must_be_valid
  #
  #       private
  #
  #       def sports_team_must_be_valid
  #         if sports_team !~ /^(Broncos|Titans)$/i
  #           self.errors.add :chosen_sports_team,
  #             'Must be either a Broncos fan or a Titans fan'
  #         end
  #       end
  #     end
  #
  #     # RSpec
  #     RSpec.describe UserProfile, type: :model do
  #       it do
  #         should allow_value('Broncos', 'Titans').
  #           for(:sports_team).
  #           with_message('Must be either a Broncos or Titans fan',
  #             against: :chosen_sports_team
  #           )
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class UserProfileTest < ActiveSupport::TestCase
  #       should allow_value('Broncos', 'Titans').
  #         for(:sports_team).
  #         with_message('Must be either a Broncos or Titans fan',
  #           against: :chosen_sports_team
  #         )
  #     end
  #
  # ##### ignoring_interference_by_writer
  #
  # Use `ignoring_interference_by_writer` to bypass an
  # AttributeChangedValueError that you have encountered. Please read the
  # Caveats section above for more information.
  #
  #     class Address < ActiveRecord::Base
  #       # Address has a zip_code field which is a string
  #     end
  #
  #     # RSpec
  #     RSpec.describe Address, type: :model do
  #       it do
  #         should_not allow_value([]).
  #           for(:zip_code).
  #           ignoring_interference_by_writer
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class AddressTest < ActiveSupport::TestCase
  #       should_not allow_value([]).
  #         for(:zip_code).
  #         ignoring_interference_by_writer
  #     end
  #
  # @private
  # @return [AllowValueMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#296
  def allow_values(*values); end

  # The `have_secure_password` matcher tests usage of the
  # `has_secure_password` macro.
  #
  # #### Example
  #
  #     class User
  #       include ActiveModel::Model
  #       include ActiveModel::SecurePassword
  #       attr_accessor :password
  #       attr_accessor :reset_password
  #
  #       has_secure_password
  #       has_secure_password :reset_password
  #     end
  #
  #     # RSpec
  #     RSpec.describe User, type: :model do
  #       it { should have_secure_password }
  #       it { should have_secure_password(:reset_password) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class UserTest < ActiveSupport::TestCase
  #       should have_secure_password
  #       should have_secure_password(:reset_password)
  #     end
  #
  # @return [HaveSecurePasswordMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/have_secure_password_matcher.rb#33
  def have_secure_password(attr = T.unsafe(nil)); end

  # The `validate_absence_of` matcher tests the usage of the
  # `validates_absence_of` validation.
  #
  #     class PowerHungryCountry
  #       include ActiveModel::Model
  #       attr_accessor :nuclear_weapons
  #
  #       validates_absence_of :nuclear_weapons
  #     end
  #
  #     # RSpec
  #     RSpec.describe PowerHungryCountry, type: :model do
  #       it { should validate_absence_of(:nuclear_weapons) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PowerHungryCountryTest < ActiveSupport::TestCase
  #       should validate_absence_of(:nuclear_weapons)
  #     end
  #
  # #### Qualifiers
  #
  # ##### on
  #
  # Use `on` if your validation applies only under a certain context.
  #
  #     class PowerHungryCountry
  #       include ActiveModel::Model
  #       attr_accessor :nuclear_weapons
  #
  #       validates_absence_of :nuclear_weapons, on: :create
  #     end
  #
  #     # RSpec
  #     RSpec.describe PowerHungryCountry, type: :model do
  #       it { should validate_absence_of(:nuclear_weapons).on(:create) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PowerHungryCountryTest < ActiveSupport::TestCase
  #       should validate_absence_of(:nuclear_weapons).on(:create)
  #     end
  #
  # ##### with_message
  #
  # Use `with_message` if you are using a custom validation message.
  #
  #     class PowerHungryCountry
  #       include ActiveModel::Model
  #       attr_accessor :nuclear_weapons
  #
  #       validates_absence_of :nuclear_weapons,
  #         message: "there shall be peace on Earth"
  #     end
  #
  #     # RSpec
  #     RSpec.describe PowerHungryCountry, type: :model do
  #       it do
  #         should validate_absence_of(:nuclear_weapons).
  #           with_message("there shall be peace on Earth")
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PowerHungryCountryTest < ActiveSupport::TestCase
  #       should validate_absence_of(:nuclear_weapons).
  #         with_message("there shall be peace on Earth")
  #     end
  #
  # @return [ValidateAbsenceOfMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_absence_of_matcher.rb#75
  def validate_absence_of(attr); end

  # The `validate_acceptance_of` matcher tests usage of the
  # `validates_acceptance_of` validation.
  #
  #     class Registration
  #       include ActiveModel::Model
  #       attr_accessor :eula
  #
  #       validates_acceptance_of :eula
  #     end
  #
  #     # RSpec
  #     RSpec.describe Registration, type: :model do
  #       it { should validate_acceptance_of(:eula) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class RegistrationTest < ActiveSupport::TestCase
  #       should validate_acceptance_of(:eula)
  #     end
  #
  # #### Qualifiers
  #
  # ##### on
  #
  # Use `on` if your validation applies only under a certain context.
  #
  #     class Registration
  #       include ActiveModel::Model
  #       attr_accessor :terms_of_service
  #
  #       validates_acceptance_of :terms_of_service, on: :create
  #     end
  #
  #     # RSpec
  #     RSpec.describe Registration, type: :model do
  #       it do
  #         should validate_acceptance_of(:terms_of_service).
  #           on(:create)
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class RegistrationTest < ActiveSupport::TestCase
  #       should validate_acceptance_of(:terms_of_service).on(:create)
  #     end
  #
  # ##### with_message
  #
  # Use `with_message` if you are using a custom validation message.
  #
  #     class Registration
  #       include ActiveModel::Model
  #       attr_accessor :terms_of_service
  #
  #       validates_acceptance_of :terms_of_service,
  #         message: 'You must accept the terms of service'
  #     end
  #
  #     # RSpec
  #     RSpec.describe Registration, type: :model do
  #       it do
  #         should validate_acceptance_of(:terms_of_service).
  #           with_message('You must accept the terms of service')
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class RegistrationTest < ActiveSupport::TestCase
  #       should validate_acceptance_of(:terms_of_service).
  #         with_message('You must accept the terms of service')
  #     end
  #
  # @return [ValidateAcceptanceOfMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_acceptance_of_matcher.rb#78
  def validate_acceptance_of(attr); end

  # The `validate_confirmation_of` matcher tests usage of the
  # `validates_confirmation_of` validation.
  #
  #     class User
  #       include ActiveModel::Model
  #       attr_accessor :email
  #
  #       validates_confirmation_of :email
  #     end
  #
  #     # RSpec
  #     RSpec.describe User, type: :model do
  #       it { should validate_confirmation_of(:email) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class UserTest < ActiveSupport::TestCase
  #       should validate_confirmation_of(:email)
  #     end
  #
  # #### Qualifiers
  #
  # ##### on
  #
  # Use `on` if your validation applies only under a certain context.
  #
  #     class User
  #       include ActiveModel::Model
  #       attr_accessor :password
  #
  #       validates_confirmation_of :password, on: :create
  #     end
  #
  #     # RSpec
  #     RSpec.describe User, type: :model do
  #       it { should validate_confirmation_of(:password).on(:create) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class UserTest < ActiveSupport::TestCase
  #       should validate_confirmation_of(:password).on(:create)
  #     end
  #
  # ##### with_message
  #
  # Use `with_message` if you are using a custom validation message.
  #
  #     class User
  #       include ActiveModel::Model
  #       attr_accessor :password
  #
  #       validates_confirmation_of :password,
  #         message: 'Please re-enter your password'
  #     end
  #
  #     # RSpec
  #     RSpec.describe User, type: :model do
  #       it do
  #         should validate_confirmation_of(:password).
  #           with_message('Please re-enter your password')
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class UserTest < ActiveSupport::TestCase
  #       should validate_confirmation_of(:password).
  #         with_message('Please re-enter your password')
  #     end
  #
  # @return [ValidateConfirmationOfMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_confirmation_of_matcher.rb#75
  def validate_confirmation_of(attr); end

  # The `validate_exclusion_of` matcher tests usage of the
  # `validates_exclusion_of` validation, asserting that an attribute cannot
  # take a blacklist of values, and inversely, can take values outside of
  # this list.
  #
  # If your blacklist is an array of values, use `in_array`:
  #
  #     class Game
  #       include ActiveModel::Model
  #       attr_accessor :supported_os
  #
  #       validates_exclusion_of :supported_os, in: ['Mac', 'Linux']
  #     end
  #
  #     # RSpec
  #     RSpec.describe Game, type: :model do
  #       it do
  #         should validate_exclusion_of(:supported_os).
  #           in_array(['Mac', 'Linux'])
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class GameTest < ActiveSupport::TestCase
  #       should validate_exclusion_of(:supported_os).
  #         in_array(['Mac', 'Linux'])
  #     end
  #
  # If your blacklist is a range of values, use `in_range`:
  #
  #     class Game
  #       include ActiveModel::Model
  #       attr_accessor :supported_os
  #
  #       validates_exclusion_of :supported_os, in: 5..8
  #     end
  #
  #     # RSpec
  #     RSpec.describe Game, type: :model do
  #       it do
  #         should validate_exclusion_of(:floors_with_enemies).
  #           in_range(5..8)
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class GameTest < ActiveSupport::TestCase
  #       should validate_exclusion_of(:floors_with_enemies).
  #         in_range(5..8)
  #     end
  #
  # #### Qualifiers
  #
  # ##### on
  #
  # Use `on` if your validation applies only under a certain context.
  #
  #     class Game
  #       include ActiveModel::Model
  #       attr_accessor :weapon
  #
  #       validates_exclusion_of :weapon,
  #         in: ['pistol', 'paintball gun', 'stick'],
  #         on: :create
  #     end
  #
  #     # RSpec
  #     RSpec.describe Game, type: :model do
  #       it do
  #         should validate_exclusion_of(:weapon).
  #           in_array(['pistol', 'paintball gun', 'stick']).
  #           on(:create)
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class GameTest < ActiveSupport::TestCase
  #       should validate_exclusion_of(:weapon).
  #         in_array(['pistol', 'paintball gun', 'stick']).
  #         on(:create)
  #     end
  #
  # ##### with_message
  #
  # Use `with_message` if you are using a custom validation message.
  #
  #     class Game
  #       include ActiveModel::Model
  #       attr_accessor :weapon
  #
  #       validates_exclusion_of :weapon,
  #         in: ['pistol', 'paintball gun', 'stick'],
  #         message: 'You chose a puny weapon'
  #     end
  #
  #     # RSpec
  #     RSpec.describe Game, type: :model do
  #       it do
  #         should validate_exclusion_of(:weapon).
  #           in_array(['pistol', 'paintball gun', 'stick']).
  #           with_message('You chose a puny weapon')
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class GameTest < ActiveSupport::TestCase
  #       should validate_exclusion_of(:weapon).
  #         in_array(['pistol', 'paintball gun', 'stick']).
  #         with_message('You chose a puny weapon')
  #     end
  #
  # @return [ValidateExclusionOfMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_exclusion_of_matcher.rb#117
  def validate_exclusion_of(attr); end

  # The `validate_inclusion_of` matcher tests usage of the
  # `validates_inclusion_of` validation, asserting that an attribute can
  # take a whitelist of values and cannot take values outside of this list.
  #
  # If your whitelist is an array of values, use `in_array`:
  #
  #     class Issue
  #       include ActiveModel::Model
  #       attr_accessor :state
  #
  #       validates_inclusion_of :state,
  #         in: ['open', 'resolved', 'unresolved']
  #     end
  #
  #     # RSpec
  #     RSpec.describe Issue, type: :model do
  #       it do
  #         should validate_inclusion_of(:state).
  #           in_array(['open', 'resolved', 'unresolved'])
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class IssueTest < ActiveSupport::TestCase
  #       should validate_inclusion_of(:state).
  #         in_array(['open', 'resolved', 'unresolved'])
  #     end
  #
  # If your whitelist is a range of values, use `in_range`:
  #
  #     class Issue
  #       include ActiveModel::Model
  #       attr_accessor :priority
  #
  #       validates_inclusion_of :priority, in: 1..5
  #     end
  #
  #     # RSpec
  #     RSpec.describe Issue, type: :model do
  #       it { should validate_inclusion_of(:state).in_range(1..5) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class IssueTest < ActiveSupport::TestCase
  #       should validate_inclusion_of(:state).in_range(1..5)
  #     end
  #
  # #### Caveats
  #
  # We discourage using `validate_inclusion_of` with boolean columns. In
  # fact, there is never a case where a boolean column will be anything but
  # true, false, or nil, as ActiveRecord will type-cast an incoming value to
  # one of these three values. That means there isn't any way we can refute
  # this logic in a test. Hence, this will produce a warning:
  #
  #     it do
  #       should validate_inclusion_of(:imported).
  #         in_array([true, false])
  #     end
  #
  # The only case where `validate_inclusion_of` *could* be appropriate is
  # for ensuring that a boolean column accepts nil, but we recommend
  # using `allow_value` instead, like this:
  #
  #     it { should allow_value(nil).for(:imported) }
  #
  # #### Qualifiers
  #
  # Use `on` if your validation applies only under a certain context.
  #
  #     class Issue
  #       include ActiveModel::Model
  #       attr_accessor :severity
  #
  #       validates_inclusion_of :severity,
  #         in: %w(low medium high),
  #         on: :create
  #     end
  #
  #     # RSpec
  #     RSpec.describe Issue, type: :model do
  #       it do
  #         should validate_inclusion_of(:severity).
  #           in_array(%w(low medium high)).
  #           on(:create)
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class IssueTest < ActiveSupport::TestCase
  #       should validate_inclusion_of(:severity).
  #         in_array(%w(low medium high)).
  #         on(:create)
  #     end
  #
  # ##### with_message
  #
  # Use `with_message` if you are using a custom validation message.
  #
  #     class Issue
  #       include ActiveModel::Model
  #       attr_accessor :severity
  #
  #       validates_inclusion_of :severity,
  #         in: %w(low medium high),
  #         message: 'Severity must be low, medium, or high'
  #     end
  #
  #     # RSpec
  #     RSpec.describe Issue, type: :model do
  #       it do
  #         should validate_inclusion_of(:severity).
  #           in_array(%w(low medium high)).
  #           with_message('Severity must be low, medium, or high')
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class IssueTest < ActiveSupport::TestCase
  #       should validate_inclusion_of(:severity).
  #         in_array(%w(low medium high)).
  #         with_message('Severity must be low, medium, or high')
  #     end
  #
  # ##### with_low_message
  #
  # Use `with_low_message` if you have a custom validation message for when
  # a given value is too low.
  #
  #     class Person
  #       include ActiveModel::Model
  #       attr_accessor :age
  #
  #       validate :age_must_be_valid
  #
  #       private
  #
  #       def age_must_be_valid
  #         if age < 65
  #           self.errors.add :age, 'You do not receive any benefits'
  #         end
  #       end
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it do
  #         should validate_inclusion_of(:age).
  #           in_range(0..65).
  #           with_low_message('You do not receive any benefits')
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should validate_inclusion_of(:age).
  #         in_range(0..65).
  #         with_low_message('You do not receive any benefits')
  #     end
  #
  # ##### with_high_message
  #
  # Use `with_high_message` if you have a custom validation message for
  # when a given value is too high.
  #
  #     class Person
  #       include ActiveModel::Model
  #       attr_accessor :age
  #
  #       validate :age_must_be_valid
  #
  #       private
  #
  #       def age_must_be_valid
  #         if age > 21
  #           self.errors.add :age, "You're too old for this stuff"
  #         end
  #       end
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it do
  #         should validate_inclusion_of(:age).
  #           in_range(0..21).
  #           with_high_message("You're too old for this stuff")
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should validate_inclusion_of(:age).
  #         in_range(0..21).
  #         with_high_message("You're too old for this stuff")
  #     end
  #
  # ##### allow_nil
  #
  # Use `allow_nil` to assert that the attribute allows nil.
  #
  #     class Issue
  #       include ActiveModel::Model
  #       attr_accessor :state
  #
  #       validates_presence_of :state
  #       validates_inclusion_of :state,
  #         in: ['open', 'resolved', 'unresolved'],
  #         allow_nil: true
  #     end
  #
  #     # RSpec
  #     RSpec.describe Issue, type: :model do
  #       it do
  #         should validate_inclusion_of(:state).
  #           in_array(['open', 'resolved', 'unresolved']).
  #           allow_nil
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class IssueTest < ActiveSupport::TestCase
  #       should validate_inclusion_of(:state).
  #         in_array(['open', 'resolved', 'unresolved']).
  #         allow_nil
  #     end
  #
  # ##### allow_blank
  #
  # Use `allow_blank` to assert that the attribute allows blank.
  #
  #     class Issue
  #       include ActiveModel::Model
  #       attr_accessor :state
  #
  #       validates_presence_of :state
  #       validates_inclusion_of :state,
  #         in: ['open', 'resolved', 'unresolved'],
  #         allow_blank: true
  #     end
  #
  #     # RSpec
  #     RSpec.describe Issue, type: :model do
  #       it do
  #         should validate_inclusion_of(:state).
  #           in_array(['open', 'resolved', 'unresolved']).
  #           allow_blank
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class IssueTest < ActiveSupport::TestCase
  #       should validate_inclusion_of(:state).
  #         in_array(['open', 'resolved', 'unresolved']).
  #         allow_blank
  #     end
  #
  # @return [ValidateInclusionOfMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#265
  def validate_inclusion_of(attr); end

  # The `validate_length_of` matcher tests usage of the
  # `validates_length_of` matcher. Note that this matcher is intended to be
  # used against string columns and not integer columns.
  #
  # #### Qualifiers
  #
  # Use `on` if your validation applies only under a certain context.
  #
  #     class User
  #       include ActiveModel::Model
  #       attr_accessor :password
  #
  #       validates_length_of :password, minimum: 10, on: :create
  #     end
  #
  #     # RSpec
  #     RSpec.describe User, type: :model do
  #       it do
  #         should validate_length_of(:password).
  #           is_at_least(10).
  #           on(:create)
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class UserTest < ActiveSupport::TestCase
  #       should validate_length_of(:password).
  #         is_at_least(10).
  #         on(:create)
  #     end
  #
  # ##### is_at_least
  #
  # Use `is_at_least` to test usage of the `:minimum` option. This asserts
  # that the attribute can take a string which is equal to or longer than
  # the given length and cannot take a string which is shorter.
  #
  #     class User
  #       include ActiveModel::Model
  #       attr_accessor :bio
  #
  #       validates_length_of :bio, minimum: 15
  #     end
  #
  #     # RSpec
  #
  #     RSpec.describe User, type: :model do
  #       it { should validate_length_of(:bio).is_at_least(15) }
  #     end
  #
  #     # Minitest (Shoulda)
  #
  #     class UserTest < ActiveSupport::TestCase
  #       should validate_length_of(:bio).is_at_least(15)
  #     end
  #
  # ##### is_at_most
  #
  # Use `is_at_most` to test usage of the `:maximum` option. This asserts
  # that the attribute can take a string which is equal to or shorter than
  # the given length and cannot take a string which is longer.
  #
  #     class User
  #       include ActiveModel::Model
  #       attr_accessor :status_update
  #
  #       validates_length_of :status_update, maximum: 140
  #     end
  #
  #     # RSpec
  #     RSpec.describe User, type: :model do
  #       it { should validate_length_of(:status_update).is_at_most(140) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class UserTest < ActiveSupport::TestCase
  #       should validate_length_of(:status_update).is_at_most(140)
  #     end
  #
  # ##### is_equal_to
  #
  # Use `is_equal_to` to test usage of the `:is` option. This asserts that
  # the attribute can take a string which is exactly equal to the given
  # length and cannot take a string which is shorter or longer.
  #
  #     class User
  #       include ActiveModel::Model
  #       attr_accessor :favorite_superhero
  #
  #       validates_length_of :favorite_superhero, is: 6
  #     end
  #
  #     # RSpec
  #     RSpec.describe User, type: :model do
  #       it { should validate_length_of(:favorite_superhero).is_equal_to(6) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class UserTest < ActiveSupport::TestCase
  #       should validate_length_of(:favorite_superhero).is_equal_to(6)
  #     end
  #
  # ##### is_at_least + is_at_most
  #
  # Use `is_at_least` and `is_at_most` together to test usage of the `:in`
  # option.
  #
  #     class User
  #       include ActiveModel::Model
  #       attr_accessor :password
  #
  #       validates_length_of :password, in: 5..30
  #     end
  #
  #     # RSpec
  #     RSpec.describe User, type: :model do
  #       it do
  #         should validate_length_of(:password).
  #           is_at_least(5).is_at_most(30)
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class UserTest < ActiveSupport::TestCase
  #       should validate_length_of(:password).
  #         is_at_least(5).is_at_most(30)
  #     end
  #
  # ##### with_message
  #
  # Use `with_message` if you are using a custom validation message.
  #
  #     class User
  #       include ActiveModel::Model
  #       attr_accessor :password
  #
  #       validates_length_of :password,
  #         minimum: 10,
  #         message: "Password isn't long enough"
  #     end
  #
  #     # RSpec
  #     RSpec.describe User, type: :model do
  #       it do
  #         should validate_length_of(:password).
  #           is_at_least(10).
  #           with_message("Password isn't long enough")
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class UserTest < ActiveSupport::TestCase
  #       should validate_length_of(:password).
  #         is_at_least(10).
  #         with_message("Password isn't long enough")
  #     end
  #
  # ##### with_short_message
  #
  # Use `with_short_message` if you are using a custom "too short" message.
  #
  #     class User
  #       include ActiveModel::Model
  #       attr_accessor :secret_key
  #
  #       validates_length_of :secret_key,
  #         in: 15..100,
  #         too_short: 'Secret key must be more than 15 characters'
  #     end
  #
  #     # RSpec
  #     RSpec.describe User, type: :model do
  #       it do
  #         should validate_length_of(:secret_key).
  #           is_at_least(15).
  #           with_short_message('Secret key must be more than 15 characters')
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class UserTest < ActiveSupport::TestCase
  #       should validate_length_of(:secret_key).
  #         is_at_least(15).
  #         with_short_message('Secret key must be more than 15 characters')
  #     end
  #
  # ##### with_long_message
  #
  # Use `with_long_message` if you are using a custom "too long" message.
  #
  #     class User
  #       include ActiveModel::Model
  #       attr_accessor :secret_key
  #
  #       validates_length_of :secret_key,
  #         in: 15..100,
  #         too_long: 'Secret key must be less than 100 characters'
  #     end
  #
  #     # RSpec
  #     RSpec.describe User, type: :model do
  #       it do
  #         should validate_length_of(:secret_key).
  #           is_at_most(100).
  #           with_long_message('Secret key must be less than 100 characters')
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class UserTest < ActiveSupport::TestCase
  #       should validate_length_of(:secret_key).
  #         is_at_most(100).
  #         with_long_message('Secret key must be less than 100 characters')
  #     end
  #
  # ##### allow_nil
  #
  # Use `allow_nil` to assert that the attribute allows nil.
  #
  #     class User
  #       include ActiveModel::Model
  #       attr_accessor :bio
  #
  #       validates_length_of :bio, minimum: 15, allow_nil: true
  #     end
  #
  #     # RSpec
  #     describe User do
  #       it { should validate_length_of(:bio).is_at_least(15).allow_nil }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class UserTest < ActiveSupport::TestCase
  #       should validate_length_of(:bio).is_at_least(15).allow_nil
  #     end
  #
  # # ##### allow_blank
  #
  # Use `allow_blank` to assert that the attribute allows blank.
  #
  #     class User
  #       include ActiveModel::Model
  #       attr_accessor :bio
  #
  #       validates_length_of :bio, minimum: 15, allow_blank: true
  #     end
  #
  #     # RSpec
  #     describe User do
  #       it { should validate_length_of(:bio).is_at_least(15).allow_blank }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class UserTest < ActiveSupport::TestCase
  #       should validate_length_of(:bio).is_at_least(15).allow_blank
  #     end
  #
  # @return [ValidateLengthOfMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_length_of_matcher.rb#263
  def validate_length_of(attr); end

  # The `validate_numericality_of` matcher tests usage of the
  # `validates_numericality_of` validation.
  #
  #     class Person
  #       include ActiveModel::Model
  #       attr_accessor :gpa
  #
  #       validates_numericality_of :gpa
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it { should validate_numericality_of(:gpa) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should validate_numericality_of(:gpa)
  #     end
  #
  # #### Qualifiers
  #
  # ##### on
  #
  # Use `on` if your validation applies only under a certain context.
  #
  #     class Person
  #       include ActiveModel::Model
  #       attr_accessor :number_of_dependents
  #
  #       validates_numericality_of :number_of_dependents, on: :create
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it do
  #         should validate_numericality_of(:number_of_dependents).
  #           on(:create)
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should validate_numericality_of(:number_of_dependents).on(:create)
  #     end
  #
  # ##### only_integer
  #
  # Use `only_integer` to test usage of the `:only_integer` option. This
  # asserts that your attribute only allows integer numbers and disallows
  # non-integer ones.
  #
  #     class Person
  #       include ActiveModel::Model
  #       attr_accessor :age
  #
  #       validates_numericality_of :age, only_integer: true
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it { should validate_numericality_of(:age).only_integer }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should validate_numericality_of(:age).only_integer
  #     end
  #
  # ##### is_less_than
  #
  # Use `is_less_than` to test usage of the the `:less_than` option. This
  # asserts that the attribute can take a number which is less than the
  # given value and cannot take a number which is greater than or equal to
  # it.
  #
  #     class Person
  #       include ActiveModel::Model
  #       attr_accessor :number_of_cars
  #
  #       validates_numericality_of :number_of_cars, less_than: 2
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it do
  #         should validate_numericality_of(:number_of_cars).
  #           is_less_than(2)
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should validate_numericality_of(:number_of_cars).
  #         is_less_than(2)
  #     end
  #
  # ##### is_less_than_or_equal_to
  #
  # Use `is_less_than_or_equal_to` to test usage of the
  # `:less_than_or_equal_to` option. This asserts that the attribute can
  # take a number which is less than or equal to the given value and cannot
  # take a number which is greater than it.
  #
  #     class Person
  #       include ActiveModel::Model
  #       attr_accessor :birth_year
  #
  #       validates_numericality_of :birth_year, less_than_or_equal_to: 1987
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it do
  #         should validate_numericality_of(:birth_year).
  #           is_less_than_or_equal_to(1987)
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should validate_numericality_of(:birth_year).
  #         is_less_than_or_equal_to(1987)
  #     end
  #
  # ##### is_equal_to
  #
  # Use `is_equal_to` to test usage of the `:equal_to` option. This asserts
  # that the attribute can take a number which is equal to the given value
  # and cannot take a number which is not equal.
  #
  #     class Person
  #       include ActiveModel::Model
  #       attr_accessor :weight
  #
  #       validates_numericality_of :weight, equal_to: 150
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it { should validate_numericality_of(:weight).is_equal_to(150) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should validate_numericality_of(:weight).is_equal_to(150)
  #     end
  #
  # ##### is_greater_than_or_equal_to
  #
  # Use `is_greater_than_or_equal_to` to test usage of the
  # `:greater_than_or_equal_to` option. This asserts that the attribute can
  # take a number which is greater than or equal to the given value and
  # cannot take a number which is less than it.
  #
  #     class Person
  #       include ActiveModel::Model
  #       attr_accessor :height
  #
  #       validates_numericality_of :height, greater_than_or_equal_to: 55
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it do
  #         should validate_numericality_of(:height).
  #           is_greater_than_or_equal_to(55)
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should validate_numericality_of(:height).
  #         is_greater_than_or_equal_to(55)
  #     end
  #
  # ##### is_greater_than
  #
  # Use `is_greater_than` to test usage of the `:greater_than` option.
  # This asserts that the attribute can take a number which is greater than
  # the given value and cannot take a number less than or equal to it.
  #
  #     class Person
  #       include ActiveModel::Model
  #       attr_accessor :legal_age
  #
  #       validates_numericality_of :legal_age, greater_than: 21
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it do
  #         should validate_numericality_of(:legal_age).
  #           is_greater_than(21)
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should validate_numericality_of(:legal_age).
  #         is_greater_than(21)
  #     end
  #
  # ##### is_other_than
  #
  # Use `is_other_than` to test usage of the `:other_than` option.
  # This asserts that the attribute can take a number which is not equal to
  # the given value.
  #
  #     class Person
  #       include ActiveModel::Model
  #       attr_accessor :legal_age
  #
  #       validates_numericality_of :legal_age, other_than: 21
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it do
  #         should validate_numericality_of(:legal_age).
  #           is_other_than(21)
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should validate_numericality_of(:legal_age).
  #         is_other_than(21)
  #     end
  #
  # ##### even
  #
  # Use `even` to test usage of the `:even` option. This asserts that the
  # attribute can take odd numbers and cannot take even ones.
  #
  #     class Person
  #       include ActiveModel::Model
  #       attr_accessor :birth_month
  #
  #       validates_numericality_of :birth_month, even: true
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it { should validate_numericality_of(:birth_month).even }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should validate_numericality_of(:birth_month).even
  #     end
  #
  # ##### odd
  #
  # Use `odd` to test usage of the `:odd` option. This asserts that the
  # attribute can take a number which is odd and cannot take a number which
  # is even.
  #
  #     class Person
  #       include ActiveModel::Model
  #       attr_accessor :birth_day
  #
  #       validates_numericality_of :birth_day, odd: true
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it { should validate_numericality_of(:birth_day).odd }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should validate_numericality_of(:birth_day).odd
  #     end
  #
  # ##### with_message
  #
  # Use `with_message` if you are using a custom validation message.
  #
  #     class Person
  #       include ActiveModel::Model
  #       attr_accessor :number_of_dependents
  #
  #       validates_numericality_of :number_of_dependents,
  #         message: 'Number of dependents must be a number'
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it do
  #         should validate_numericality_of(:number_of_dependents).
  #           with_message('Number of dependents must be a number')
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should validate_numericality_of(:number_of_dependents).
  #         with_message('Number of dependents must be a number')
  #     end
  #
  # ##### allow_nil
  #
  # Use `allow_nil` to assert that the attribute allows nil.
  #
  #     class Post
  #       include ActiveModel::Model
  #       attr_accessor :age
  #
  #       validates_numericality_of :age, allow_nil: true
  #     end
  #
  #     # RSpec
  #     RSpec.describe Post, type: :model do
  #       it { should validate_numericality_of(:age).allow_nil }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PostTest < ActiveSupport::TestCase
  #       should validate_numericality_of(:age).allow_nil
  #     end
  #
  # @return [ValidateNumericalityOfMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#328
  def validate_numericality_of(attr); end

  # The `validate_presence_of` matcher tests usage of the
  # `validates_presence_of` validation.
  #
  #     class Robot
  #       include ActiveModel::Model
  #       attr_accessor :arms
  #
  #       validates_presence_of :arms
  #     end
  #
  #     # RSpec
  #     RSpec.describe Robot, type: :model do
  #       it { should validate_presence_of(:arms) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class RobotTest < ActiveSupport::TestCase
  #       should validate_presence_of(:arms)
  #     end
  #
  # #### Caveats
  #
  # Under Rails 4 and greater, if your model `has_secure_password` and you
  # are validating presence of the password using a record whose password
  # has already been set prior to calling the matcher, you will be
  # instructed to use a record whose password is empty instead.
  #
  # For example, given this scenario:
  #
  #     class User < ActiveRecord::Base
  #       has_secure_password validations: false
  #
  #       validates_presence_of :password
  #     end
  #
  #     RSpec.describe User, type: :model do
  #       subject { User.new(password: '123456') }
  #
  #       it { should validate_presence_of(:password) }
  #     end
  #
  # the above test will raise an error like this:
  #
  #     The validation failed because your User model declares
  #     `has_secure_password`, and `validate_presence_of` was called on a
  #     user which has `password` already set to a value. Please use a user
  #     with an empty `password` instead.
  #
  # This happens because `has_secure_password` itself overrides your model
  # so that it is impossible to set `password` to nil. This means that it is
  # impossible to test that setting `password` to nil places your model in
  # an invalid state (which in turn means that the validation itself is
  # unnecessary).
  #
  # #### Qualifiers
  #
  # ##### allow_nil
  #
  # Use `allow_nil` if your model has an optional attribute.
  #
  #   class Robot
  #     include ActiveModel::Model
  #     attr_accessor :nickname
  #
  #     validates_presence_of :nickname, allow_nil: true
  #   end
  #
  #   # RSpec
  #   RSpec.describe Robot, type: :model do
  #     it { should validate_presence_of(:nickname).allow_nil }
  #   end
  #
  #   # Minitest (Shoulda)
  #   class RobotTest < ActiveSupport::TestCase
  #     should validate_presence_of(:nickname).allow_nil
  #   end
  #
  # ##### on
  #
  # Use `on` if your validation applies only under a certain context.
  #
  #     class Robot
  #       include ActiveModel::Model
  #       attr_accessor :arms
  #
  #       validates_presence_of :arms, on: :create
  #     end
  #
  #     # RSpec
  #     RSpec.describe Robot, type: :model do
  #       it { should validate_presence_of(:arms).on(:create) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class RobotTest < ActiveSupport::TestCase
  #       should validate_presence_of(:arms).on(:create)
  #     end
  #
  # ##### with_message
  #
  # Use `with_message` if you are using a custom validation message.
  #
  #     class Robot
  #       include ActiveModel::Model
  #       attr_accessor :legs
  #
  #       validates_presence_of :legs, message: 'Robot has no legs'
  #     end
  #
  #     # RSpec
  #     RSpec.describe Robot, type: :model do
  #       it do
  #         should validate_presence_of(:legs).
  #           with_message('Robot has no legs')
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class RobotTest < ActiveSupport::TestCase
  #       should validate_presence_of(:legs).
  #         with_message('Robot has no legs')
  #     end
  #
  # @return [ValidatePresenceOfMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_presence_of_matcher.rb#129
  def validate_presence_of(attr); end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_mass_assignment_of_matcher.rb#75
class Shoulda::Matchers::ActiveModel::AllowMassAssignmentOfMatcher
  # @return [AllowMassAssignmentOfMatcher] a new instance of AllowMassAssignmentOfMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_mass_assignment_of_matcher.rb#78
  def initialize(attribute); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_mass_assignment_of_matcher.rb#83
  def as(role); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_mass_assignment_of_matcher.rb#114
  def description; end

  # Returns the value of attribute failure_message.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_mass_assignment_of_matcher.rb#76
  def failure_message; end

  # Returns the value of attribute failure_message_when_negated.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_mass_assignment_of_matcher.rb#76
  def failure_message_when_negated; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_mass_assignment_of_matcher.rb#88
  def matches?(subject); end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_mass_assignment_of_matcher.rb#138
  def accessible_attributes; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_mass_assignment_of_matcher.rb#147
  def attr_mass_assignable?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_mass_assignment_of_matcher.rb#151
  def authorizer; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_mass_assignment_of_matcher.rb#120
  def base_description; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_mass_assignment_of_matcher.rb#155
  def class_name; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_mass_assignment_of_matcher.rb#134
  def protected_attributes; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_mass_assignment_of_matcher.rb#130
  def role; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_mass_assignment_of_matcher.rb#124
  def role_description; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_mass_assignment_of_matcher.rb#143
  def whitelisting?; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#307
class Shoulda::Matchers::ActiveModel::AllowValueMatcher
  include ::Shoulda::Matchers::ActiveModel::Helpers
  include ::Shoulda::Matchers::ActiveModel::Qualifiers::IgnoringInterferenceByWriter

  # @return [AllowValueMatcher] a new instance of AllowValueMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#325
  def initialize(*values); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#389
  def _after_setting_value(&callback); end

  # Returns the value of attribute after_setting_value_callback.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#311
  def after_setting_value_callback; end

  # Sets the attribute attribute_changed_value_message
  #
  # @param value the value to set the attribute attribute_changed_value_message to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#319
  def attribute_changed_value_message=(_arg0); end

  # Returns the value of attribute attribute_to_check_message_against.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#311
  def attribute_to_check_message_against; end

  # Returns the value of attribute attribute_to_set.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#311
  def attribute_to_set; end

  # Returns the value of attribute context.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#311
  def context; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#502
  def description; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#399
  def does_not_match?(instance); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#366
  def expected_message; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#376
  def expects_custom_validation_message?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#385
  def expects_strict?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#405
  def failure_message; end

  # Sets the attribute failure_message_preface
  #
  # @param value the value to set the attribute failure_message_preface to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#319
  def failure_message_preface=(_arg0); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#432
  def failure_message_when_negated; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#338
  def for(attribute_name); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#311
  def instance; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#514
  def last_attribute_setter_used; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#518
  def last_value_set; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#393
  def matches?(instance); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#510
  def model; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#344
  def on(context); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#506
  def simple_description; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#380
  def strict(expects_strict = T.unsafe(nil)); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#319
  def values_to_preset=(_arg0); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#352
  def with_message(message, given_options = T.unsafe(nil)); end

  protected

  # Returns the value of attribute options.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#524
  def options; end

  # Returns the value of attribute result.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#524
  def result; end

  # Returns the value of attribute values_to_preset.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#524
  def values_to_preset; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#524
  def values_to_set; end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#569
  def attribute_changed_value_message; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#598
  def attribute_setters_and_validators_for_values_to_set; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#593
  def attribute_setters_for_values_to_preset; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#574
  def default_attribute_changed_value_message; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#621
  def default_attribute_message; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#628
  def default_attribute_message_values; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#613
  def default_expected_message; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#543
  def default_failure_message_preface; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#589
  def description_for_resulting_attribute_setter; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#584
  def descriptions_for_preset_values; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#539
  def failure_message_preface; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#642
  def human_attribute_name; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#564
  def include_attribute_changed_value_message?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#606
  def inspected_values_to_set; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#638
  def model_name; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher.rb#533
  def run(strategy); end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_changed_value_error.rb#6
class Shoulda::Matchers::ActiveModel::AllowValueMatcher::AttributeChangedValueError < ::Shoulda::Matchers::Error
  # Returns the value of attribute attribute_name.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_changed_value_error.rb#7
  def attribute_name; end

  # Sets the attribute attribute_name
  #
  # @param value the value to set the attribute attribute_name to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_changed_value_error.rb#7
  def attribute_name=(_arg0); end

  # Returns the value of attribute matcher_name.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_changed_value_error.rb#7
  def matcher_name; end

  # Sets the attribute matcher_name
  #
  # @param value the value to set the attribute matcher_name to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_changed_value_error.rb#7
  def matcher_name=(_arg0); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_changed_value_error.rb#10
  def message; end

  # Returns the value of attribute model.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_changed_value_error.rb#7
  def model; end

  # Sets the attribute model
  #
  # @param value the value to set the attribute model to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_changed_value_error.rb#7
  def model=(_arg0); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_changed_value_error.rb#38
  def successful?; end

  # Returns the value of attribute value_read.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_changed_value_error.rb#7
  def value_read; end

  # Sets the attribute value_read
  #
  # @param value the value to set the attribute value_read to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_changed_value_error.rb#7
  def value_read=(_arg0); end

  # Returns the value of attribute value_written.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_changed_value_error.rb#7
  def value_written; end

  # Sets the attribute value_written
  #
  # @param value the value to set the attribute value_written to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_changed_value_error.rb#7
  def value_written=(_arg0); end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_does_not_exist_error.rb#6
class Shoulda::Matchers::ActiveModel::AllowValueMatcher::AttributeDoesNotExistError < ::Shoulda::Matchers::Error
  # Returns the value of attribute attribute_name.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_does_not_exist_error.rb#7
  def attribute_name; end

  # Sets the attribute attribute_name
  #
  # @param value the value to set the attribute attribute_name to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_does_not_exist_error.rb#7
  def attribute_name=(_arg0); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_does_not_exist_error.rb#9
  def message; end

  # Returns the value of attribute model.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_does_not_exist_error.rb#7
  def model; end

  # Sets the attribute model
  #
  # @param value the value to set the attribute model to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_does_not_exist_error.rb#7
  def model=(_arg0); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_does_not_exist_error.rb#16
  def successful?; end

  # Returns the value of attribute value.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_does_not_exist_error.rb#7
  def value; end

  # Sets the attribute value
  #
  # @param value the value to set the attribute value to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_does_not_exist_error.rb#7
  def value=(_arg0); end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#6
class Shoulda::Matchers::ActiveModel::AllowValueMatcher::AttributeSetter
  # @return [AttributeSetter] a new instance of AttributeSetter
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#18
  def initialize(args); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#139
  def attribute_changed_value?; end

  # Returns the value of attribute attribute_name.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#11
  def attribute_name; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#55
  def check; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#115
  def checked?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#34
  def description; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#97
  def failure_message; end

  # Returns the value of attribute result_of_checking.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#11
  def result_of_checking; end

  # Returns the value of attribute result_of_setting.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#11
  def result_of_setting; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#47
  def run; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#51
  def run!; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#82
  def set; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#65
  def set!; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#127
  def set?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#107
  def successful?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#119
  def successfully_checked?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#131
  def successfully_set?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#111
  def unsuccessful?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#123
  def unsuccessfully_checked?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#135
  def value_read; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#11
  def value_written; end

  protected

  # Returns the value of attribute after_set_callback.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#145
  def after_set_callback; end

  # Returns the value of attribute args.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#145
  def args; end

  # Returns the value of attribute matcher_name.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#145
  def matcher_name; end

  # Returns the value of attribute object.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#145
  def object; end

  private

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#225
  def active_resource_object?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#200
  def attribute_changed_value!; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#204
  def attribute_changed_value_error; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#213
  def attribute_does_not_exist!; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#217
  def attribute_does_not_exist_error; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#153
  def attribute_exists?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#171
  def attribute_is_an_enum?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#184
  def defined_enums; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#180
  def enum_values; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#161
  def ignore_interference_by_writer; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#149
  def model; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#165
  def raise_attribute_changed_value_error?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#192
  def successful_check; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#196
  def successful_setting; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#175
  def value_read_is_expected_for_an_enum?; end

  class << self
    # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter.rb#7
    def set(args); end
  end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter_and_validator.rb#8
class Shoulda::Matchers::ActiveModel::AllowValueMatcher::AttributeSetterAndValidator
  extend ::Forwardable

  # @return [AttributeSetterAndValidator] a new instance of AttributeSetterAndValidator
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter_and_validator.rb#22
  def initialize(allow_value_matcher, attribute_name, value); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def after_setting_value_callback(*args, **_arg1, &block); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter_and_validator.rb#30
  def attribute_setter; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter_and_validator.rb#41
  def attribute_setter_description; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def attribute_to_check_message_against(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def context(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def expected_message(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def expects_strict?(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def ignore_interference_by_writer(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def instance(*args, **_arg1, &block); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter_and_validator.rb#45
  def validator; end

  protected

  # Returns the value of attribute allow_value_matcher.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter_and_validator.rb#57
  def allow_value_matcher; end

  # Returns the value of attribute attribute_name.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter_and_validator.rb#57
  def attribute_name; end

  # Returns the value of attribute value.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setter_and_validator.rb#57
  def value; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setters.rb#6
class Shoulda::Matchers::ActiveModel::AllowValueMatcher::AttributeSetters
  include ::Enumerable

  # @return [AttributeSetters] a new instance of AttributeSetters
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setters.rb#9
  def initialize(allow_value_matcher, values); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setters.rb#19
  def each(&block); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setters.rb#23
  def first_failing; end

  protected

  # Returns the value of attribute tuples.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setters.rb#29
  def tuples; end

  private

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setters.rb#33
  def does_not_match?(tuple); end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setters_and_validators.rb#6
class Shoulda::Matchers::ActiveModel::AllowValueMatcher::AttributeSettersAndValidators
  include ::Enumerable

  # @return [AttributeSettersAndValidators] a new instance of AttributeSettersAndValidators
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setters_and_validators.rb#9
  def initialize(allow_value_matcher, values); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setters_and_validators.rb#19
  def each(&block); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setters_and_validators.rb#27
  def first_failing; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setters_and_validators.rb#23
  def first_passing; end

  protected

  # Returns the value of attribute tuples.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setters_and_validators.rb#33
  def tuples; end

  private

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setters_and_validators.rb#41
  def does_not_match?(tuple); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/attribute_setters_and_validators.rb#37
  def matches?(tuple); end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/successful_check.rb#6
class Shoulda::Matchers::ActiveModel::AllowValueMatcher::SuccessfulCheck
  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/successful_check.rb#7
  def successful?; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/successful_setting.rb#6
class Shoulda::Matchers::ActiveModel::AllowValueMatcher::SuccessfulSetting
  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/allow_value_matcher/successful_setting.rb#7
  def successful?; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_model/errors.rb#5
class Shoulda::Matchers::ActiveModel::CouldNotDetermineValueOutsideOfArray < ::RuntimeError; end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_model/errors.rb#25
class Shoulda::Matchers::ActiveModel::CouldNotSetPasswordError < ::Shoulda::Matchers::Error
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/errors.rb#32
  def message; end

  # Returns the value of attribute model.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/errors.rb#30
  def model; end

  # Sets the attribute model
  #
  # @param value the value to set the attribute model to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/errors.rb#30
  def model=(_arg0); end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/errors.rb#42
  def model_name; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/errors.rb#46
  def record_name; end

  class << self
    # source://shoulda-matchers//lib/shoulda/matchers/active_model/errors.rb#26
    def create(model); end
  end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_model/disallow_value_matcher.rb#7
class Shoulda::Matchers::ActiveModel::DisallowValueMatcher
  extend ::Forwardable

  # @return [DisallowValueMatcher] a new instance of DisallowValueMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/disallow_value_matcher.rb#27
  def initialize(value); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def _after_setting_value(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def attribute_changed_value_message=(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def attribute_to_set(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def description(*args, **_arg1, &block); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/disallow_value_matcher.rb#35
  def does_not_match?(subject); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def expects_strict?(*args, **_arg1, &block); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/disallow_value_matcher.rb#64
  def failure_message; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def failure_message_preface(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def failure_message_preface=(*args, **_arg1, &block); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/disallow_value_matcher.rb#68
  def failure_message_when_negated; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/disallow_value_matcher.rb#39
  def for(attribute); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def ignore_interference_by_writer(*args, **_arg1, &block); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/disallow_value_matcher.rb#59
  def ignoring_interference_by_writer(value = T.unsafe(nil)); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def last_attribute_setter_used(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def last_value_set(*args, **_arg1, &block); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/disallow_value_matcher.rb#31
  def matches?(subject); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def model(*args, **_arg1, &block); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/disallow_value_matcher.rb#44
  def on(context); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def simple_description(*args, **_arg1, &block); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/disallow_value_matcher.rb#54
  def strict(strict = T.unsafe(nil)); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def values_to_preset=(*args, **_arg1, &block); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/disallow_value_matcher.rb#49
  def with_message(message, options = T.unsafe(nil)); end

  protected

  # Returns the value of attribute allow_matcher.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/disallow_value_matcher.rb#74
  def allow_matcher; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_model/have_secure_password_matcher.rb#38
class Shoulda::Matchers::ActiveModel::HaveSecurePasswordMatcher
  # @return [HaveSecurePasswordMatcher] a new instance of HaveSecurePasswordMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/have_secure_password_matcher.rb#52
  def initialize(attribute); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/have_secure_password_matcher.rb#56
  def description; end

  # Returns the value of attribute failure_message.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/have_secure_password_matcher.rb#39
  def failure_message; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/have_secure_password_matcher.rb#60
  def matches?(subject); end

  protected

  # Returns the value of attribute subject.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/have_secure_password_matcher.rb#74
  def subject; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/have_secure_password_matcher.rb#76
  def validate; end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/have_secure_password_matcher.rb#108
  def authenticate_method; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/have_secure_password_matcher.rb#98
  def expected_methods; end
end

# source://shoulda-matchers//lib/shoulda/matchers/active_model/have_secure_password_matcher.rb#41
Shoulda::Matchers::ActiveModel::HaveSecurePasswordMatcher::CORRECT_PASSWORD = T.let(T.unsafe(nil), String)

# source://shoulda-matchers//lib/shoulda/matchers/active_model/have_secure_password_matcher.rb#42
Shoulda::Matchers::ActiveModel::HaveSecurePasswordMatcher::INCORRECT_PASSWORD = T.let(T.unsafe(nil), String)

# source://shoulda-matchers//lib/shoulda/matchers/active_model/have_secure_password_matcher.rb#44
Shoulda::Matchers::ActiveModel::HaveSecurePasswordMatcher::MESSAGES = T.let(T.unsafe(nil), Hash)

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_model/helpers.rb#5
module Shoulda::Matchers::ActiveModel::Helpers
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/helpers.rb#19
  def default_error_message(type, options = T.unsafe(nil)); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/helpers.rb#10
  def format_validation_errors(errors); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/helpers.rb#6
  def pretty_error_messages(object); end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_model/errors.rb#8
class Shoulda::Matchers::ActiveModel::NonNullableBooleanError < ::Shoulda::Matchers::Error
  # Returns the value of attribute attribute.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/errors.rb#13
  def attribute; end

  # Sets the attribute attribute
  #
  # @param value the value to set the attribute attribute to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/errors.rb#13
  def attribute=(_arg0); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/errors.rb#15
  def message; end

  class << self
    # source://shoulda-matchers//lib/shoulda/matchers/active_model/errors.rb#9
    def create(attribute); end
  end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/numeric_type_matcher.rb#6
module Shoulda::Matchers::ActiveModel::NumericalityMatchers; end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/comparison_matcher.rb#6
class Shoulda::Matchers::ActiveModel::NumericalityMatchers::ComparisonMatcher < ::Shoulda::Matchers::ActiveModel::ValidationMatcher
  # @return [ComparisonMatcher] a new instance of ComparisonMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/comparison_matcher.rb#34
  def initialize(numericality_matcher, value, operator); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/comparison_matcher.rb#86
  def comparison_description; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/comparison_matcher.rb#69
  def expects_custom_validation_message?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/comparison_matcher.rb#78
  def failure_message; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/comparison_matcher.rb#82
  def failure_message_when_negated; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/comparison_matcher.rb#58
  def for(attribute); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/comparison_matcher.rb#73
  def matches?(subject); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/comparison_matcher.rb#46
  def simple_description; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/comparison_matcher.rb#63
  def with_message(message); end

  private

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/comparison_matcher.rb#92
  def all_bounds_correct?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/comparison_matcher.rb#135
  def assertions; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/comparison_matcher.rb#121
  def comparison_combos; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/comparison_matcher.rb#150
  def comparison_expectation; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/comparison_matcher.rb#139
  def diffs_to_compare; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/comparison_matcher.rb#96
  def failing_submatchers; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/comparison_matcher.rb#102
  def last_failing_submatcher; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/comparison_matcher.rb#125
  def submatcher_method_names; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/comparison_matcher.rb#106
  def submatchers; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/comparison_matcher.rb#115
  def submatchers_and_results; end
end

# source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/comparison_matcher.rb#7
Shoulda::Matchers::ActiveModel::NumericalityMatchers::ComparisonMatcher::ERROR_MESSAGES = T.let(T.unsafe(nil), Hash)

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/even_number_matcher.rb#6
class Shoulda::Matchers::ActiveModel::NumericalityMatchers::EvenNumberMatcher < ::Shoulda::Matchers::ActiveModel::NumericalityMatchers::NumericTypeMatcher
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/even_number_matcher.rb#20
  def allowed_type_adjective; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/even_number_matcher.rb#24
  def diff_to_compare; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/even_number_matcher.rb#9
  def simple_description; end

  protected

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/even_number_matcher.rb#34
  def disallowed_value; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/even_number_matcher.rb#30
  def wrap_disallow_value_matcher(matcher); end
end

# source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/even_number_matcher.rb#7
Shoulda::Matchers::ActiveModel::NumericalityMatchers::EvenNumberMatcher::NON_EVEN_NUMBER_VALUE = T.let(T.unsafe(nil), Integer)

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/numeric_type_matcher.rb#8
class Shoulda::Matchers::ActiveModel::NumericalityMatchers::NumericTypeMatcher
  extend ::Forwardable

  # @return [NumericTypeMatcher] a new instance of NumericTypeMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/numeric_type_matcher.rb#26
  def initialize(numeric_type_matcher, attribute); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/numeric_type_matcher.rb#35
  def allowed_type_adjective; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/numeric_type_matcher.rb#31
  def allowed_type_name; end

  # @raise [NotImplementedError]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/numeric_type_matcher.rb#39
  def diff_to_compare; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def does_not_match?(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def expects_custom_validation_message?(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def expects_strict?(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def failure_message(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def failure_message_when_negated(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def ignore_interference_by_writer(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def ignoring_interference_by_writer(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def matches?(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def on(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def strict(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def with_message(*args, **_arg1, &block); end

  protected

  # Returns the value of attribute attribute.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/numeric_type_matcher.rb#45
  def attribute; end

  # @raise [NotImplementedError]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/numeric_type_matcher.rb#51
  def disallowed_value; end

  # @raise [NotImplementedError]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/numeric_type_matcher.rb#47
  def wrap_disallow_value_matcher(_matcher); end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/numeric_type_matcher.rb#57
  def disallow_value_matcher; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/odd_number_matcher.rb#6
class Shoulda::Matchers::ActiveModel::NumericalityMatchers::OddNumberMatcher < ::Shoulda::Matchers::ActiveModel::NumericalityMatchers::NumericTypeMatcher
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/odd_number_matcher.rb#20
  def allowed_type_adjective; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/odd_number_matcher.rb#24
  def diff_to_compare; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/odd_number_matcher.rb#9
  def simple_description; end

  protected

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/odd_number_matcher.rb#34
  def disallowed_value; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/odd_number_matcher.rb#30
  def wrap_disallow_value_matcher(matcher); end
end

# source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/odd_number_matcher.rb#7
Shoulda::Matchers::ActiveModel::NumericalityMatchers::OddNumberMatcher::NON_ODD_NUMBER_VALUE = T.let(T.unsafe(nil), Integer)

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/only_integer_matcher.rb#6
class Shoulda::Matchers::ActiveModel::NumericalityMatchers::OnlyIntegerMatcher < ::Shoulda::Matchers::ActiveModel::NumericalityMatchers::NumericTypeMatcher
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/only_integer_matcher.rb#19
  def allowed_type_name; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/only_integer_matcher.rb#23
  def diff_to_compare; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/only_integer_matcher.rb#9
  def simple_description; end

  protected

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/only_integer_matcher.rb#33
  def disallowed_value; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/only_integer_matcher.rb#29
  def wrap_disallow_value_matcher(matcher); end
end

# source://shoulda-matchers//lib/shoulda/matchers/active_model/numericality_matchers/only_integer_matcher.rb#7
Shoulda::Matchers::ActiveModel::NumericalityMatchers::OnlyIntegerMatcher::NON_INTEGER_VALUE = T.let(T.unsafe(nil), Float)

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_model/qualifiers.rb#5
module Shoulda::Matchers::ActiveModel::Qualifiers; end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_model/qualifiers/allow_nil.rb#6
module Shoulda::Matchers::ActiveModel::Qualifiers::AllowNil
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/qualifiers/allow_nil.rb#7
  def initialize(*args); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/qualifiers/allow_nil.rb#12
  def allow_nil; end

  protected

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/qualifiers/allow_nil.rb#19
  def expects_to_allow_nil?; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_model/qualifiers/ignore_interference_by_writer.rb#6
class Shoulda::Matchers::ActiveModel::Qualifiers::IgnoreInterferenceByWriter
  # @return [IgnoreInterferenceByWriter] a new instance of IgnoreInterferenceByWriter
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/qualifiers/ignore_interference_by_writer.rb#9
  def initialize(argument = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/qualifiers/ignore_interference_by_writer.rb#62
  def always?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/qualifiers/ignore_interference_by_writer.rb#70
  def changed?; end

  # Returns the value of attribute condition.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/qualifiers/ignore_interference_by_writer.rb#7
  def condition; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/qualifiers/ignore_interference_by_writer.rb#54
  def considering?(value); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/qualifiers/ignore_interference_by_writer.rb#42
  def default_to(argument); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/qualifiers/ignore_interference_by_writer.rb#66
  def never?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/qualifiers/ignore_interference_by_writer.rb#14
  def set(argument); end

  # Returns the value of attribute setting.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/qualifiers/ignore_interference_by_writer.rb#7
  def setting; end

  private

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/qualifiers/ignore_interference_by_writer.rb#90
  def condition_matches?(value); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/qualifiers/ignore_interference_by_writer.rb#76
  def invalid_argument_error(invalid_argument); end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_model/qualifiers/ignoring_interference_by_writer.rb#6
module Shoulda::Matchers::ActiveModel::Qualifiers::IgnoringInterferenceByWriter
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/qualifiers/ignoring_interference_by_writer.rb#9
  def initialize(*_arg0); end

  # Returns the value of attribute ignore_interference_by_writer.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/qualifiers/ignoring_interference_by_writer.rb#7
  def ignore_interference_by_writer; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/qualifiers/ignoring_interference_by_writer.rb#13
  def ignoring_interference_by_writer(value = T.unsafe(nil)); end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_absence_of_matcher.rb#80
class Shoulda::Matchers::ActiveModel::ValidateAbsenceOfMatcher < ::Shoulda::Matchers::ActiveModel::ValidationMatcher
  # @return [ValidateAbsenceOfMatcher] a new instance of ValidateAbsenceOfMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_absence_of_matcher.rb#81
  def initialize(attribute); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_absence_of_matcher.rb#91
  def does_not_match?(subject); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_absence_of_matcher.rb#86
  def matches?(subject); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_absence_of_matcher.rb#96
  def simple_description; end

  private

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_absence_of_matcher.rb#143
  def array_column?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_absence_of_matcher.rb#130
  def collection?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_absence_of_matcher.rb#124
  def column_type; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_absence_of_matcher.rb#138
  def reflection; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_absence_of_matcher.rb#102
  def value; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_acceptance_of_matcher.rb#83
class Shoulda::Matchers::ActiveModel::ValidateAcceptanceOfMatcher < ::Shoulda::Matchers::ActiveModel::ValidationMatcher
  # @return [ValidateAcceptanceOfMatcher] a new instance of ValidateAcceptanceOfMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_acceptance_of_matcher.rb#84
  def initialize(attribute); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_acceptance_of_matcher.rb#94
  def does_not_match?(subject); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_acceptance_of_matcher.rb#89
  def matches?(subject); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_acceptance_of_matcher.rb#99
  def simple_description; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_confirmation_of_matcher.rb#80
class Shoulda::Matchers::ActiveModel::ValidateConfirmationOfMatcher < ::Shoulda::Matchers::ActiveModel::ValidationMatcher
  include ::Shoulda::Matchers::ActiveModel::Helpers

  # @return [ValidateConfirmationOfMatcher] a new instance of ValidateConfirmationOfMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_confirmation_of_matcher.rb#85
  def initialize(attribute); end

  # Returns the value of attribute attribute.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_confirmation_of_matcher.rb#83
  def attribute; end

  # Returns the value of attribute confirmation_attribute.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_confirmation_of_matcher.rb#83
  def confirmation_attribute; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_confirmation_of_matcher.rb#103
  def does_not_match?(subject); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_confirmation_of_matcher.rb#95
  def matches?(subject); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_confirmation_of_matcher.rb#91
  def simple_description; end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_confirmation_of_matcher.rb#113
  def allows_different_value; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_confirmation_of_matcher.rb#137
  def allows_missing_confirmation; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_confirmation_of_matcher.rb#125
  def allows_same_value; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_confirmation_of_matcher.rb#119
  def disallows_different_value; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_confirmation_of_matcher.rb#143
  def disallows_missing_confirmation; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_confirmation_of_matcher.rb#131
  def disallows_same_value; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_confirmation_of_matcher.rb#149
  def qualify_matcher(matcher, confirmation_attribute_value); end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_exclusion_of_matcher.rb#122
class Shoulda::Matchers::ActiveModel::ValidateExclusionOfMatcher < ::Shoulda::Matchers::ActiveModel::ValidationMatcher
  # @return [ValidateExclusionOfMatcher] a new instance of ValidateExclusionOfMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_exclusion_of_matcher.rb#123
  def initialize(attribute); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_exclusion_of_matcher.rb#173
  def does_not_match?(subject); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_exclusion_of_matcher.rb#130
  def in_array(array); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_exclusion_of_matcher.rb#135
  def in_range(range); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_exclusion_of_matcher.rb#160
  def matches?(subject); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_exclusion_of_matcher.rb#142
  def simple_description; end

  private

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_exclusion_of_matcher.rb#188
  def allows_any_values_in_array?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_exclusion_of_matcher.rb#224
  def allows_higher_value; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_exclusion_of_matcher.rb#200
  def allows_lower_value; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_exclusion_of_matcher.rb#216
  def allows_maximum_value; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_exclusion_of_matcher.rb#208
  def allows_minimum_value; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_exclusion_of_matcher.rb#194
  def disallows_all_values_in_array?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_exclusion_of_matcher.rb#228
  def disallows_higher_value; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_exclusion_of_matcher.rb#204
  def disallows_lower_value; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_exclusion_of_matcher.rb#220
  def disallows_maximum_value; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_exclusion_of_matcher.rb#212
  def disallows_minimum_value; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_exclusion_of_matcher.rb#232
  def inspect_message; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_exclusion_of_matcher.rb#240
  def inspected_array; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#270
class Shoulda::Matchers::ActiveModel::ValidateInclusionOfMatcher < ::Shoulda::Matchers::ActiveModel::ValidationMatcher
  # @return [ValidateInclusionOfMatcher] a new instance of ValidateInclusionOfMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#291
  def initialize(attribute); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#314
  def allow_nil; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#383
  def does_not_match?(subject); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#319
  def expects_to_allow_nil?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#302
  def in_array(array); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#307
  def in_range(range); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#368
  def matches?(subject); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#350
  def simple_description; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#342
  def with_high_message(message); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#333
  def with_low_message(message); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#323
  def with_message(message); end

  private

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#464
  def allows_all_values_in_array?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#476
  def allows_any_value_outside_of_array?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#456
  def allows_higher_value; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#428
  def allows_lower_value; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#448
  def allows_maximum_value; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#440
  def allows_minimum_value; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#603
  def allows_nil_value?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#569
  def attribute_allows_nil?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#577
  def attribute_column; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#561
  def attribute_type; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#545
  def boolean_outside_values; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#583
  def column_type_to_attribute_type(type); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#497
  def disallows_all_values_outside_of_array?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#470
  def disallows_any_values_in_array?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#460
  def disallows_higher_value; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#434
  def disallows_lower_value; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#452
  def disallows_maximum_value; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#444
  def disallows_minimum_value; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#607
  def disallows_nil_value?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#421
  def does_not_match_for_array?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#407
  def does_not_match_for_range?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#611
  def inspected_array; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#414
  def matches_for_array?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#400
  def matches_for_range?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#526
  def outside_values; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#591
  def value_to_attribute_type(value); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#518
  def values_outside_of_array; end
end

# source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#275
Shoulda::Matchers::ActiveModel::ValidateInclusionOfMatcher::ARBITRARY_OUTSIDE_DATE = T.let(T.unsafe(nil), Date)

# source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#276
Shoulda::Matchers::ActiveModel::ValidateInclusionOfMatcher::ARBITRARY_OUTSIDE_DATETIME = T.let(T.unsafe(nil), DateTime)

# source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#274
Shoulda::Matchers::ActiveModel::ValidateInclusionOfMatcher::ARBITRARY_OUTSIDE_DECIMAL = T.let(T.unsafe(nil), BigDecimal)

# source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#273
Shoulda::Matchers::ActiveModel::ValidateInclusionOfMatcher::ARBITRARY_OUTSIDE_INTEGER = T.let(T.unsafe(nil), Integer)

# source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#272
Shoulda::Matchers::ActiveModel::ValidateInclusionOfMatcher::ARBITRARY_OUTSIDE_STRING = T.let(T.unsafe(nil), String)

# source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#277
Shoulda::Matchers::ActiveModel::ValidateInclusionOfMatcher::ARBITRARY_OUTSIDE_TIME = T.let(T.unsafe(nil), Time)

# source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#271
Shoulda::Matchers::ActiveModel::ValidateInclusionOfMatcher::BLANK_VALUES = T.let(T.unsafe(nil), Array)

# source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#278
Shoulda::Matchers::ActiveModel::ValidateInclusionOfMatcher::BOOLEAN_ALLOWS_BOOLEAN_MESSAGE = T.let(T.unsafe(nil), String)

# source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_inclusion_of_matcher.rb#284
Shoulda::Matchers::ActiveModel::ValidateInclusionOfMatcher::BOOLEAN_ALLOWS_NIL_MESSAGE = T.let(T.unsafe(nil), String)

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_length_of_matcher.rb#268
class Shoulda::Matchers::ActiveModel::ValidateLengthOfMatcher < ::Shoulda::Matchers::ActiveModel::ValidationMatcher
  include ::Shoulda::Matchers::ActiveModel::Helpers

  # @return [ValidateLengthOfMatcher] a new instance of ValidateLengthOfMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_length_of_matcher.rb#271
  def initialize(attribute); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_length_of_matcher.rb#326
  def allow_nil; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_length_of_matcher.rb#359
  def does_not_match?(subject); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_length_of_matcher.rb#278
  def is_at_least(length); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_length_of_matcher.rb#284
  def is_at_most(length); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_length_of_matcher.rb#290
  def is_equal_to(length); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_length_of_matcher.rb#350
  def matches?(subject); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_length_of_matcher.rb#331
  def simple_description; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_length_of_matcher.rb#317
  def with_long_message(message); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_length_of_matcher.rb#298
  def with_message(message); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_length_of_matcher.rb#308
  def with_short_message(message); end

  private

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_length_of_matcher.rb#449
  def allow_nil_does_not_match?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_length_of_matcher.rb#445
  def allow_nil_matches?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_length_of_matcher.rb#409
  def allows_higher_length?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_length_of_matcher.rb#453
  def allows_length_of?(length, message); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_length_of_matcher.rb#390
  def allows_lower_length?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_length_of_matcher.rb#435
  def allows_maximum_length?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_length_of_matcher.rb#425
  def allows_minimum_length?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_length_of_matcher.rb#417
  def disallows_higher_length?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_length_of_matcher.rb#457
  def disallows_length_of?(length, message); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_length_of_matcher.rb#399
  def disallows_lower_length?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_length_of_matcher.rb#440
  def disallows_maximum_length?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_length_of_matcher.rb#430
  def disallows_minimum_length?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_length_of_matcher.rb#370
  def expects_to_allow_nil?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_length_of_matcher.rb#378
  def lower_bound_does_not_match?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_length_of_matcher.rb#374
  def lower_bound_matches?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_length_of_matcher.rb#461
  def string_of_length(length); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_length_of_matcher.rb#480
  def translated_long_message; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_length_of_matcher.rb#465
  def translated_short_message; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_length_of_matcher.rb#386
  def upper_bound_does_not_match?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_length_of_matcher.rb#382
  def upper_bound_matches?; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#333
class Shoulda::Matchers::ActiveModel::ValidateNumericalityOfMatcher
  include ::Shoulda::Matchers::ActiveModel::Qualifiers::IgnoringInterferenceByWriter

  # @return [ValidateNumericalityOfMatcher] a new instance of ValidateNumericalityOfMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#341
  def initialize(attribute); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#371
  def allow_nil; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#467
  def description; end

  # Returns the value of attribute diff_to_compare.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#339
  def diff_to_compare; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#449
  def does_not_match?(subject); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#392
  def even; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#435
  def expects_custom_validation_message?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#360
  def expects_strict?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#381
  def expects_to_allow_nil?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#471
  def failure_message; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#478
  def failure_message_when_negated; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#486
  def given_numeric_column?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#409
  def is_equal_to(value); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#399
  def is_greater_than(value); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#404
  def is_greater_than_or_equal_to(value); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#414
  def is_less_than(value); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#419
  def is_less_than_or_equal_to(value); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#424
  def is_other_than(value); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#444
  def matches?(subject); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#385
  def odd; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#439
  def on(context); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#364
  def only_integer; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#454
  def simple_description; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#355
  def strict; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#429
  def with_message(message); end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#531
  def add_disallow_value_matcher; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#551
  def add_submatcher(submatcher); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#515
  def attribute_is_active_record_column?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#633
  def build_submatcher_failure_message_for(submatcher, failure_message_method); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#519
  def column_type; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#523
  def columns_hash; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#658
  def comparison_descriptions; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#545
  def comparison_matcher_for(value, operator); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#619
  def failure_message_for_first_submatcher_that_fails_to_match; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#626
  def failure_message_for_first_submatcher_that_fails_to_not_match; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#605
  def first_submatcher_that_fails_to_match; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#612
  def first_submatcher_that_fails_to_not_match; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#654
  def full_allowed_type; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#598
  def has_been_qualified?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#493
  def matches_or_does_not_match?(subject); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#676
  def model; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#680
  def non_numeric_value; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#590
  def number_of_submatchers_for_failure_message; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#501
  def overall_failure_message; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#508
  def overall_failure_message_when_negated; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#540
  def prepare_submatcher(submatcher); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#570
  def qualify_submatchers; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#667
  def submatcher_comparison_descriptions; end
end

# source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#335
Shoulda::Matchers::ActiveModel::ValidateNumericalityOfMatcher::DEFAULT_DIFF_TO_COMPARE = T.let(T.unsafe(nil), Integer)

# source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_numericality_of_matcher.rb#334
Shoulda::Matchers::ActiveModel::ValidateNumericalityOfMatcher::NUMERIC_NAME = T.let(T.unsafe(nil), String)

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_presence_of_matcher.rb#134
class Shoulda::Matchers::ActiveModel::ValidatePresenceOfMatcher < ::Shoulda::Matchers::ActiveModel::ValidationMatcher
  include ::Shoulda::Matchers::ActiveModel::Qualifiers::AllowNil

  # @return [ValidatePresenceOfMatcher] a new instance of ValidatePresenceOfMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_presence_of_matcher.rb#137
  def initialize(attribute); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_presence_of_matcher.rb#161
  def does_not_match?(subject); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_presence_of_matcher.rb#184
  def failure_message; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_presence_of_matcher.rb#142
  def matches?(subject); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_presence_of_matcher.rb#180
  def simple_description; end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_presence_of_matcher.rb#216
  def allows_and_double_checks_value_of!(value); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_presence_of_matcher.rb#222
  def allows_original_or_typecast_value?(value); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_presence_of_matcher.rb#325
  def association?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_presence_of_matcher.rb#341
  def association_name; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_presence_of_matcher.rb#345
  def association_options; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_presence_of_matcher.rb#349
  def association_reflection; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_presence_of_matcher.rb#335
  def attachment?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_presence_of_matcher.rb#314
  def attribute_accepts_string_values?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_presence_of_matcher.rb#359
  def attribute_serialization_coder; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_presence_of_matcher.rb#363
  def attribute_type; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_presence_of_matcher.rb#310
  def belongs_to_association_being_validated?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_presence_of_matcher.rb#305
  def belongs_to_association_configured_to_be_required?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_presence_of_matcher.rb#329
  def collection_association?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_presence_of_matcher.rb#236
  def disallowed_values; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_presence_of_matcher.rb#226
  def disallows_and_double_checks_value_of!(value); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_presence_of_matcher.rb#232
  def disallows_original_or_typecast_value?(value); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_presence_of_matcher.rb#289
  def example_of_belongs_to(with: T.unsafe(nil)); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_presence_of_matcher.rb#371
  def model; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_presence_of_matcher.rb#353
  def model_has_associations?(associations); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_presence_of_matcher.rb#210
  def possibly_ignore_interference_by_writer; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_presence_of_matcher.rb#367
  def presence_validation_exists_on_attribute?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_presence_of_matcher.rb#261
  def reason_for_existing_presence_validation; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_presence_of_matcher.rb#205
  def secure_password_being_validated?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_presence_of_matcher.rb#256
  def should_add_footnote_about_belongs_to?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validate_presence_of_matcher.rb#272
  def suggestions_for_belongs_to; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher.rb#5
class Shoulda::Matchers::ActiveModel::ValidationMatcher
  include ::Shoulda::Matchers::ActiveModel::Qualifiers::IgnoringInterferenceByWriter

  # @return [ValidationMatcher] a new instance of ValidationMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher.rb#8
  def initialize(attribute); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher.rb#27
  def allow_blank; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher.rb#18
  def description; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher.rb#59
  def does_not_match?(subject); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher.rb#50
  def expects_custom_validation_message?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher.rb#37
  def expects_strict?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher.rb#64
  def failure_message; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher.rb#76
  def failure_message_when_negated; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher.rb#54
  def matches?(subject); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher.rb#22
  def on(context); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher.rb#32
  def strict; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher.rb#41
  def with_message(expected_message); end

  protected

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher.rb#129
  def allow_blank_does_not_match?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher.rb#124
  def allow_blank_matches?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher.rb#106
  def allow_value_matcher(value, message = T.unsafe(nil), &block); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher.rb#96
  def allows_value_of(value, message = T.unsafe(nil), &block); end

  # Returns the value of attribute attribute.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher.rb#90
  def attribute; end

  # Returns the value of attribute context.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher.rb#90
  def context; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher.rb#115
  def disallow_value_matcher(value, message = T.unsafe(nil), &block); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher.rb#101
  def disallows_value_of(value, message = T.unsafe(nil), &block); end

  # Returns the value of attribute last_submatcher_run.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher.rb#90
  def last_submatcher_run; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher.rb#92
  def model; end

  # Returns the value of attribute subject.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher.rb#90
  def subject; end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher.rb#186
  def blank_values; end

  # @yield [matcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher.rb#160
  def build_allow_or_disallow_value_matcher(args); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher.rb#182
  def expects_to_allow_blank?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher.rb#152
  def failure_reason; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher.rb#156
  def failure_reason_when_negated; end

  # Returns the value of attribute options.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher.rb#136
  def options; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher.rb#138
  def overall_failure_message; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher.rb#145
  def overall_failure_message_when_negated; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher.rb#177
  def run_allow_or_disallow_matcher(matcher); end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher/build_description.rb#6
class Shoulda::Matchers::ActiveModel::ValidationMatcher::BuildDescription
  # @return [BuildDescription] a new instance of BuildDescription
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher/build_description.rb#11
  def initialize(matcher, main_description); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher/build_description.rb#16
  def call; end

  protected

  # Returns the value of attribute main_description.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher/build_description.rb#27
  def main_description; end

  # Returns the value of attribute matcher.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher/build_description.rb#27
  def matcher; end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher/build_description.rb#31
  def clause_for_allow_blank_or_nil; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher/build_description.rb#41
  def description_clauses_for_qualifiers; end

  class << self
    # source://shoulda-matchers//lib/shoulda/matchers/active_model/validation_matcher/build_description.rb#7
    def call(matcher, main_description); end
  end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_model/validator.rb#5
class Shoulda::Matchers::ActiveModel::Validator
  include ::Shoulda::Matchers::ActiveModel::Helpers

  # @return [Validator] a new instance of Validator
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validator.rb#8
  def initialize(record, attribute, options = T.unsafe(nil)); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validator.rb#36
  def all_formatted_validation_error_messages; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validator.rb#20
  def call; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validator.rb#28
  def captured_validation_exception?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validator.rb#24
  def has_messages?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validator.rb#32
  def type_of_message_matched?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validator.rb#40
  def validation_exception_message; end

  protected

  # Returns the value of attribute attribute.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validator.rb#46
  def attribute; end

  # Returns the value of attribute context.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validator.rb#46
  def context; end

  # Returns the value of attribute record.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validator.rb#46
  def record; end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validator.rb#80
  def all_validation_errors; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validator.rb#76
  def captured_range_error?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validator.rb#50
  def expects_strict?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validator.rb#68
  def matched_messages; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validator.rb#60
  def messages; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validator.rb#54
  def messages_match?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validator.rb#92
  def perform_validation; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validator.rb#84
  def validation_error_messages; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_model/validator.rb#88
  def validation_result; end
end

# This module provides matchers that are used to test behavior within
# ActiveRecord classes.
#
# source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#5
module Shoulda::Matchers::ActiveRecord
  # The `accept_nested_attributes_for` matcher tests usage of the
  # `accepts_nested_attributes_for` macro.
  #
  #     class Car < ActiveRecord::Base
  #       accepts_nested_attributes_for :doors
  #     end
  #
  #     # RSpec
  #     RSpec.describe Car, type: :model do
  #       it { should accept_nested_attributes_for(:doors) }
  #     end
  #
  #     # Minitest (Shoulda) (using Shoulda)
  #     class CarTest < ActiveSupport::TestCase
  #       should accept_nested_attributes_for(:doors)
  #     end
  #
  # #### Qualifiers
  #
  # ##### allow_destroy
  #
  # Use `allow_destroy` to assert that the `:allow_destroy` option was
  # specified.
  #
  #     class Car < ActiveRecord::Base
  #       accepts_nested_attributes_for :mirrors, allow_destroy: true
  #     end
  #
  #     # RSpec
  #     RSpec.describe Car, type: :model do
  #       it do
  #         should accept_nested_attributes_for(:mirrors).
  #           allow_destroy(true)
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class CarTest < ActiveSupport::TestCase
  #       should accept_nested_attributes_for(:mirrors).
  #         allow_destroy(true)
  #     end
  #
  # ##### limit
  #
  # Use `limit` to assert that the `:limit` option was specified.
  #
  #     class Car < ActiveRecord::Base
  #       accepts_nested_attributes_for :windows, limit: 3
  #     end
  #
  #     # RSpec
  #     RSpec.describe Car, type: :model do
  #       it do
  #         should accept_nested_attributes_for(:windows).
  #           limit(3)
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class CarTest < ActiveSupport::TestCase
  #       should accept_nested_attributes_for(:windows).
  #         limit(3)
  #     end
  #
  # ##### update_only
  #
  # Use `update_only` to assert that the `:update_only` option was
  # specified.
  #
  #     class Car < ActiveRecord::Base
  #       accepts_nested_attributes_for :engine, update_only: true
  #     end
  #
  #     # RSpec
  #     RSpec.describe Car, type: :model do
  #       it do
  #         should accept_nested_attributes_for(:engine).
  #           update_only(true)
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class CarTest < ActiveSupport::TestCase
  #       should accept_nested_attributes_for(:engine).
  #         update_only(true)
  #     end
  #
  # @return [AcceptNestedAttributesForMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/accept_nested_attributes_for_matcher.rb#93
  def accept_nested_attributes_for(name); end

  # The `belong_to` matcher is used to ensure that a `belong_to` association
  # exists on your model.
  #
  #     class Person < ActiveRecord::Base
  #       belongs_to :organization
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it { should belong_to(:organization) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should belong_to(:organization)
  #     end
  #
  # Note that polymorphic associations are automatically detected and do not
  # need any qualifiers:
  #
  #     class Comment < ActiveRecord::Base
  #       belongs_to :commentable, polymorphic: true
  #     end
  #
  #     # RSpec
  #     RSpec.describe Comment, type: :model do
  #       it { should belong_to(:commentable) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class CommentTest < ActiveSupport::TestCase
  #       should belong_to(:commentable)
  #     end
  #
  # #### Qualifiers
  #
  # ##### conditions
  #
  # Use `conditions` if your association is defined with a scope that sets
  # the `where` clause.
  #
  #     class Person < ActiveRecord::Base
  #       belongs_to :family, -> { where(everyone_is_perfect: false) }
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it do
  #         should belong_to(:family).
  #           conditions(everyone_is_perfect: false)
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should belong_to(:family).
  #         conditions(everyone_is_perfect: false)
  #     end
  #
  # ##### order
  #
  # Use `order` if your association is defined with a scope that sets the
  # `order` clause.
  #
  #     class Person < ActiveRecord::Base
  #       belongs_to :previous_company, -> { order('hired_on desc') }
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it { should belong_to(:previous_company).order('hired_on desc') }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should belong_to(:previous_company).order('hired_on desc')
  #     end
  #
  # ##### class_name
  #
  # Use `class_name` to test usage of the `:class_name` option. This
  # asserts that the model you're referring to actually exists.
  #
  #     class Person < ActiveRecord::Base
  #       belongs_to :ancient_city, class_name: 'City'
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it { should belong_to(:ancient_city).class_name('City') }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should belong_to(:ancient_city).class_name('City')
  #     end
  #
  # ##### with_primary_key
  #
  # Use `with_primary_key` to test usage of the `:primary_key` option.
  #
  #     class Person < ActiveRecord::Base
  #       belongs_to :great_country, primary_key: 'country_id'
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it do
  #         should belong_to(:great_country).
  #           with_primary_key('country_id')
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should belong_to(:great_country).
  #         with_primary_key('country_id')
  #     end
  #
  # ##### with_foreign_key
  #
  # Use `with_foreign_key` to test usage of the `:foreign_key` option.
  #
  #     class Person < ActiveRecord::Base
  #       belongs_to :great_country, foreign_key: 'country_id'
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it do
  #         should belong_to(:great_country).
  #           with_foreign_key('country_id')
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should belong_to(:great_country).
  #         with_foreign_key('country_id')
  #     end
  #
  # ##### dependent
  #
  # Use `dependent` to assert that the `:dependent` option was specified.
  #
  #     class Person < ActiveRecord::Base
  #       belongs_to :world, dependent: :destroy
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it { should belong_to(:world).dependent(:destroy) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should belong_to(:world).dependent(:destroy)
  #     end
  #
  # To assert that *any* `:dependent` option was specified, use `true`:
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it { should belong_to(:world).dependent(true) }
  #     end
  #
  # To assert that *no* `:dependent` option was specified, use `false`:
  #
  #     class Person < ActiveRecord::Base
  #       belongs_to :company
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it { should belong_to(:company).dependent(false) }
  #     end
  #
  # ##### counter_cache
  #
  # Use `counter_cache` to assert that the `:counter_cache` option was
  # specified.
  #
  #     class Person < ActiveRecord::Base
  #       belongs_to :organization, counter_cache: true
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it { should belong_to(:organization).counter_cache(true) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should belong_to(:organization).counter_cache(true)
  #     end
  #
  # ##### touch
  #
  # Use `touch` to assert that the `:touch` option was specified.
  #
  #     class Person < ActiveRecord::Base
  #       belongs_to :organization, touch: true
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it { should belong_to(:organization).touch(true) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should belong_to(:organization).touch(true)
  #     end
  #
  # ##### autosave
  #
  # Use `autosave` to assert that the `:autosave` option was specified.
  #
  #     class Account < ActiveRecord::Base
  #       belongs_to :bank, autosave: true
  #     end
  #
  #     # RSpec
  #     RSpec.describe Account, type: :model do
  #       it { should belong_to(:bank).autosave(true) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class AccountTest < ActiveSupport::TestCase
  #       should belong_to(:bank).autosave(true)
  #     end
  #
  # ##### inverse_of
  #
  # Use `inverse_of` to assert that the `:inverse_of` option was specified.
  #
  #     class Person < ActiveRecord::Base
  #       belongs_to :organization, inverse_of: :employees
  #     end
  #
  #     # RSpec
  #     describe Person
  #       it { should belong_to(:organization).inverse_of(:employees) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should belong_to(:organization).inverse_of(:employees)
  #     end
  #
  # ##### required
  #
  # Use `required` to assert that the association is not allowed to be nil.
  # (Enabled by default in Rails 5+.)
  #
  #     class Person < ActiveRecord::Base
  #       belongs_to :organization, required: true
  #     end
  #
  #     # RSpec
  #     describe Person
  #       it { should belong_to(:organization).required }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should belong_to(:organization).required
  #     end
  #
  # ##### without_validating_presence
  #
  # Use `without_validating_presence` with `belong_to` to prevent the
  # matcher from checking whether the association disallows nil (Rails 5+
  # only). This can be helpful if you have a custom hook that always sets
  # the association to a meaningful value:
  #
  #     class Person < ActiveRecord::Base
  #       belongs_to :organization
  #
  #       before_validation :autoassign_organization
  #
  #       private
  #
  #       def autoassign_organization
  #         self.organization = Organization.create!
  #       end
  #     end
  #
  #     # RSpec
  #     describe Person
  #       it { should belong_to(:organization).without_validating_presence }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should belong_to(:organization).without_validating_presence
  #     end
  #
  # ##### optional
  #
  # Use `optional` to assert that the association is allowed to be nil.
  # (Rails 5+ only.)
  #
  #     class Person < ActiveRecord::Base
  #       belongs_to :organization, optional: true
  #     end
  #
  #     # RSpec
  #     describe Person
  #       it { should belong_to(:organization).optional }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should belong_to(:organization).optional
  #     end
  #
  # @return [AssociationMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#325
  def belong_to(name); end

  # The `define_enum_for` matcher is used to test that the `enum` macro has
  # been used to decorate an attribute with enum capabilities.
  #
  #     class Process < ActiveRecord::Base
  #       enum status: [:running, :stopped, :suspended]
  #     end
  #
  #     # RSpec
  #     RSpec.describe Process, type: :model do
  #       it { should define_enum_for(:status) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class ProcessTest < ActiveSupport::TestCase
  #       should define_enum_for(:status)
  #     end
  #
  # #### Qualifiers
  #
  # ##### with_values
  #
  # Use `with_values` to test that the attribute can only receive a certain
  # set of possible values.
  #
  #     class Process < ActiveRecord::Base
  #       enum status: [:running, :stopped, :suspended]
  #     end
  #
  #     # RSpec
  #     RSpec.describe Process, type: :model do
  #       it do
  #         should define_enum_for(:status).
  #           with_values([:running, :stopped, :suspended])
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class ProcessTest < ActiveSupport::TestCase
  #       should define_enum_for(:status).
  #         with_values([:running, :stopped, :suspended])
  #     end
  #
  # If the values backing your enum attribute are arbitrary instead of a
  # series of integers starting from 0, pass a hash to `with_values` instead
  # of an array:
  #
  #     class Process < ActiveRecord::Base
  #       enum status: {
  #         running: 0,
  #         stopped: 1,
  #         suspended: 3,
  #         other: 99
  #       }
  #     end
  #
  #     # RSpec
  #     RSpec.describe Process, type: :model do
  #       it do
  #         should define_enum_for(:status).
  #           with_values(running: 0, stopped: 1, suspended: 3, other: 99)
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class ProcessTest < ActiveSupport::TestCase
  #       should define_enum_for(:status).
  #         with_values(running: 0, stopped: 1, suspended: 3, other: 99)
  #     end
  #
  # ##### backed_by_column_of_type
  #
  # Use `backed_by_column_of_type` when the column backing your column type
  # is a string instead of an integer:
  #
  #     class LoanApplication < ActiveRecord::Base
  #       enum status: {
  #         active: "active",
  #         pending: "pending",
  #         rejected: "rejected"
  #       }
  #     end
  #
  #     # RSpec
  #     RSpec.describe LoanApplication, type: :model do
  #       it do
  #         should define_enum_for(:status).
  #           with_values(
  #             active: "active",
  #             pending: "pending",
  #             rejected: "rejected"
  #           ).
  #           backed_by_column_of_type(:string)
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class LoanApplicationTest < ActiveSupport::TestCase
  #       should define_enum_for(:status).
  #         with_values(
  #           active: "active",
  #           pending: "pending",
  #           rejected: "rejected"
  #         ).
  #         backed_by_column_of_type(:string)
  #     end
  #
  # ##### with_prefix
  #
  # Use `with_prefix` to test that the enum is defined with a `_prefix`
  # option (Rails 5 only). Can take either a boolean or a symbol:
  #
  #     class Issue < ActiveRecord::Base
  #       enum status: [:open, :closed], _prefix: :old
  #     end
  #
  #     # RSpec
  #     RSpec.describe Issue, type: :model do
  #       it do
  #         should define_enum_for(:status).
  #           with_values([:open, :closed]).
  #           with_prefix(:old)
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class ProcessTest < ActiveSupport::TestCase
  #       should define_enum_for(:status).
  #         with_values([:open, :closed]).
  #         with_prefix(:old)
  #     end
  #
  # ##### with_suffix
  #
  # Use `with_suffix` to test that the enum is defined with a `_suffix`
  # option (Rails 5 only). Can take either a boolean or a symbol:
  #
  #     class Issue < ActiveRecord::Base
  #       enum status: [:open, :closed], _suffix: true
  #     end
  #
  #     # RSpec
  #     RSpec.describe Issue, type: :model do
  #       it do
  #         should define_enum_for(:status).
  #           with_values([:open, :closed]).
  #           with_suffix
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class ProcessTest < ActiveSupport::TestCase
  #       should define_enum_for(:status).
  #         with_values([:open, :closed]).
  #         with_suffix
  #     end
  #
  # @return [DefineEnumForMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/define_enum_for_matcher.rb#162
  def define_enum_for(attribute_name); end

  # The `have_and_belong_to_many` matcher is used to test that a
  # `has_and_belongs_to_many` association exists on your model and that the
  # join table exists in the database.
  #
  #     class Person < ActiveRecord::Base
  #       has_and_belongs_to_many :awards
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it { should have_and_belong_to_many(:awards) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should have_and_belong_to_many(:awards)
  #     end
  #
  # #### Qualifiers
  #
  # ##### conditions
  #
  # Use `conditions` if your association is defined with a scope that sets
  # the `where` clause.
  #
  #     class Person < ActiveRecord::Base
  #       has_and_belongs_to_many :issues, -> { where(difficulty: 'hard') }
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it do
  #         should have_and_belong_to_many(:issues).
  #           conditions(difficulty: 'hard')
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should have_and_belong_to_many(:issues).
  #         conditions(difficulty: 'hard')
  #     end
  #
  # ##### order
  #
  # Use `order` if your association is defined with a scope that sets the
  # `order` clause.
  #
  #     class Person < ActiveRecord::Base
  #       has_and_belongs_to_many :projects, -> { order('time_spent') }
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it do
  #         should have_and_belong_to_many(:projects).
  #           order('time_spent')
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should have_and_belong_to_many(:projects).
  #         order('time_spent')
  #     end
  #
  # ##### class_name
  #
  # Use `class_name` to test usage of the `:class_name` option. This
  # asserts that the model you're referring to actually exists.
  #
  #     class Person < ActiveRecord::Base
  #       has_and_belongs_to_many :places_visited, class_name: 'City'
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it do
  #         should have_and_belong_to_many(:places_visited).
  #           class_name('City')
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should have_and_belong_to_many(:places_visited).
  #         class_name('City')
  #     end
  #
  # ##### join_table
  #
  # Use `join_table` to test usage of the `:join_table` option. This
  # asserts that the table you're referring to actually exists.
  #
  #     class Person < ActiveRecord::Base
  #       has_and_belongs_to_many :issues, join_table: :people_tickets
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it do
  #         should have_and_belong_to_many(:issues).
  #           join_table(:people_tickets)
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should have_and_belong_to_many(:issues).
  #         join_table(:people_tickets)
  #     end
  #
  # ##### validate
  #
  # Use `validate` to test that the `:validate` option was specified.
  #
  #     class Person < ActiveRecord::Base
  #       has_and_belongs_to_many :interviews, validate: false
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it do
  #         should have_and_belong_to_many(:interviews).
  #           validate(false)
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should have_and_belong_to_many(:interviews).
  #         validate(false)
  #     end
  #
  # ##### autosave
  #
  # Use `autosave` to assert that the `:autosave` option was specified.
  #
  #     class Publisher < ActiveRecord::Base
  #       has_and_belongs_to_many :advertisers, autosave: true
  #     end
  #
  #     # RSpec
  #     RSpec.describe Publisher, type: :model do
  #       it { should have_and_belong_to_many(:advertisers).autosave(true) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class AccountTest < ActiveSupport::TestCase
  #       should have_and_belong_to_many(:advertisers).autosave(true)
  #     end
  #
  # @return [AssociationMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#982
  def have_and_belong_to_many(name); end

  # The `have_db_column` matcher tests that the table that backs your model
  # has a specific column.
  #
  #     class CreatePhones < ActiveRecord::Migration
  #       def change
  #         create_table :phones do |t|
  #           t.string :supported_ios_version
  #         end
  #       end
  #     end
  #
  #     # RSpec
  #     RSpec.describe Phone, type: :model do
  #       it { should have_db_column(:supported_ios_version) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PhoneTest < ActiveSupport::TestCase
  #       should have_db_column(:supported_ios_version)
  #     end
  #
  # #### Qualifiers
  #
  # ##### of_type
  #
  # Use `of_type` to assert that a column is defined as a certain type.
  #
  #     class CreatePhones < ActiveRecord::Migration
  #       def change
  #         create_table :phones do |t|
  #           t.decimal :camera_aperture
  #         end
  #       end
  #     end
  #
  #     # RSpec
  #     RSpec.describe Phone, type: :model do
  #       it do
  #         should have_db_column(:camera_aperture).of_type(:decimal)
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PhoneTest < ActiveSupport::TestCase
  #       should have_db_column(:camera_aperture).of_type(:decimal)
  #     end
  #
  # ##### with_options
  #
  # Use `with_options` to assert that a column has been defined with
  # certain options (`:precision`, `:limit`, `:default`, `:null`, `:scale`,
  # or `:primary`).
  #
  #     class CreatePhones < ActiveRecord::Migration
  #       def change
  #         create_table :phones do |t|
  #           t.decimal :camera_aperture, precision: 1, null: false
  #         end
  #       end
  #     end
  #
  #     # RSpec
  #     RSpec.describe Phone, type: :model do
  #       it do
  #         should have_db_column(:camera_aperture).
  #           with_options(precision: 1, null: false)
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PhoneTest < ActiveSupport::TestCase
  #       should have_db_column(:camera_aperture).
  #         with_options(precision: 1, null: false)
  #     end
  #
  # @return [HaveDbColumnMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_column_matcher.rb#81
  def have_db_column(column); end

  # The `have_db_index` matcher tests that the table that backs your model
  # has a specific index.
  #
  # You can specify one column:
  #
  #     class CreateBlogs < ActiveRecord::Migration
  #       def change
  #         create_table :blogs do |t|
  #           t.integer :user_id
  #         end
  #
  #         add_index :blogs, :user_id
  #       end
  #     end
  #
  #     # RSpec
  #     RSpec.describe Blog, type: :model do
  #       it { should have_db_index(:user_id) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class BlogTest < ActiveSupport::TestCase
  #       should have_db_index(:user_id)
  #     end
  #
  # Or you can specify a group of columns:
  #
  #     class CreateBlogs < ActiveRecord::Migration
  #       def change
  #         create_table :blogs do |t|
  #           t.integer :user_id
  #           t.string :name
  #         end
  #
  #         add_index :blogs, :user_id, :name
  #       end
  #     end
  #
  #     # RSpec
  #     RSpec.describe Blog, type: :model do
  #       it { should have_db_index([:user_id, :name]) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class BlogTest < ActiveSupport::TestCase
  #       should have_db_index([:user_id, :name])
  #     end
  #
  # Finally, if you're using Rails 5 and PostgreSQL, you can also specify an
  # expression:
  #
  #     class CreateLoggedErrors < ActiveRecord::Migration
  #       def change
  #         create_table :logged_errors do |t|
  #           t.string :code
  #           t.jsonb :content
  #         end
  #
  #         add_index :logged_errors, 'lower(code)::text'
  #       end
  #     end
  #
  #     # RSpec
  #     RSpec.describe LoggedError, type: :model do
  #       it { should have_db_index('lower(code)::text') }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class LoggedErrorTest < ActiveSupport::TestCase
  #       should have_db_index('lower(code)::text')
  #     end
  #
  # #### Qualifiers
  #
  # ##### unique
  #
  # Use `unique` to assert that the index is either unique or non-unique:
  #
  #     class CreateBlogs < ActiveRecord::Migration
  #       def change
  #         create_table :blogs do |t|
  #           t.string :domain
  #           t.integer :user_id
  #         end
  #
  #         add_index :blogs, :domain, unique: true
  #         add_index :blogs, :user_id
  #       end
  #     end
  #
  #     # RSpec
  #     RSpec.describe Blog, type: :model do
  #       it { should have_db_index(:name).unique }
  #       it { should have_db_index(:name).unique(true) }   # if you want to be explicit
  #       it { should have_db_index(:user_id).unique(false) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class BlogTest < ActiveSupport::TestCase
  #       should have_db_index(:name).unique
  #       should have_db_index(:name).unique(true)   # if you want to be explicit
  #       should have_db_index(:user_id).unique(false)
  #     end
  #
  # @return [HaveDbIndexMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_index_matcher.rb#110
  def have_db_index(columns); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_implicit_order_column.rb#24
  def have_implicit_order_column(column_name); end

  # The `have_many` matcher is used to test that a `has_many` or `has_many
  # :through` association exists on your model.
  #
  #     class Person < ActiveRecord::Base
  #       has_many :friends
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it { should have_many(:friends) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should have_many(:friends)
  #     end
  #
  # Note that polymorphic associations are automatically detected and do not
  # need any qualifiers:
  #
  #     class Person < ActiveRecord::Base
  #       has_many :pictures, as: :imageable
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it { should have_many(:pictures) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should have_many(:pictures)
  #     end
  #
  # #### Qualifiers
  #
  # ##### conditions
  #
  # Use `conditions` if your association is defined with a scope that sets
  # the `where` clause.
  #
  #     class Person < ActiveRecord::Base
  #       has_many :coins, -> { where(quality: 'mint') }
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it { should have_many(:coins).conditions(quality: 'mint') }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should have_many(:coins).conditions(quality: 'mint')
  #     end
  #
  # ##### order
  #
  # Use `order` if your association is defined with a scope that sets the
  # `order` clause.
  #
  #     class Person < ActiveRecord::Base
  #       has_many :shirts, -> { order('color') }
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it { should have_many(:shirts).order('color') }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should have_many(:shirts).order('color')
  #     end
  #
  # ##### class_name
  #
  # Use `class_name` to test usage of the `:class_name` option. This
  # asserts that the model you're referring to actually exists.
  #
  #     class Person < ActiveRecord::Base
  #       has_many :hopes, class_name: 'Dream'
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it { should have_many(:hopes).class_name('Dream') }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should have_many(:hopes).class_name('Dream')
  #     end
  #
  # ##### with_primary_key
  #
  # Use `with_primary_key` to test usage of the `:primary_key` option.
  #
  #     class Person < ActiveRecord::Base
  #       has_many :worries, primary_key: 'worrier_id'
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it { should have_many(:worries).with_primary_key('worrier_id') }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should have_many(:worries).with_primary_key('worrier_id')
  #     end
  #
  # ##### with_foreign_key
  #
  # Use `with_foreign_key` to test usage of the `:foreign_key` option.
  #
  #     class Person < ActiveRecord::Base
  #       has_many :worries, foreign_key: 'worrier_id'
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it { should have_many(:worries).with_foreign_key('worrier_id') }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should have_many(:worries).with_foreign_key('worrier_id')
  #     end
  #
  # ##### dependent
  #
  # Use `dependent` to assert that the `:dependent` option was specified.
  #
  #     class Person < ActiveRecord::Base
  #       has_many :secret_documents, dependent: :destroy
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it { should have_many(:secret_documents).dependent(:destroy) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should have_many(:secret_documents).dependent(:destroy)
  #     end
  #
  # ##### through
  #
  # Use `through` to test usage of the `:through` option. This asserts that
  # the association you are going through actually exists.
  #
  #     class Person < ActiveRecord::Base
  #       has_many :acquaintances, through: :friends
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it { should have_many(:acquaintances).through(:friends) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should have_many(:acquaintances).through(:friends)
  #     end
  #
  # ##### source
  #
  # Use `source` to test usage of the `:source` option on a `:through`
  # association.
  #
  #     class Person < ActiveRecord::Base
  #       has_many :job_offers, through: :friends, source: :opportunities
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it do
  #         should have_many(:job_offers).
  #           through(:friends).
  #           source(:opportunities)
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should have_many(:job_offers).
  #         through(:friends).
  #         source(:opportunities)
  #     end
  #
  # ##### validate
  #
  # Use `validate` to assert that the `:validate` option was specified.
  #
  #     class Person < ActiveRecord::Base
  #       has_many :ideas, validate: false
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it { should have_many(:ideas).validate(false) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should have_many(:ideas).validate(false)
  #     end
  #
  # ##### autosave
  #
  # Use `autosave` to assert that the `:autosave` option was specified.
  #
  #     class Player < ActiveRecord::Base
  #       has_many :games, autosave: true
  #     end
  #
  #     # RSpec
  #     RSpec.describe Player, type: :model do
  #       it { should have_many(:games).autosave(true) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PlayerTest < ActiveSupport::TestCase
  #       should have_many(:games).autosave(true)
  #     end
  #
  # ##### index_errors
  #
  # Use `index_errors` to assert that the `:index_errors` option was
  # specified.
  #
  #     class Player < ActiveRecord::Base
  #       has_many :games, index_errors: true
  #     end
  #
  #     # RSpec
  #     RSpec.describe Player, type: :model do
  #       it { should have_many(:games).index_errors(true) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PlayerTest < ActiveSupport::TestCase
  #       should have_many(:games).index_errors(true)
  #     end
  #
  # ##### inverse_of
  #
  # Use `inverse_of` to assert that the `:inverse_of` option was specified.
  #
  #     class Organization < ActiveRecord::Base
  #       has_many :employees, inverse_of: :company
  #     end
  #
  #     # RSpec
  #     describe Organization
  #       it { should have_many(:employees).inverse_of(:company) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class OrganizationTest < ActiveSupport::TestCase
  #       should have_many(:employees).inverse_of(:company)
  #     end
  #
  # @return [AssociationMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#595
  def have_many(name); end

  # The `have_many_attached` matcher tests usage of the
  # `has_many_attached` macro.
  #
  # #### Example
  #
  #     class Message < ApplicationRecord
  #       has_many_attached :images
  #     end
  #
  #     # RSpec
  #     RSpec.describe Message, type: :model do
  #       it { should have_many_attached(:images) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class MessageTest < ActiveSupport::TestCase
  #       should have_many_attached(:images)
  #     end
  #
  # @return [HaveAttachedMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_attached_matcher.rb#50
  def have_many_attached(name); end

  # The `have_one` matcher is used to test that a `has_one` or `has_one
  # :through` association exists on your model.
  #
  #     class Person < ActiveRecord::Base
  #       has_one :partner
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it { should have_one(:partner) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should have_one(:partner)
  #     end
  #
  # #### Qualifiers
  #
  # ##### conditions
  #
  # Use `conditions` if your association is defined with a scope that sets
  # the `where` clause.
  #
  #     class Person < ActiveRecord::Base
  #       has_one :pet, -> { where('weight < 80') }
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it { should have_one(:pet).conditions('weight < 80') }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should have_one(:pet).conditions('weight < 80')
  #     end
  #
  # ##### order
  #
  # Use `order` if your association is defined with a scope that sets the
  # `order` clause.
  #
  #     class Person < ActiveRecord::Base
  #       has_one :focus, -> { order('priority desc') }
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it { should have_one(:focus).order('priority desc') }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should have_one(:focus).order('priority desc')
  #     end
  #
  # ##### class_name
  #
  # Use `class_name` to test usage of the `:class_name` option. This
  # asserts that the model you're referring to actually exists.
  #
  #     class Person < ActiveRecord::Base
  #       has_one :chance, class_name: 'Opportunity'
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it { should have_one(:chance).class_name('Opportunity') }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should have_one(:chance).class_name('Opportunity')
  #     end
  #
  # ##### dependent
  #
  # Use `dependent` to test that the `:dependent` option was specified.
  #
  #     class Person < ActiveRecord::Base
  #       has_one :contract, dependent: :nullify
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it { should have_one(:contract).dependent(:nullify) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should have_one(:contract).dependent(:nullify)
  #     end
  #
  # ##### with_primary_key
  #
  # Use `with_primary_key` to test usage of the `:primary_key` option.
  #
  #     class Person < ActiveRecord::Base
  #       has_one :job, primary_key: 'worker_id'
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it { should have_one(:job).with_primary_key('worker_id') }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should have_one(:job).with_primary_key('worker_id')
  #     end
  #
  # ##### with_foreign_key
  #
  # Use `with_foreign_key` to test usage of the `:foreign_key` option.
  #
  #     class Person < ActiveRecord::Base
  #       has_one :job, foreign_key: 'worker_id'
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it { should have_one(:job).with_foreign_key('worker_id') }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should have_one(:job).with_foreign_key('worker_id')
  #     end
  #
  # ##### through
  #
  # Use `through` to test usage of the `:through` option. This asserts that
  # the association you are going through actually exists.
  #
  #     class Person < ActiveRecord::Base
  #       has_one :life, through: :partner
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it { should have_one(:life).through(:partner) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should have_one(:life).through(:partner)
  #     end
  #
  # ##### source
  #
  # Use `source` to test usage of the `:source` option on a `:through`
  # association.
  #
  #     class Person < ActiveRecord::Base
  #       has_one :car, through: :partner, source: :vehicle
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it { should have_one(:car).through(:partner).source(:vehicle) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should have_one(:car).through(:partner).source(:vehicle)
  #     end
  #
  # ##### validate
  #
  # Use `validate` to assert that the the `:validate` option was specified.
  #
  #     class Person < ActiveRecord::Base
  #       has_one :parking_card, validate: false
  #     end
  #
  #     # RSpec
  #     RSpec.describe Person, type: :model do
  #       it { should have_one(:parking_card).validate(false) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should have_one(:parking_card).validate(false)
  #     end
  #
  # ##### autosave
  #
  # Use `autosave` to assert that the `:autosave` option was specified.
  #
  #     class Account < ActiveRecord::Base
  #       has_one :bank, autosave: true
  #     end
  #
  #     # RSpec
  #     RSpec.describe Account, type: :model do
  #       it { should have_one(:bank).autosave(true) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class AccountTest < ActiveSupport::TestCase
  #       should have_one(:bank).autosave(true)
  #     end
  #
  # ##### required
  #
  # Use `required` to assert that the association is not allowed to be nil.
  # (Rails 5+ only.)
  #
  #     class Person < ActiveRecord::Base
  #       has_one :brain, required: true
  #     end
  #
  #     # RSpec
  #     describe Person
  #       it { should have_one(:brain).required }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PersonTest < ActiveSupport::TestCase
  #       should have_one(:brain).required
  #     end
  #
  # @return [AssociationMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#824
  def have_one(name); end

  # The `have_one_attached` matcher tests usage of the
  # `has_one_attached` macro.
  #
  # #### Example
  #
  #     class User < ApplicationRecord
  #       has_one_attached :avatar
  #     end
  #
  #     # RSpec
  #     RSpec.describe User, type: :model do
  #       it { should have_one_attached(:avatar) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class UserTest < ActiveSupport::TestCase
  #       should have_one_attached(:avatar)
  #     end
  #
  # @return [HaveAttachedMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_attached_matcher.rb#25
  def have_one_attached(name); end

  # The `have_readonly_attribute` matcher tests usage of the
  # `attr_readonly` macro.
  #
  #     class User < ActiveRecord::Base
  #       attr_readonly :password
  #     end
  #
  #     # RSpec
  #     RSpec.describe User, type: :model do
  #       it { should have_readonly_attribute(:password) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class UserTest < ActiveSupport::TestCase
  #       should have_readonly_attribute(:password)
  #     end
  #
  # @return [HaveReadonlyAttributeMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_readonly_attribute_matcher.rb#23
  def have_readonly_attribute(value); end

  # The `have_rich_text` matcher tests usage of the
  # `has_rich_text` macro.
  #
  # #### Example
  #
  #     class Post < ActiveRecord
  #       has_rich_text :content
  #     end
  #
  #     # RSpec
  #     RSpec.describe Post, type: :model do
  #       it { should have_rich_text(:content) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PostTest < ActiveSupport::TestCase
  #       should have_rich_text(:content)
  #     end
  #
  # @return [HaveRichTextMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_rich_text_matcher.rb#25
  def have_rich_text(rich_text_attribute); end

  # The `have_secure_token` matcher tests usage of the
  # `has_secure_token` macro.
  #
  #     class User < ActiveRecord
  #       has_secure_token
  #       has_secure_token :auth_token
  #     end
  #
  #     # RSpec
  #     RSpec.describe User, type: :model do
  #       it { should have_secure_token }
  #       it { should have_secure_token(:auth_token) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class UserTest < ActiveSupport::TestCase
  #       should have_secure_token
  #       should have_secure_token(:auth_token)
  #     end
  #
  # #### Qualifiers
  #
  # ##### ignoring_check_for_db_index
  #
  # By default, this matcher tests that an index is defined on your token
  # column. Use `ignoring_check_for_db_index` if this is not the case.
  #
  #     class User < ActiveRecord
  #       has_secure_token :auth_token
  #     end
  #
  #     # RSpec
  #     RSpec.describe User, type: :model do
  #       it { should have_secure_token(:auth_token).ignoring_check_for_db_index }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class UserTest < ActiveSupport::TestCase
  #       should have_secure_token(:auth_token).ignoring_check_for_db_index
  #     end
  #
  # @return [HaveSecureToken]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_secure_token_matcher.rb#47
  def have_secure_token(token_attribute = T.unsafe(nil)); end

  # The `serialize` matcher tests usage of the `serialize` macro.
  #
  #     class Product < ActiveRecord::Base
  #       serialize :customizations
  #     end
  #
  #     # RSpec
  #     RSpec.describe Product, type: :model do
  #       it { should serialize(:customizations) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class ProductTest < ActiveSupport::TestCase
  #       should serialize(:customizations)
  #     end
  #
  # #### Qualifiers
  #
  # ##### as
  #
  # Use `as` if you are using a custom serializer class.
  #
  #     class ProductSpecsSerializer
  #       def load(string)
  #         # ...
  #       end
  #
  #       def dump(options)
  #         # ...
  #       end
  #     end
  #
  #     class Product < ActiveRecord::Base
  #       serialize :specifications, ProductSpecsSerializer
  #     end
  #
  #     # RSpec
  #     RSpec.describe Product, type: :model do
  #       it do
  #         should serialize(:specifications).
  #           as(ProductSpecsSerializer)
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class ProductTest < ActiveSupport::TestCase
  #       should serialize(:specifications).
  #         as(ProductSpecsSerializer)
  #     end
  #
  # ##### as_instance_of
  #
  # Use `as_instance_of` if you are using a custom serializer object.
  #
  #     class ProductOptionsSerializer
  #       def load(string)
  #         # ...
  #       end
  #
  #       def dump(options)
  #         # ...
  #       end
  #     end
  #
  #     class Product < ActiveRecord::Base
  #       serialize :options, ProductOptionsSerializer.new
  #     end
  #
  #     # RSpec
  #     RSpec.describe Product, type: :model do
  #       it do
  #         should serialize(:options).
  #           as_instance_of(ProductOptionsSerializer)
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class ProductTest < ActiveSupport::TestCase
  #       should serialize(:options).
  #         as_instance_of(ProductOptionsSerializer)
  #     end
  #
  # @return [SerializeMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/serialize_matcher.rb#88
  def serialize(name); end

  # The `validate_uniqueness_of` matcher tests usage of the
  # `validates_uniqueness_of` validation. It first checks for an existing
  # instance of your model in the database, creating one if necessary. It
  # then takes a new instance of that model and asserts that it fails
  # validation if the attribute or attributes you've specified in the
  # validation are set to values which are the same as those of the
  # pre-existing record (thereby failing the uniqueness check).
  #
  #     class Post < ActiveRecord::Base
  #       validates :permalink, uniqueness: true
  #     end
  #
  #     # RSpec
  #     RSpec.describe Post, type: :model do
  #       it { should validate_uniqueness_of(:permalink) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PostTest < ActiveSupport::TestCase
  #       should validate_uniqueness_of(:permalink)
  #     end
  #
  # #### Caveat
  #
  # This matcher works a bit differently than other matchers. As noted
  # before, it will create an instance of your model if one doesn't already
  # exist. Sometimes this step fails, especially if you have database-level
  # restrictions on any attributes other than the one which is unique. In
  # this case, the solution is to populate these attributes with values
  # before you call `validate_uniqueness_of`.
  #
  # For example, say you have the following migration and model:
  #
  #     class CreatePosts < ActiveRecord::Migration
  #       def change
  #         create_table :posts do |t|
  #           t.string :title
  #           t.text :content, null: false
  #         end
  #       end
  #     end
  #
  #     class Post < ActiveRecord::Base
  #       validates :title, uniqueness: true
  #     end
  #
  # You may be tempted to test the model like this:
  #
  #     RSpec.describe Post, type: :model do
  #       it { should validate_uniqueness_of(:title) }
  #     end
  #
  # However, running this test will fail with an exception such as:
  #
  #     Shoulda::Matchers::ActiveRecord::ValidateUniquenessOfMatcher::ExistingRecordInvalid:
  #       validate_uniqueness_of works by matching a new record against an
  #       existing record. If there is no existing record, it will create one
  #       using the record you provide.
  #
  #       While doing this, the following error was raised:
  #
  #         PG::NotNullViolation: ERROR:  null value in column "content" violates not-null constraint
  #         DETAIL:  Failing row contains (1, null, null).
  #         : INSERT INTO "posts" DEFAULT VALUES RETURNING "id"
  #
  #       The best way to fix this is to provide the matcher with a record where
  #       any required attributes are filled in with valid values beforehand.
  #
  # (The exact error message will differ depending on which database you're
  # using, but you get the idea.)
  #
  # This happens because `validate_uniqueness_of` tries to create a new post
  # but cannot do so because of the `content` attribute: though unrelated to
  # this test, it nevertheless needs to be filled in. As indicated at the
  # end of the error message, the solution is to build a custom Post object
  # ahead of time with `content` filled in:
  #
  #     RSpec.describe Post, type: :model do
  #       describe "validations" do
  #         subject { Post.new(content: "Here is the content") }
  #         it { should validate_uniqueness_of(:title) }
  #       end
  #     end
  #
  # Or, if you're using
  # [FactoryBot](https://github.com/thoughtbot/factory_bot) and you have a
  # `post` factory defined which automatically fills in `content`, you can
  # say:
  #
  #     RSpec.describe Post, type: :model do
  #       describe "validations" do
  #         subject { FactoryBot.build(:post) }
  #         it { should validate_uniqueness_of(:title) }
  #       end
  #     end
  #
  # #### Qualifiers
  #
  # Use `on` if your validation applies only under a certain context.
  #
  #     class Post < ActiveRecord::Base
  #       validates :title, uniqueness: true, on: :create
  #     end
  #
  #     # RSpec
  #     RSpec.describe Post, type: :model do
  #       it { should validate_uniqueness_of(:title).on(:create) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PostTest < ActiveSupport::TestCase
  #       should validate_uniqueness_of(:title).on(:create)
  #     end
  #
  # ##### with_message
  #
  # Use `with_message` if you are using a custom validation message.
  #
  #     class Post < ActiveRecord::Base
  #       validates :title, uniqueness: true, message: 'Please choose another title'
  #     end
  #
  #     # RSpec
  #     RSpec.describe Post, type: :model do
  #       it do
  #         should validate_uniqueness_of(:title).
  #           with_message('Please choose another title')
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PostTest < ActiveSupport::TestCase
  #       should validate_uniqueness_of(:title).
  #         with_message('Please choose another title')
  #     end
  #
  # ##### scoped_to
  #
  # Use `scoped_to` to test usage of the `:scope` option. This asserts that
  # a new record fails validation if not only the primary attribute is not
  # unique, but the scoped attributes are not unique either.
  #
  #     class Post < ActiveRecord::Base
  #       validates :slug, uniqueness: { scope: :journal_id }
  #     end
  #
  #     # RSpec
  #     RSpec.describe Post, type: :model do
  #       it { should validate_uniqueness_of(:slug).scoped_to(:journal_id) }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PostTest < ActiveSupport::TestCase
  #       should validate_uniqueness_of(:slug).scoped_to(:journal_id)
  #     end
  #
  # NOTE: Support for testing uniqueness validation scoped to an array of
  # associations is not available.
  #
  # For more information, please refer to
  # https://github.com/thoughtbot/shoulda-matchers/issues/814
  #
  # ##### case_insensitive
  #
  # Use `case_insensitive` to test usage of the `:case_sensitive` option
  # with a false value. This asserts that the uniquable attributes fail
  # validation even if their values are a different case than corresponding
  # attributes in the pre-existing record.
  #
  #     class Post < ActiveRecord::Base
  #       validates :key, uniqueness: { case_sensitive: false }
  #     end
  #
  #     # RSpec
  #     RSpec.describe Post, type: :model do
  #       it { should validate_uniqueness_of(:key).case_insensitive }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PostTest < ActiveSupport::TestCase
  #       should validate_uniqueness_of(:key).case_insensitive
  #     end
  #
  # ##### ignoring_case_sensitivity
  #
  # By default, `validate_uniqueness_of` will check that the
  # validation is case sensitive: it asserts that uniquable attributes pass
  # validation when their values are in a different case than corresponding
  # attributes in the pre-existing record.
  #
  # Use `ignoring_case_sensitivity` to skip this check. This qualifier is
  # particularly handy if your model has somehow changed the behavior of
  # attribute you're testing so that it modifies the case of incoming values
  # as they are set. For instance, perhaps you've overridden the writer
  # method or added a `before_validation` callback to normalize the
  # attribute.
  #
  #     class User < ActiveRecord::Base
  #       validates :email, uniqueness: true
  #
  #       def email=(value)
  #         super(value.downcase)
  #       end
  #     end
  #
  #     # RSpec
  #     RSpec.describe Post, type: :model do
  #       it do
  #         should validate_uniqueness_of(:email).ignoring_case_sensitivity
  #       end
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PostTest < ActiveSupport::TestCase
  #       should validate_uniqueness_of(:email).ignoring_case_sensitivity
  #     end
  #
  # ##### allow_nil
  #
  # Use `allow_nil` to assert that the attribute allows nil.
  #
  #     class Post < ActiveRecord::Base
  #       validates :author_id, uniqueness: true, allow_nil: true
  #     end
  #
  #     # RSpec
  #     RSpec.describe Post, type: :model do
  #       it { should validate_uniqueness_of(:author_id).allow_nil }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PostTest < ActiveSupport::TestCase
  #       should validate_uniqueness_of(:author_id).allow_nil
  #     end
  #
  # ##### allow_blank
  #
  # Use `allow_blank` to assert that the attribute allows a blank value.
  #
  #     class Post < ActiveRecord::Base
  #       validates :author_id, uniqueness: true, allow_blank: true
  #     end
  #
  #     # RSpec
  #     RSpec.describe Post, type: :model do
  #       it { should validate_uniqueness_of(:author_id).allow_blank }
  #     end
  #
  #     # Minitest (Shoulda)
  #     class PostTest < ActiveSupport::TestCase
  #       should validate_uniqueness_of(:author_id).allow_blank
  #     end
  #
  # @return [ValidateUniquenessOfMatcher]
  # @return [ValidateUniquenessOfMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#261
  def validate_uniqueness_of(attr); end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_record/accept_nested_attributes_for_matcher.rb#98
class Shoulda::Matchers::ActiveRecord::AcceptNestedAttributesForMatcher
  # @return [AcceptNestedAttributesForMatcher] a new instance of AcceptNestedAttributesForMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/accept_nested_attributes_for_matcher.rb#99
  def initialize(name); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/accept_nested_attributes_for_matcher.rb#104
  def allow_destroy(allow_destroy); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/accept_nested_attributes_for_matcher.rb#135
  def description; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/accept_nested_attributes_for_matcher.rb#127
  def failure_message; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/accept_nested_attributes_for_matcher.rb#131
  def failure_message_when_negated; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/accept_nested_attributes_for_matcher.rb#109
  def limit(limit); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/accept_nested_attributes_for_matcher.rb#119
  def matches?(subject); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/accept_nested_attributes_for_matcher.rb#114
  def update_only(update_only); end

  protected

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/accept_nested_attributes_for_matcher.rb#160
  def allow_destroy_correct?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/accept_nested_attributes_for_matcher.rb#191
  def config; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/accept_nested_attributes_for_matcher.rb#151
  def exists?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/accept_nested_attributes_for_matcher.rb#203
  def expectation; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/accept_nested_attributes_for_matcher.rb#166
  def limit_correct?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/accept_nested_attributes_for_matcher.rb#199
  def model_class; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/accept_nested_attributes_for_matcher.rb#195
  def model_config; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/accept_nested_attributes_for_matcher.rb#207
  def should_or_should_not(value); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/accept_nested_attributes_for_matcher.rb#172
  def update_only_correct?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/accept_nested_attributes_for_matcher.rb#178
  def verify_option_is_correct(option, failure_message); end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#987
class Shoulda::Matchers::ActiveRecord::AssociationMatcher
  # @return [AssociationMatcher] a new instance of AssociationMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1000
  def initialize(macro, name); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#995
  def associated_class(*_arg0, **_arg1, &_arg2); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1071
  def autosave(autosave); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1081
  def class_name(class_name); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1066
  def conditions(conditions); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1039
  def counter_cache(counter_cache = T.unsafe(nil)); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1021
  def dependent(dependent); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1136
  def description; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1144
  def failure_message; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1148
  def failure_message_when_negated; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1076
  def index_errors(index_errors); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1048
  def inverse_of(inverse_of); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1126
  def join_table(join_table_name); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1170
  def join_table_name; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1152
  def matches?(subject); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#995
  def model_class(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute name.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#998
  def name; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1174
  def option_verifier; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1106
  def optional(optional = T.unsafe(nil)); end

  # Returns the value of attribute options.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#998
  def options; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1030
  def order(order); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#995
  def polymorphic?(*_arg0, **_arg1, &_arg2); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#995
  def reflection(*_arg0, **_arg1, &_arg2); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1096
  def required(required = T.unsafe(nil)); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1057
  def source(source); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1012
  def through(through); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#995
  def through?(*_arg0, **_arg1, &_arg2); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1121
  def touch(touch = T.unsafe(nil)); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1116
  def validate(validate = T.unsafe(nil)); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1086
  def with_foreign_key(foreign_key); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1091
  def with_primary_key(primary_key); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1131
  def without_validating_presence; end

  protected

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1187
  def add_submatcher(matcher_class, *args); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1232
  def association_exists?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1328
  def autosave_correct?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1274
  def belongs_foreign_key_missing?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1485
  def belongs_to_required_by_default?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1320
  def class_exists?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1396
  def class_has_foreign_key?(klass); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1284
  def class_name_correct?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1479
  def column_names_for(klass); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1361
  def conditions_correct?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1202
  def expectation; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1218
  def failing_submatchers; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1445
  def foreign_key; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1417
  def foreign_key_correct?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1266
  def foreign_key_exists?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1424
  def foreign_key_failure_message(klass, foreign_key); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1461
  def foreign_key_reflection; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1408
  def has_column?(klass, column); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1278
  def has_foreign_key_missing?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1345
  def index_errors_correct?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1301
  def join_table_correct?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1313
  def join_table_matcher; end

  # Returns the value of attribute macro.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1181
  def macro; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1241
  def macro_correct?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1198
  def macro_description; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1261
  def macro_supports_primary_key?; end

  # Returns the value of attribute missing.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1181
  def missing; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1213
  def missing_options; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1224
  def missing_options_for_failing_submatchers; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1428
  def primary_key_correct?(klass); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1270
  def primary_key_exists?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1183
  def reflector; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1192
  def remove_submatcher(matcher_class); end

  # Returns the value of attribute subject.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1181
  def subject; end

  # Returns the value of attribute submatchers.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1181
  def submatchers; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1475
  def submatchers_match?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1387
  def touch_correct?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1378
  def validate_correct?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#1253
  def validate_inverse_of_through_association; end
end

# source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matcher.rb#988
Shoulda::Matchers::ActiveRecord::AssociationMatcher::MACROS = T.let(T.unsafe(nil), Hash)

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers.rb#5
module Shoulda::Matchers::ActiveRecord::AssociationMatchers; end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/counter_cache_matcher.rb#6
class Shoulda::Matchers::ActiveRecord::AssociationMatchers::CounterCacheMatcher
  # @return [CounterCacheMatcher] a new instance of CounterCacheMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/counter_cache_matcher.rb#9
  def initialize(counter_cache, name); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/counter_cache_matcher.rb#15
  def description; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/counter_cache_matcher.rb#19
  def matches?(subject); end

  # Returns the value of attribute missing_option.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/counter_cache_matcher.rb#7
  def missing_option; end

  # Sets the attribute missing_option
  #
  # @param value the value to set the attribute missing_option to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/counter_cache_matcher.rb#7
  def missing_option=(_arg0); end

  protected

  # Returns the value of attribute counter_cache.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/counter_cache_matcher.rb#35
  def counter_cache; end

  # Sets the attribute counter_cache
  #
  # @param value the value to set the attribute counter_cache to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/counter_cache_matcher.rb#35
  def counter_cache=(_arg0); end

  # Returns the value of attribute name.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/counter_cache_matcher.rb#35
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/counter_cache_matcher.rb#35
  def name=(_arg0); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/counter_cache_matcher.rb#37
  def option_verifier; end

  # Returns the value of attribute subject.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/counter_cache_matcher.rb#35
  def subject; end

  # Sets the attribute subject
  #
  # @param value the value to set the attribute subject to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/counter_cache_matcher.rb#35
  def subject=(_arg0); end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/dependent_matcher.rb#6
class Shoulda::Matchers::ActiveRecord::AssociationMatchers::DependentMatcher
  # @return [DependentMatcher] a new instance of DependentMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/dependent_matcher.rb#9
  def initialize(dependent, name); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/dependent_matcher.rb#15
  def description; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/dependent_matcher.rb#19
  def matches?(subject); end

  # Returns the value of attribute missing_option.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/dependent_matcher.rb#7
  def missing_option; end

  # Sets the attribute missing_option
  #
  # @param value the value to set the attribute missing_option to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/dependent_matcher.rb#7
  def missing_option=(_arg0); end

  protected

  # Returns the value of attribute dependent.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/dependent_matcher.rb#32
  def dependent; end

  # Sets the attribute dependent
  #
  # @param value the value to set the attribute dependent to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/dependent_matcher.rb#32
  def dependent=(_arg0); end

  # Returns the value of attribute name.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/dependent_matcher.rb#32
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/dependent_matcher.rb#32
  def name=(_arg0); end

  # Returns the value of attribute subject.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/dependent_matcher.rb#32
  def subject; end

  # Sets the attribute subject
  #
  # @param value the value to set the attribute subject to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/dependent_matcher.rb#32
  def subject=(_arg0); end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/dependent_matcher.rb#51
  def generate_missing_option; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/dependent_matcher.rb#40
  def option_matches?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/dependent_matcher.rb#44
  def option_type; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/dependent_matcher.rb#36
  def option_verifier; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/inverse_of_matcher.rb#6
class Shoulda::Matchers::ActiveRecord::AssociationMatchers::InverseOfMatcher
  # @return [InverseOfMatcher] a new instance of InverseOfMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/inverse_of_matcher.rb#9
  def initialize(inverse_of, name); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/inverse_of_matcher.rb#15
  def description; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/inverse_of_matcher.rb#19
  def matches?(subject); end

  # Returns the value of attribute missing_option.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/inverse_of_matcher.rb#7
  def missing_option; end

  # Sets the attribute missing_option
  #
  # @param value the value to set the attribute missing_option to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/inverse_of_matcher.rb#7
  def missing_option=(_arg0); end

  protected

  # Returns the value of attribute inverse_of.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/inverse_of_matcher.rb#32
  def inverse_of; end

  # Sets the attribute inverse_of
  #
  # @param value the value to set the attribute inverse_of to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/inverse_of_matcher.rb#32
  def inverse_of=(_arg0); end

  # Returns the value of attribute name.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/inverse_of_matcher.rb#32
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/inverse_of_matcher.rb#32
  def name=(_arg0); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/inverse_of_matcher.rb#34
  def option_verifier; end

  # Returns the value of attribute subject.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/inverse_of_matcher.rb#32
  def subject; end

  # Sets the attribute subject
  #
  # @param value the value to set the attribute subject to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/inverse_of_matcher.rb#32
  def subject=(_arg0); end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/join_table_matcher.rb#6
class Shoulda::Matchers::ActiveRecord::AssociationMatchers::JoinTableMatcher
  # @return [JoinTableMatcher] a new instance of JoinTableMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/join_table_matcher.rb#16
  def initialize(association_matcher, reflector); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/join_table_matcher.rb#11
  def associated_class(*_arg0, **_arg1, &_arg2); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/join_table_matcher.rb#69
  def association_foreign_key(*_arg0, **_arg1, &_arg2); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/join_table_matcher.rb#14
  def connection(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute failure_message.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/join_table_matcher.rb#7
  def failure_message; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/join_table_matcher.rb#69
  def foreign_key(*_arg0, **_arg1, &_arg2); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/join_table_matcher.rb#44
  def join_table_exists?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/join_table_matcher.rb#54
  def join_table_has_correct_columns?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/join_table_matcher.rb#11
  def join_table_name(*_arg0, **_arg1, &_arg2); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/join_table_matcher.rb#27
  def join_table_option_correct?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/join_table_matcher.rb#21
  def matches?(_subject); end

  # Returns the value of attribute failure_message.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/join_table_matcher.rb#7
  def missing_option; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/join_table_matcher.rb#11
  def model_class(*_arg0, **_arg1, &_arg2); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/join_table_matcher.rb#11
  def name(*_arg0, **_arg1, &_arg2); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/join_table_matcher.rb#11
  def option_verifier(*_arg0, **_arg1, &_arg2); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/join_table_matcher.rb#11
  def options(*_arg0, **_arg1, &_arg2); end

  protected

  # Returns the value of attribute association_matcher.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/join_table_matcher.rb#65
  def association_matcher; end

  # Returns the value of attribute reflector.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/join_table_matcher.rb#65
  def reflector; end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/join_table_matcher.rb#81
  def actual_join_table_columns; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/join_table_matcher.rb#94
  def column_label; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/join_table_matcher.rb#77
  def expected_join_table_columns; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/join_table_matcher.rb#71
  def missing_columns; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/join_table_matcher.rb#89
  def missing_columns_message; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/join_table_matcher.rb#85
  def missing_table_message; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/model_reflection.rb#8
class Shoulda::Matchers::ActiveRecord::AssociationMatchers::ModelReflection < ::SimpleDelegator
  # @return [ModelReflection] a new instance of ModelReflection
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/model_reflection.rb#9
  def initialize(reflection); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/model_reflection.rb#15
  def associated_class; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/model_reflection.rb#54
  def association_foreign_key; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/model_reflection.rb#33
  def association_relation(related_instance); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/model_reflection.rb#44
  def foreign_key; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/model_reflection.rb#69
  def has_and_belongs_to_many_name; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/model_reflection.rb#27
  def join_table_name; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/model_reflection.rb#19
  def polymorphic?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/model_reflection.rb#23
  def through?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/model_reflection.rb#63
  def validate_inverse_of_through_association!; end

  protected

  # Returns the value of attribute reflection.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/model_reflection.rb#75
  def reflection; end

  # Returns the value of attribute subject.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/model_reflection.rb#75
  def subject; end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/model_reflection.rb#79
  def has_and_belongs_to_many_name_table_name; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/model_reflection.rb#83
  def has_and_belongs_to_many_reflection; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/model_reflector.rb#6
class Shoulda::Matchers::ActiveRecord::AssociationMatchers::ModelReflector
  # @return [ModelReflector] a new instance of ModelReflector
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/model_reflector.rb#24
  def initialize(subject, name); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/model_reflector.rb#7
  def associated_class(*_arg0, **_arg1, &_arg2); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/model_reflector.rb#7
  def association_foreign_key(*_arg0, **_arg1, &_arg2); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/model_reflector.rb#29
  def association_relation; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/model_reflector.rb#49
  def build_relation_with_clause(name, value); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/model_reflector.rb#60
  def extract_relation_clause_from(relation, name); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/model_reflector.rb#7
  def foreign_key(*_arg0, **_arg1, &_arg2); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/model_reflector.rb#7
  def has_and_belongs_to_many_name(*_arg0, **_arg1, &_arg2); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/model_reflector.rb#7
  def join_table_name(*_arg0, **_arg1, &_arg2); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/model_reflector.rb#45
  def model_class; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/model_reflector.rb#7
  def polymorphic?(*_arg0, **_arg1, &_arg2); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/model_reflector.rb#37
  def reflect_on_association(name); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/model_reflector.rb#33
  def reflection; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/model_reflector.rb#18
  def through?(*_arg0, **_arg1, &_arg2); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/model_reflector.rb#7
  def validate_inverse_of_through_association!(*_arg0, **_arg1, &_arg2); end

  protected

  # Returns the value of attribute name.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/model_reflector.rb#75
  def name; end

  # Returns the value of attribute subject.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/model_reflector.rb#75
  def subject; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/model_reflector.rb#77
  def value_as_sql(value); end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/option_verifier.rb#6
class Shoulda::Matchers::ActiveRecord::AssociationMatchers::OptionVerifier
  # @return [OptionVerifier] a new instance of OptionVerifier
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/option_verifier.rb#16
  def initialize(reflector); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/option_verifier.rb#55
  def actual_value_for(name); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/option_verifier.rb#40
  def correct_for?(*args); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/option_verifier.rb#24
  def correct_for_boolean?(name, expected_value); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/option_verifier.rb#32
  def correct_for_constant?(name, expected_unresolved_value); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/option_verifier.rb#28
  def correct_for_hash?(name, expected_value); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/option_verifier.rb#36
  def correct_for_relation_clause?(name, expected_value); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/option_verifier.rb#20
  def correct_for_string?(name, expected_value); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/option_verifier.rb#7
  def reflection(*_arg0, **_arg1, &_arg2); end

  protected

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/option_verifier.rb#121
  def actual_value_for_class_name; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/option_verifier.rb#125
  def actual_value_for_option(name); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/option_verifier.rb#114
  def actual_value_for_relation_clause(name); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/option_verifier.rb#85
  def expected_value_for(type, name, value); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/option_verifier.rb#100
  def expected_value_for_constant(name); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/option_verifier.rb#95
  def expected_value_for_relation_clause(name, value); end

  # Returns the value of attribute reflector.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/option_verifier.rb#70
  def reflector; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/option_verifier.rb#72
  def type_cast(type, value); end
end

# source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/option_verifier.rb#9
Shoulda::Matchers::ActiveRecord::AssociationMatchers::OptionVerifier::DEFAULT_VALUE_OF_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/option_verifier.rb#14
Shoulda::Matchers::ActiveRecord::AssociationMatchers::OptionVerifier::RELATION_OPTIONS = T.let(T.unsafe(nil), Array)

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/optional_matcher.rb#6
class Shoulda::Matchers::ActiveRecord::AssociationMatchers::OptionalMatcher
  # @return [OptionalMatcher] a new instance of OptionalMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/optional_matcher.rb#9
  def initialize(attribute_name, optional); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/optional_matcher.rb#17
  def description; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/optional_matcher.rb#21
  def matches?(subject); end

  # Returns the value of attribute missing_option.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/optional_matcher.rb#7
  def missing_option; end

  private

  # Returns the value of attribute attribute_name.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/optional_matcher.rb#56
  def attribute_name; end

  # Returns the value of attribute optional.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/optional_matcher.rb#56
  def optional; end

  # Returns the value of attribute submatcher.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/optional_matcher.rb#56
  def submatcher; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/optional_matcher.rb#58
  def submatcher_passes?(subject); end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/order_matcher.rb#6
class Shoulda::Matchers::ActiveRecord::AssociationMatchers::OrderMatcher
  # @return [OrderMatcher] a new instance of OrderMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/order_matcher.rb#9
  def initialize(order, name); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/order_matcher.rb#15
  def description; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/order_matcher.rb#19
  def matches?(subject); end

  # Returns the value of attribute missing_option.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/order_matcher.rb#7
  def missing_option; end

  # Sets the attribute missing_option
  #
  # @param value the value to set the attribute missing_option to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/order_matcher.rb#7
  def missing_option=(_arg0); end

  protected

  # Returns the value of attribute name.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/order_matcher.rb#32
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/order_matcher.rb#32
  def name=(_arg0); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/order_matcher.rb#34
  def option_verifier; end

  # Returns the value of attribute order.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/order_matcher.rb#32
  def order; end

  # Sets the attribute order
  #
  # @param value the value to set the attribute order to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/order_matcher.rb#32
  def order=(_arg0); end

  # Returns the value of attribute subject.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/order_matcher.rb#32
  def subject; end

  # Sets the attribute subject
  #
  # @param value the value to set the attribute subject to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/order_matcher.rb#32
  def subject=(_arg0); end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/required_matcher.rb#6
class Shoulda::Matchers::ActiveRecord::AssociationMatchers::RequiredMatcher
  # @return [RequiredMatcher] a new instance of RequiredMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/required_matcher.rb#9
  def initialize(attribute_name, required); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/required_matcher.rb#18
  def description; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/required_matcher.rb#22
  def matches?(subject); end

  # Returns the value of attribute missing_option.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/required_matcher.rb#7
  def missing_option; end

  private

  # Returns the value of attribute attribute_name.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/required_matcher.rb#57
  def attribute_name; end

  # Returns the value of attribute required.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/required_matcher.rb#57
  def required; end

  # Returns the value of attribute submatcher.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/required_matcher.rb#57
  def submatcher; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/required_matcher.rb#59
  def submatcher_passes?(subject); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/required_matcher.rb#67
  def validation_message_key; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/source_matcher.rb#6
class Shoulda::Matchers::ActiveRecord::AssociationMatchers::SourceMatcher
  # @return [SourceMatcher] a new instance of SourceMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/source_matcher.rb#9
  def initialize(source, name); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/source_matcher.rb#15
  def description; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/source_matcher.rb#19
  def matches?(subject); end

  # Returns the value of attribute missing_option.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/source_matcher.rb#7
  def missing_option; end

  # Sets the attribute missing_option
  #
  # @param value the value to set the attribute missing_option to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/source_matcher.rb#7
  def missing_option=(_arg0); end

  protected

  # Returns the value of attribute name.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/source_matcher.rb#33
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/source_matcher.rb#33
  def name=(_arg0); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/source_matcher.rb#35
  def option_verifier; end

  # Returns the value of attribute source.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/source_matcher.rb#33
  def source; end

  # Sets the attribute source
  #
  # @param value the value to set the attribute source to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/source_matcher.rb#33
  def source=(_arg0); end

  # Returns the value of attribute subject.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/source_matcher.rb#33
  def subject; end

  # Sets the attribute subject
  #
  # @param value the value to set the attribute subject to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/source_matcher.rb#33
  def subject=(_arg0); end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/through_matcher.rb#6
class Shoulda::Matchers::ActiveRecord::AssociationMatchers::ThroughMatcher
  # @return [ThroughMatcher] a new instance of ThroughMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/through_matcher.rb#9
  def initialize(through, name); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/through_matcher.rb#24
  def association_set_properly?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/through_matcher.rb#15
  def description; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/through_matcher.rb#19
  def matches?(subject); end

  # Returns the value of attribute missing_option.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/through_matcher.rb#7
  def missing_option; end

  # Sets the attribute missing_option
  #
  # @param value the value to set the attribute missing_option to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/through_matcher.rb#7
  def missing_option=(_arg0); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/through_matcher.rb#42
  def through_association_correct?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/through_matcher.rb#28
  def through_association_exists?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/through_matcher.rb#38
  def through_reflection; end

  protected

  # Returns the value of attribute name.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/through_matcher.rb#56
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/through_matcher.rb#56
  def name=(_arg0); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/through_matcher.rb#58
  def option_verifier; end

  # Returns the value of attribute subject.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/through_matcher.rb#56
  def subject; end

  # Sets the attribute subject
  #
  # @param value the value to set the attribute subject to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/through_matcher.rb#56
  def subject=(_arg0); end

  # Returns the value of attribute through.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/through_matcher.rb#56
  def through; end

  # Sets the attribute through
  #
  # @param value the value to set the attribute through to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/association_matchers/through_matcher.rb#56
  def through=(_arg0); end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_record/define_enum_for_matcher.rb#167
class Shoulda::Matchers::ActiveRecord::DefineEnumForMatcher
  # @return [DefineEnumForMatcher] a new instance of DefineEnumForMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/define_enum_for_matcher.rb#168
  def initialize(attribute_name); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/define_enum_for_matcher.rb#218
  def backed_by_column_of_type(expected_column_type); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/define_enum_for_matcher.rb#173
  def description; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/define_enum_for_matcher.rb#232
  def failure_message; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/define_enum_for_matcher.rb#245
  def failure_message_when_negated; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/define_enum_for_matcher.rb#223
  def matches?(subject); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/define_enum_for_matcher.rb#200
  def with(expected_enum_values); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/define_enum_for_matcher.rb#208
  def with_prefix(expected_prefix = T.unsafe(nil)); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/define_enum_for_matcher.rb#213
  def with_suffix(expected_suffix = T.unsafe(nil)); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/define_enum_for_matcher.rb#195
  def with_values(expected_enum_values); end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/define_enum_for_matcher.rb#327
  def actual_enum_values; end

  # Returns the value of attribute attribute_name.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/define_enum_for_matcher.rb#252
  def attribute_name; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/define_enum_for_matcher.rb#372
  def column; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/define_enum_for_matcher.rb#356
  def column_type_matches?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/define_enum_for_matcher.rb#331
  def enum_defined?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/define_enum_for_matcher.rb#380
  def enum_value_methods_exist?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/define_enum_for_matcher.rb#341
  def enum_values_match?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/define_enum_for_matcher.rb#255
  def expectation; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/define_enum_for_matcher.rb#368
  def expected_column_type; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/define_enum_for_matcher.rb#315
  def expected_enum_value_names; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/define_enum_for_matcher.rb#319
  def expected_enum_values; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/define_enum_for_matcher.rb#421
  def expected_prefix; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/define_enum_for_matcher.rb#412
  def expected_singleton_methods; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/define_enum_for_matcher.rb#431
  def expected_suffix; end

  # Returns the value of attribute failure_message_continuation.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/define_enum_for_matcher.rb#252
  def failure_message_continuation; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/define_enum_for_matcher.rb#376
  def model; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/define_enum_for_matcher.rb#323
  def normalized_actual_enum_values; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/define_enum_for_matcher.rb#311
  def normalized_expected_enum_values; end

  # Returns the value of attribute options.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/define_enum_for_matcher.rb#252
  def options; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/define_enum_for_matcher.rb#301
  def presented_enum_mapping(enum_values); end

  # Returns the value of attribute record.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/define_enum_for_matcher.rb#252
  def record; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/define_enum_for_matcher.rb#297
  def simple_description; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/define_enum_for_matcher.rb#451
  def to_array(value); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/define_enum_for_matcher.rb#441
  def to_hash(value); end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_record/have_attached_matcher.rb#55
class Shoulda::Matchers::ActiveRecord::HaveAttachedMatcher
  # @return [HaveAttachedMatcher] a new instance of HaveAttachedMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_attached_matcher.rb#58
  def initialize(macro, name); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_attached_matcher.rb#63
  def description; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_attached_matcher.rb#80
  def expectation; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_attached_matcher.rb#67
  def failure_message; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_attached_matcher.rb#74
  def failure_message_when_negated; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_attached_matcher.rb#84
  def matches?(subject); end

  # Returns the value of attribute name.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_attached_matcher.rb#56
  def name; end

  private

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_attached_matcher.rb#115
  def attachments_association_exists?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_attached_matcher.rb#124
  def attachments_association_matcher; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_attached_matcher.rb#135
  def attachments_association_name; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_attached_matcher.rb#142
  def blobs_association_exists?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_attached_matcher.rb#151
  def blobs_association_matcher; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_attached_matcher.rb#162
  def blobs_association_name; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_attached_matcher.rb#169
  def eager_loading_scope_exists?; end

  # Returns the value of attribute macro.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_attached_matcher.rb#95
  def macro; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_attached_matcher.rb#179
  def model_class; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_attached_matcher.rb#97
  def reader_attribute_exists?; end

  # Returns the value of attribute subject.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_attached_matcher.rb#95
  def subject; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_attached_matcher.rb#106
  def writer_attribute_exists?; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_column_matcher.rb#86
class Shoulda::Matchers::ActiveRecord::HaveDbColumnMatcher
  # @return [HaveDbColumnMatcher] a new instance of HaveDbColumnMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_column_matcher.rb#89
  def initialize(column); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_column_matcher.rb#129
  def description; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_column_matcher.rb#121
  def failure_message; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_column_matcher.rb#125
  def failure_message_when_negated; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_column_matcher.rb#109
  def matches?(subject); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_column_matcher.rb#94
  def of_type(column_type); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_column_matcher.rb#99
  def with_options(opts = T.unsafe(nil)); end

  protected

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_column_matcher.rb#278
  def actual_primary?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_column_matcher.rb#274
  def actual_scale; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_column_matcher.rb#157
  def column_exists?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_column_matcher.rb#167
  def correct_column_type?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_column_matcher.rb#206
  def correct_default?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_column_matcher.rb#193
  def correct_limit?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_column_matcher.rb#219
  def correct_null?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_column_matcher.rb#180
  def correct_precision?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_column_matcher.rb#244
  def correct_primary?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_column_matcher.rb#232
  def correct_scale?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_column_matcher.rb#282
  def expectation; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_column_matcher.rb#261
  def matched_column; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_column_matcher.rb#270
  def model_class; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_column_matcher.rb#147
  def validate_options(opts); end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_column_matcher.rb#287
class Shoulda::Matchers::ActiveRecord::HaveDbColumnMatcher::DecoratedColumn < ::SimpleDelegator
  # @return [DecoratedColumn] a new instance of DecoratedColumn
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_column_matcher.rb#288
  def initialize(model, column); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_column_matcher.rb#297
  def primary?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_column_matcher.rb#293
  def type_cast_default; end

  protected

  # Returns the value of attribute model.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_column_matcher.rb#303
  def model; end
end

# source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_column_matcher.rb#87
Shoulda::Matchers::ActiveRecord::HaveDbColumnMatcher::OPTIONS = T.let(T.unsafe(nil), Array)

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_index_matcher.rb#115
class Shoulda::Matchers::ActiveRecord::HaveDbIndexMatcher
  # @return [HaveDbIndexMatcher] a new instance of HaveDbIndexMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_index_matcher.rb#116
  def initialize(columns); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_index_matcher.rb#154
  def description; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_index_matcher.rb#131
  def failure_message; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_index_matcher.rb#147
  def failure_message_when_negated; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_index_matcher.rb#126
  def matches?(subject); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_index_matcher.rb#121
  def unique(unique = T.unsafe(nil)); end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_index_matcher.rb#210
  def actual_indexes; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_index_matcher.rb#181
  def correct_unique?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_index_matcher.rb#214
  def described_table_name; end

  # Returns the value of attribute expected_columns.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_index_matcher.rb#171
  def expected_columns; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_index_matcher.rb#260
  def formatted_expected_columns; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_index_matcher.rb#177
  def index_exists?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_index_matcher.rb#252
  def index_type; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_index_matcher.rb#244
  def inspected_expected_columns; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_index_matcher.rb#197
  def matched_index; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_index_matcher.rb#270
  def model; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_index_matcher.rb#240
  def negative_expectation; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_index_matcher.rb#173
  def normalize_columns_to_array(columns); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_index_matcher.rb#226
  def positive_expectation; end

  # Returns the value of attribute qualifiers.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_index_matcher.rb#171
  def qualifiers; end

  # Returns the value of attribute reason.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_index_matcher.rb#171
  def reason; end

  # Returns the value of attribute subject.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_index_matcher.rb#171
  def subject; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_db_index_matcher.rb#222
  def table_name; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_record/have_implicit_order_column.rb#30
class Shoulda::Matchers::ActiveRecord::HaveImplicitOrderColumnMatcher
  # @return [HaveImplicitOrderColumnMatcher] a new instance of HaveImplicitOrderColumnMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_implicit_order_column.rb#33
  def initialize(column_name); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_implicit_order_column.rb#61
  def description; end

  # Returns the value of attribute failure_message.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_implicit_order_column.rb#31
  def failure_message; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_implicit_order_column.rb#55
  def failure_message_when_negated; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_implicit_order_column.rb#37
  def matches?(subject); end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_implicit_order_column.rb#69
  def check_column_exists!; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_implicit_order_column.rb#80
  def check_implicit_order_column_matches!; end

  # Returns the value of attribute column_name.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_implicit_order_column.rb#67
  def column_name; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_implicit_order_column.rb#97
  def expectation; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_implicit_order_column.rb#93
  def model; end

  # Returns the value of attribute subject.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_implicit_order_column.rb#67
  def subject; end
end

# source://shoulda-matchers//lib/shoulda/matchers/active_record/have_implicit_order_column.rb#102
class Shoulda::Matchers::ActiveRecord::HaveImplicitOrderColumnMatcher::PrimaryCheckFailedError < ::StandardError; end

# source://shoulda-matchers//lib/shoulda/matchers/active_record/have_implicit_order_column.rb#101
class Shoulda::Matchers::ActiveRecord::HaveImplicitOrderColumnMatcher::SecondaryCheckFailedError < ::StandardError; end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_record/have_readonly_attribute_matcher.rb#28
class Shoulda::Matchers::ActiveRecord::HaveReadonlyAttributeMatcher
  # @return [HaveReadonlyAttributeMatcher] a new instance of HaveReadonlyAttributeMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_readonly_attribute_matcher.rb#29
  def initialize(attribute); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_readonly_attribute_matcher.rb#55
  def description; end

  # Returns the value of attribute failure_message.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_readonly_attribute_matcher.rb#33
  def failure_message; end

  # Returns the value of attribute failure_message_when_negated.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_readonly_attribute_matcher.rb#33
  def failure_message_when_negated; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_readonly_attribute_matcher.rb#35
  def matches?(subject); end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_readonly_attribute_matcher.rb#65
  def class_name; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_readonly_attribute_matcher.rb#61
  def readonly_attributes; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_record/have_rich_text_matcher.rb#30
class Shoulda::Matchers::ActiveRecord::HaveRichTextMatcher
  # @return [HaveRichTextMatcher] a new instance of HaveRichTextMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_rich_text_matcher.rb#31
  def initialize(rich_text_attribute); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_rich_text_matcher.rb#35
  def description; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_rich_text_matcher.rb#40
  def failure_message; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_rich_text_matcher.rb#44
  def failure_message_when_negated; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_rich_text_matcher.rb#49
  def matches?(subject); end

  private

  # Returns the value of attribute error.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_rich_text_matcher.rb#57
  def error; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_rich_text_matcher.rb#77
  def error_description; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_rich_text_matcher.rb#67
  def has_attribute?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_rich_text_matcher.rb#71
  def has_expected_action_text?; end

  # Returns the value of attribute rich_text_attribute.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_rich_text_matcher.rb#57
  def rich_text_attribute; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_rich_text_matcher.rb#59
  def run_checks; end

  # Returns the value of attribute subject.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_rich_text_matcher.rb#57
  def subject; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_record/have_secure_token_matcher.rb#52
class Shoulda::Matchers::ActiveRecord::HaveSecureTokenMatcher
  # @return [HaveSecureTokenMatcher] a new instance of HaveSecureTokenMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_secure_token_matcher.rb#55
  def initialize(token_attribute); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_secure_token_matcher.rb#60
  def description; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_secure_token_matcher.rb#64
  def failure_message; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_secure_token_matcher.rb#71
  def failure_message_when_negated; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_secure_token_matcher.rb#84
  def ignoring_check_for_db_index; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_secure_token_matcher.rb#78
  def matches?(subject); end

  # Returns the value of attribute token_attribute.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_secure_token_matcher.rb#53
  def token_attribute; end

  private

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_secure_token_matcher.rb#112
  def has_expected_db_column?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_secure_token_matcher.rb#117
  def has_expected_db_index?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_secure_token_matcher.rb#105
  def has_expected_instance_methods?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_secure_token_matcher.rb#91
  def run_checks; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_secure_token_matcher.rb#122
  def table_and_column; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/have_secure_token_matcher.rb#126
  def table_name; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_record/serialize_matcher.rb#93
class Shoulda::Matchers::ActiveRecord::SerializeMatcher
  # @return [SerializeMatcher] a new instance of SerializeMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/serialize_matcher.rb#94
  def initialize(name); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/serialize_matcher.rb#99
  def as(type); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/serialize_matcher.rb#104
  def as_instance_of(type); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/serialize_matcher.rb#122
  def description; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/serialize_matcher.rb#114
  def failure_message; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/serialize_matcher.rb#118
  def failure_message_when_negated; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/serialize_matcher.rb#109
  def matches?(subject); end

  protected

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/serialize_matcher.rb#189
  def attribute_is_serialized?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/serialize_matcher.rb#141
  def class_valid?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/serialize_matcher.rb#179
  def expectation; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/serialize_matcher.rb#162
  def instance_class_valid?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/serialize_matcher.rb#197
  def model; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/serialize_matcher.rb#158
  def model_class; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/serialize_matcher.rb#193
  def serialization_coder; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/serialize_matcher.rb#132
  def serialization_valid?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/serialize_matcher.rb#175
  def type_valid?; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_record/uniqueness.rb#5
module Shoulda::Matchers::ActiveRecord::Uniqueness; end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_record/uniqueness/model.rb#7
class Shoulda::Matchers::ActiveRecord::Uniqueness::Model
  # @return [Model] a new instance of Model
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/uniqueness/model.rb#18
  def initialize(name, namespace); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/uniqueness/model.rb#23
  def already_exists?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/uniqueness/model.rb#27
  def next; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/uniqueness/model.rb#31
  def symlink_to(parent); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/uniqueness/model.rb#35
  def to_s; end

  protected

  # Returns the value of attribute name.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/uniqueness/model.rb#41
  def name; end

  # Returns the value of attribute namespace.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/uniqueness/model.rb#41
  def namespace; end

  class << self
    # source://shoulda-matchers//lib/shoulda/matchers/active_record/uniqueness/model.rb#8
    def next_unique_copy_of(model_name, namespace); end
  end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_record/uniqueness/namespace.rb#7
class Shoulda::Matchers::ActiveRecord::Uniqueness::Namespace
  # @return [Namespace] a new instance of Namespace
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/uniqueness/namespace.rb#8
  def initialize(constant); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/uniqueness/namespace.rb#20
  def clear; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/uniqueness/namespace.rb#12
  def has?(name); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/uniqueness/namespace.rb#16
  def set(name, value); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/uniqueness/namespace.rb#26
  def to_s; end

  protected

  # Returns the value of attribute constant.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/uniqueness/namespace.rb#32
  def constant; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_record/uniqueness/test_model_creator.rb#7
class Shoulda::Matchers::ActiveRecord::Uniqueness::TestModelCreator
  # @return [TestModelCreator] a new instance of TestModelCreator
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/uniqueness/test_model_creator.rb#14
  def initialize(model_name, namespace); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/uniqueness/test_model_creator.rb#19
  def create; end

  protected

  # Returns the value of attribute model_name.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/uniqueness/test_model_creator.rb#27
  def model_name; end

  # Returns the value of attribute namespace.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/uniqueness/test_model_creator.rb#27
  def namespace; end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/uniqueness/test_model_creator.rb#42
  def existing_model; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/uniqueness/test_model_creator.rb#31
  def model_name_without_namespace; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/uniqueness/test_model_creator.rb#35
  def new_model; end

  class << self
    # source://shoulda-matchers//lib/shoulda/matchers/active_record/uniqueness/test_model_creator.rb#8
    def create(model_name, namespace); end
  end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_record/uniqueness/test_models.rb#7
module Shoulda::Matchers::ActiveRecord::Uniqueness::TestModels
  class << self
    # source://shoulda-matchers//lib/shoulda/matchers/active_record/uniqueness/test_models.rb#8
    def create(model_name); end

    # source://shoulda-matchers//lib/shoulda/matchers/active_record/uniqueness/test_models.rb#12
    def remove_all; end

    # source://shoulda-matchers//lib/shoulda/matchers/active_record/uniqueness/test_models.rb#16
    def root_namespace; end
  end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#266
class Shoulda::Matchers::ActiveRecord::ValidateUniquenessOfMatcher < ::Shoulda::Matchers::ActiveModel::ValidationMatcher
  include ::Shoulda::Matchers::ActiveModel::Helpers

  # @return [ValidateUniquenessOfMatcher] a new instance of ValidateUniquenessOfMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#269
  def initialize(attribute); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#308
  def allow_blank; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#299
  def allow_nil; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#289
  def case_insensitive; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#345
  def does_not_match?(given_record); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#313
  def expects_to_allow_blank?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#304
  def expects_to_allow_nil?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#294
  def ignoring_case_sensitivity; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#329
  def matches?(given_record); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#284
  def scoped_to(*scopes); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#317
  def simple_description; end

  protected

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#370
  def build_allow_or_disallow_value_matcher(args); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#362
  def failure_reason; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#366
  def failure_reason_when_negated; end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#485
  def actual_sets_of_scopes; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#836
  def all_scopes_are_booleans?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#561
  def arbitrary_non_blank_value; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#980
  def attribute_changed_value_message; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#899
  def attribute_names_under_test; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#610
  def attribute_present_on_model?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#1028
  def attribute_setter_descriptions_for_new_record; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#890
  def attribute_setter_for_existing_record; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#894
  def attribute_setters_for_new_record; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#855
  def available_enum_values_for(scope, previous_value); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#842
  def boolean_value?(value); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#903
  def build_attribute_setter(record, attribute_name, value); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#577
  def build_new_record; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#380
  def case_sensitivity_strategy; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#926
  def column_for(scope); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#930
  def column_limit_for(attribute); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#542
  def create_existing_record; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#846
  def defined_as_enum?(scope); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#995
  def description_for_attribute_setter(attribute_setter, same_as_existing: T.unsafe(nil)); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#393
  def description_for_case_sensitive_qualifier; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#1024
  def descriptions_for_attribute_setters_for_new_record; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#514
  def does_not_match_allow_blank?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#498
  def does_not_match_allow_nil?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#600
  def does_not_match_presence_of_attribute?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#640
  def does_not_match_presence_of_scopes?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#434
  def does_not_match_scopes_configuration?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#718
  def does_not_match_uniqueness_with_case_sensitivity_strategy?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#765
  def does_not_match_uniqueness_with_scopes?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#685
  def does_not_match_uniqueness_without_scopes?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#803
  def dummy_scalar_value_for(column); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#793
  def dummy_value_for(scope); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#1041
  def existing_and_new_values_are_same?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#521
  def existing_record; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#914
  def existing_value_read; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#918
  def existing_value_written; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#481
  def expected_scopes; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#938
  def failure_message_preface; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#538
  def find_existing_record; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#529
  def find_or_create_existing_record; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#573
  def has_secure_password?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#462
  def inspected_actual_scopes; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#469
  def inspected_actual_sets_of_scopes; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#458
  def inspected_expected_scopes; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#1045
  def last_attribute_setter_used_on_new_record; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#1049
  def last_value_set_on_new_record; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#507
  def matches_allow_blank?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#491
  def matches_allow_nil?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#590
  def matches_presence_of_attribute?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#615
  def matches_presence_of_scopes?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#410
  def matches_scopes_configuration?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#695
  def matches_uniqueness_with_case_sensitivity_strategy?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#755
  def matches_uniqueness_with_scopes?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#677
  def matches_uniqueness_without_scopes?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#934
  def model; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#749
  def model_class?(model_name); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#384
  def new_record; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#815
  def next_scalar_value_for(scope, previous_value); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#807
  def next_value_for(scope, previous_value); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#851
  def polymorphic_type_attribute?(scope, previous_value); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#453
  def scopes_match?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#671
  def scopes_missing_on_model; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#665
  def scopes_present_on_model; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#861
  def set_attribute_on!(record_type, record, attribute_name, value); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#872
  def set_attribute_on_existing_record!(attribute_name, value); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#881
  def set_attribute_on_new_record!(attribute_name, value); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#776
  def setting_next_value_for(scope); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#743
  def should_test_case_sensitivity?; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#384
  def subject; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#550
  def update_existing_record!(value); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#404
  def validations; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#1054
class Shoulda::Matchers::ActiveRecord::ValidateUniquenessOfMatcher::AttributeSetters
  include ::Enumerable

  # @return [AttributeSetters] a new instance of AttributeSetters
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#1057
  def initialize; end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#1071
  def +(other_attribute_setters); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#1061
  def <<(given_attribute_setter); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#1079
  def each(&block); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#1083
  def last; end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#1089
  def find_index_of(given_attribute_setter); end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#1125
class Shoulda::Matchers::ActiveRecord::ValidateUniquenessOfMatcher::ExistingRecordInvalid < ::Shoulda::Matchers::Error
  include ::Shoulda::Matchers::ActiveModel::Helpers

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#1130
  def message; end

  # Returns the value of attribute underlying_exception.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#1128
  def underlying_exception; end

  # Sets the attribute underlying_exception
  #
  # @param value the value to set the attribute underlying_exception to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#1128
  def underlying_exception=(_arg0); end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#1098
class Shoulda::Matchers::ActiveRecord::ValidateUniquenessOfMatcher::NonCaseSwappableValueError < ::Shoulda::Matchers::Error
  # Returns the value of attribute attribute.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#1099
  def attribute; end

  # Sets the attribute attribute
  #
  # @param value the value to set the attribute attribute to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#1099
  def attribute=(_arg0); end

  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#1101
  def message; end

  # Returns the value of attribute model.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#1099
  def model; end

  # Sets the attribute model
  #
  # @param value the value to set the attribute model to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#1099
  def model=(_arg0); end

  # Returns the value of attribute value.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#1099
  def value; end

  # Sets the attribute value
  #
  # @param value the value to set the attribute value to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/active_record/validate_uniqueness_of_matcher.rb#1099
  def value=(_arg0); end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/configuration.rb#19
class Shoulda::Matchers::Configuration
  # @return [Configuration] a new instance of Configuration
  #
  # source://shoulda-matchers//lib/shoulda/matchers/configuration.rb#22
  def initialize; end

  # source://shoulda-matchers//lib/shoulda/matchers/configuration.rb#26
  def integrate(&block); end

  # Returns the value of attribute integrations.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/configuration.rb#20
  def integrations; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/util/word_wrap.rb#15
class Shoulda::Matchers::Document
  # @return [Document] a new instance of Document
  #
  # source://shoulda-matchers//lib/shoulda/matchers/util/word_wrap.rb#16
  def initialize(document, indent: T.unsafe(nil)); end

  # source://shoulda-matchers//lib/shoulda/matchers/util/word_wrap.rb#21
  def wrap; end

  protected

  # Returns the value of attribute document.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/util/word_wrap.rb#27
  def document; end

  # Returns the value of attribute indent.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/util/word_wrap.rb#27
  def indent; end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/util/word_wrap.rb#31
  def paragraphs; end

  # source://shoulda-matchers//lib/shoulda/matchers/util/word_wrap.rb#35
  def wrapped_paragraphs; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/doublespeak.rb#7
module Shoulda::Matchers::Doublespeak
  class << self
    # source://shoulda-matchers//lib/shoulda/matchers/doublespeak.rb#22
    def debug(&block); end

    # @return [Boolean]
    #
    # source://shoulda-matchers//lib/shoulda/matchers/doublespeak.rb#18
    def debugging_enabled?; end

    # source://forwardable/1.3.3/forwardable.rb#231
    def double_collection_for(*args, **_arg1, &block); end

    # source://forwardable/1.3.3/forwardable.rb#231
    def with_doubles_activated(*args, **_arg1, &block); end

    # source://shoulda-matchers//lib/shoulda/matchers/doublespeak.rb#14
    def world; end
  end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/doublespeak/double.rb#5
class Shoulda::Matchers::Doublespeak::Double
  # @return [Double] a new instance of Double
  #
  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/double.rb#8
  def initialize(world, klass, method_name, implementation); end

  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/double.rb#33
  def activate; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/double.rb#21
  def activated?; end

  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/double.rb#52
  def call_original_method(call); end

  # Returns the value of attribute calls.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/double.rb#6
  def calls; end

  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/double.rb#41
  def deactivate; end

  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/double.rb#48
  def record_call(call); end

  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/double.rb#25
  def to_return(value = T.unsafe(nil), &block); end

  protected

  # Returns the value of attribute implementation.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/double.rb#62
  def implementation; end

  # Returns the value of attribute klass.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/double.rb#62
  def klass; end

  # Returns the value of attribute method_name.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/double.rb#62
  def method_name; end

  # Returns the value of attribute original_method.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/double.rb#62
  def original_method; end

  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/double.rb#69
  def replace_method_with_double; end

  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/double.rb#91
  def restore_original_method; end

  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/double.rb#65
  def store_original_method; end

  # Returns the value of attribute world.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/double.rb#62
  def world; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/doublespeak/double_collection.rb#5
class Shoulda::Matchers::Doublespeak::DoubleCollection
  # @return [DoubleCollection] a new instance of DoubleCollection
  #
  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/double_collection.rb#6
  def initialize(world, klass); end

  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/double_collection.rb#20
  def activate; end

  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/double_collection.rb#32
  def calls_by_method_name; end

  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/double_collection.rb#38
  def calls_to(method_name); end

  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/double_collection.rb#26
  def deactivate; end

  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/double_collection.rb#16
  def register_proxy(method_name); end

  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/double_collection.rb#12
  def register_stub(method_name); end

  protected

  # Returns the value of attribute doubles_by_method_name.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/double_collection.rb#50
  def doubles_by_method_name; end

  # Returns the value of attribute klass.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/double_collection.rb#50
  def klass; end

  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/double_collection.rb#52
  def register_double(method_name, implementation_type); end

  # Returns the value of attribute world.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/double_collection.rb#50
  def world; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/doublespeak/double_implementation_registry.rb#5
module Shoulda::Matchers::Doublespeak::DoubleImplementationRegistry
  class << self
    # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/double_implementation_registry.rb#7
    def find(type); end

    # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/double_implementation_registry.rb#11
    def register(klass, type); end

    private

    # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/double_implementation_registry.rb#17
    def find_class!(type); end

    # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/double_implementation_registry.rb#24
    def registry; end
  end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/doublespeak/method_call.rb#5
class Shoulda::Matchers::Doublespeak::MethodCall
  # @return [MethodCall] a new instance of MethodCall
  #
  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/method_call.rb#9
  def initialize(args); end

  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/method_call.rb#25
  def ==(other); end

  # Returns the value of attribute args.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/method_call.rb#7
  def args; end

  # Returns the value of attribute block.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/method_call.rb#7
  def block; end

  # Returns the value of attribute caller.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/method_call.rb#7
  def caller; end

  # Returns the value of attribute double.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/method_call.rb#7
  def double; end

  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/method_call.rb#38
  def inspect; end

  # Returns the value of attribute method_name.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/method_call.rb#7
  def method_name; end

  # Returns the value of attribute object.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/method_call.rb#7
  def object; end

  # Returns the value of attribute return_value.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/method_call.rb#6
  def return_value; end

  # Sets the attribute return_value
  #
  # @param value the value to set the attribute return_value to.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/method_call.rb#6
  def return_value=(_arg0); end

  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/method_call.rb#34
  def to_hash; end

  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/method_call.rb#19
  def with_return_value(return_value); end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/doublespeak/object_double.rb#5
class Shoulda::Matchers::Doublespeak::ObjectDouble < ::BasicObject
  # @return [ObjectDouble] a new instance of ObjectDouble
  #
  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/object_double.rb#8
  def initialize; end

  # Returns the value of attribute calls.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/object_double.rb#6
  def calls; end

  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/object_double.rb#13
  def calls_to(method_name); end

  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/object_double.rb#25
  def method_missing(method_name, *args, &block); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/object_double.rb#17
  def respond_to?(_name, _include_private = T.unsafe(nil)); end

  protected

  # Returns the value of attribute calls_by_method_name.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/object_double.rb#39
  def calls_by_method_name; end

  private

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/object_double.rb#21
  def respond_to_missing?(_name, _include_all); end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/doublespeak/proxy_implementation.rb#5
class Shoulda::Matchers::Doublespeak::ProxyImplementation
  extend ::Forwardable

  # @return [ProxyImplementation] a new instance of ProxyImplementation
  #
  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/proxy_implementation.rb#16
  def initialize(stub_implementation); end

  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/proxy_implementation.rb#20
  def call(call); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def returns(*args, **_arg1, &block); end

  protected

  # Returns the value of attribute stub_implementation.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/proxy_implementation.rb#28
  def stub_implementation; end

  class << self
    # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/proxy_implementation.rb#12
    def create; end
  end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/doublespeak/stub_implementation.rb#5
class Shoulda::Matchers::Doublespeak::StubImplementation
  # @return [StubImplementation] a new instance of StubImplementation
  #
  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/stub_implementation.rb#12
  def initialize; end

  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/stub_implementation.rb#20
  def call(call); end

  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/stub_implementation.rb#16
  def returns(value = T.unsafe(nil), &block); end

  protected

  # Returns the value of attribute implementation.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/stub_implementation.rb#27
  def implementation; end

  class << self
    # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/stub_implementation.rb#8
    def create; end
  end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/doublespeak/world.rb#5
class Shoulda::Matchers::Doublespeak::World
  # @return [World] a new instance of World
  #
  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/world.rb#6
  def initialize; end

  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/world.rb#10
  def double_collection_for(klass); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/world.rb#35
  def doubles_activated?; end

  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/world.rb#20
  def original_method_for(klass, method_name); end

  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/world.rb#15
  def store_original_method_for(klass, method_name); end

  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/world.rb#26
  def with_doubles_activated; end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/world.rb#41
  def activate; end

  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/world.rb#47
  def deactivate; end

  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/world.rb#53
  def double_collections_by_class; end

  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/world.rb#57
  def original_methods_by_class; end

  # source://shoulda-matchers//lib/shoulda/matchers/doublespeak/world.rb#61
  def original_methods_for_class(klass); end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/error.rb#4
class Shoulda::Matchers::Error < ::StandardError
  # @return [Error] a new instance of Error
  #
  # source://shoulda-matchers//lib/shoulda/matchers/error.rb#15
  def initialize(*args); end

  # source://shoulda-matchers//lib/shoulda/matchers/error.rb#24
  def inspect; end

  # source://shoulda-matchers//lib/shoulda/matchers/error.rb#20
  def message; end

  class << self
    # source://shoulda-matchers//lib/shoulda/matchers/error.rb#5
    def create(attributes); end
  end
end

# This module provides matchers that are used to test behavior outside of
# Rails-specific classes.
#
# source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#6
module Shoulda::Matchers::Independent
  # The `delegate_method` matcher tests that an object forwards messages
  # to other, internal objects by way of delegation.
  #
  # In this example, we test that Courier forwards a call to #deliver onto
  # its PostOffice instance:
  #
  #     require 'forwardable'
  #
  #     class Courier
  #       extend Forwardable
  #
  #       attr_reader :post_office
  #
  #       def_delegators :post_office, :deliver
  #
  #       def initialize
  #         @post_office = PostOffice.new
  #       end
  #     end
  #
  #     # RSpec
  #     describe Courier do
  #       it { should delegate_method(:deliver).to(:post_office) }
  #     end
  #
  #     # Minitest
  #     class CourierTest < Minitest::Test
  #       should delegate_method(:deliver).to(:post_office)
  #     end
  #
  # You can also use `delegate_method` with Rails's `delegate` macro:
  #
  #     class Courier
  #       attr_reader :post_office
  #       delegate :deliver, to: :post_office
  #
  #       def initialize
  #         @post_office = PostOffice.new
  #       end
  #     end
  #
  #     describe Courier do
  #       it { should delegate_method(:deliver).to(:post_office) }
  #     end
  #
  # To employ some terminology, we would say that Courier's #deliver method
  # is the *delegating method*, PostOffice is the *delegate object*, and
  # PostOffice#deliver is the *delegate method*.
  #
  # #### Qualifiers
  #
  # ##### as
  #
  # Use `as` if the name of the delegate method is different from the name
  # of the delegating method.
  #
  # Here, Courier has a #deliver method, but instead of calling #deliver on
  # the PostOffice, it calls #ship:
  #
  #     class Courier
  #       attr_reader :post_office
  #
  #       def initialize
  #         @post_office = PostOffice.new
  #       end
  #
  #       def deliver(package)
  #         post_office.ship(package)
  #       end
  #     end
  #
  #     # RSpec
  #     describe Courier do
  #       it { should delegate_method(:deliver).to(:post_office).as(:ship) }
  #     end
  #
  #     # Minitest
  #     class CourierTest < Minitest::Test
  #       should delegate_method(:deliver).to(:post_office).as(:ship)
  #     end
  #
  # ##### with_prefix
  #
  # Use `with_prefix` when using Rails's `delegate` helper along with the
  # `:prefix` option.
  #
  #     class Page < ActiveRecord::Base
  #       belongs_to :site
  #       delegate :name, to: :site, prefix: true
  #       delegate :title, to: :site, prefix: :root
  #     end
  #
  #     # RSpec
  #     describe Page do
  #       it { should delegate_method(:name).to(:site).with_prefix }
  #       it { should delegate_method(:name).to(:site).with_prefix(true) }
  #       it { should delegate_method(:title).to(:site).with_prefix(:root) }
  #     end
  #
  #     # Minitest
  #     class PageTest < Minitest::Test
  #       should delegate_method(:name).to(:site).with_prefix
  #       should delegate_method(:name).to(:site).with_prefix(true)
  #       should delegate_method(:title).to(:site).with_prefix(:root)
  #     end
  #
  # ##### with_arguments
  #
  # Use `with_arguments` to assert that the delegate method is called with
  # certain arguments. Note that this qualifier can only be used when the
  # delegating method takes no arguments; it does not support delegating
  # or delegate methods that take arbitrary arguments.
  #
  # Here, when Courier#deliver_package calls PostOffice#deliver_package, it
  # adds an options hash:
  #
  #     class Courier
  #       attr_reader :post_office
  #
  #       def initialize
  #         @post_office = PostOffice.new
  #       end
  #
  #       def deliver_package
  #         post_office.deliver_package(expedited: true)
  #       end
  #     end
  #
  #     # RSpec
  #     describe Courier do
  #       it do
  #         should delegate_method(:deliver_package).
  #           to(:post_office).
  #           with_arguments(expedited: true)
  #       end
  #     end
  #
  #     # Minitest
  #     class CourierTest < Minitest::Test
  #       should delegate_method(:deliver_package).
  #         to(:post_office).
  #         with_arguments(expedited: true)
  #     end
  #
  # ##### allow_nil
  #
  # Use `allow_nil` if the delegation accounts for the fact that your
  # delegate object could be nil. (This is mostly intended as an analogue to
  # the `allow_nil` option that Rails' `delegate` helper takes.)
  #
  #     class Account
  #       delegate :plan, to: :subscription, allow_nil: true
  #     end
  #
  #     # RSpec
  #     describe Account do
  #       it { should delegate_method(:plan).to(:subscription).allow_nil }
  #     end
  #
  #     # Minitest
  #     class PageTest < Minitest::Test
  #       should delegate_method(:plan).to(:subscription).allow_nil
  #     end
  #
  # @return [DelegateMethodMatcher]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#173
  def delegate_method(delegating_method); end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#178
class Shoulda::Matchers::Independent::DelegateMethodMatcher
  # @return [DelegateMethodMatcher] a new instance of DelegateMethodMatcher
  #
  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#179
  def initialize(delegating_method); end

  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#252
  def allow_nil; end

  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#235
  def as(delegate_method); end

  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#257
  def build_delegating_method_prefix(prefix); end

  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#208
  def description; end

  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#264
  def failure_message; end

  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#286
  def failure_message_when_negated; end

  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#192
  def in_context(context); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#197
  def matches?(subject); end

  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#230
  def to(delegate_object_reader_method); end

  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#240
  def with_arguments(*arguments); end

  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#245
  def with_prefix(prefix = T.unsafe(nil)); end

  protected

  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#419
  def call_delegating_method_with_delegate_method_returning(value); end

  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#438
  def calls_on_delegate_object; end

  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#434
  def calls_to_delegate_method; end

  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#351
  def class_or_instance_method_indicator; end

  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#313
  def class_under_test; end

  # Returns the value of attribute context.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#292
  def context; end

  # Returns the value of attribute delegate_method.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#292
  def delegate_method; end

  # Returns the value of attribute delegate_object.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#292
  def delegate_object; end

  # Returns the value of attribute delegate_object_reader_method.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#292
  def delegate_object_reader_method; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#359
  def delegate_object_received_call?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#363
  def delegate_object_received_call_with_delegated_arguments?; end

  # Returns the value of attribute delegated_arguments.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#292
  def delegated_arguments; end

  # Returns the value of attribute delegating_method.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#292
  def delegating_method; end

  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#377
  def ensure_delegate_object_has_been_specified!; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#321
  def expects_to_allow_nil_delegate_object?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#414
  def failed_to_allow_nil_delegate_object?; end

  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#442
  def formatted_calls_on_delegate_object; end

  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#325
  def formatted_delegate_method(options = T.unsafe(nil)); end

  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#333
  def formatted_delegate_object_reader_method_name(options = T.unsafe(nil)); end

  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#329
  def formatted_delegating_method_name(options = T.unsafe(nil)); end

  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#337
  def formatted_method_name_for(method_name, options); end

  # Returns the value of attribute method.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#292
  def method; end

  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#343
  def possible_class_under_test(options); end

  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#427
  def register_subject_double_collection_to(returned_value); end

  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#301
  def subject; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#383
  def subject_delegates_to_delegate_object_correctly?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#393
  def subject_handles_nil_delegate_object?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#373
  def subject_has_delegate_object_reader_method?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#369
  def subject_has_delegating_method?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher.rb#305
  def subject_is_a_class?; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher/target_not_defined_error.rb#6
class Shoulda::Matchers::Independent::DelegateMethodMatcher::DelegateObjectNotSpecified < ::StandardError
  # source://shoulda-matchers//lib/shoulda/matchers/independent/delegate_method_matcher/target_not_defined_error.rb#7
  def message; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/integrations.rb#4
module Shoulda::Matchers::Integrations
  class << self
    # source://shoulda-matchers//lib/shoulda/matchers/integrations.rb#10
    def find_library!(name); end

    # source://shoulda-matchers//lib/shoulda/matchers/integrations.rb#18
    def find_test_framework!(name); end

    # source://shoulda-matchers//lib/shoulda/matchers/integrations.rb#6
    def register_library(klass, name); end

    # source://shoulda-matchers//lib/shoulda/matchers/integrations.rb#14
    def register_test_framework(klass, name); end

    private

    # source://shoulda-matchers//lib/shoulda/matchers/integrations.rb#24
    def library_registry; end

    # source://shoulda-matchers//lib/shoulda/matchers/integrations.rb#28
    def test_framework_registry; end
  end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/integrations/configuration.rb#7
class Shoulda::Matchers::Integrations::Configuration
  # @return [Configuration] a new instance of Configuration
  #
  # source://shoulda-matchers//lib/shoulda/matchers/integrations/configuration.rb#14
  def initialize(&block); end

  # source://shoulda-matchers//lib/shoulda/matchers/integrations/configuration.rb#33
  def apply; end

  # source://shoulda-matchers//lib/shoulda/matchers/integrations/configuration.rb#29
  def library(name); end

  # source://shoulda-matchers//lib/shoulda/matchers/integrations/configuration.rb#24
  def test_framework(name); end

  # Returns the value of attribute test_frameworks.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/integrations/configuration.rb#12
  def test_frameworks; end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/integrations/configuration.rb#58
  def clear_default_test_framework; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/integrations/configuration.rb#66
  def no_libraries_added?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/integrations/configuration.rb#62
  def no_test_frameworks_added?; end

  class << self
    # source://shoulda-matchers//lib/shoulda/matchers/integrations/configuration.rb#8
    def apply(&block); end
  end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/integrations/configuration_error.rb#5
class Shoulda::Matchers::Integrations::ConfigurationError < ::StandardError; end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/integrations/inclusion.rb#5
module Shoulda::Matchers::Integrations::Inclusion
  # source://shoulda-matchers//lib/shoulda/matchers/integrations/inclusion.rb#6
  def include_into(mod, *other_mods, &block); end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/integrations/libraries/action_controller.rb#4
module Shoulda::Matchers::Integrations::Libraries; end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/integrations/libraries/action_controller.rb#6
class Shoulda::Matchers::Integrations::Libraries::ActionController
  include ::Shoulda::Matchers::Integrations::Inclusion
  include ::Shoulda::Matchers::Integrations::Rails

  # source://shoulda-matchers//lib/shoulda/matchers/integrations/libraries/action_controller.rb#12
  def integrate_with(test_framework); end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/integrations/libraries/action_controller.rb#24
  def matchers_module; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/integrations/libraries/active_model.rb#6
class Shoulda::Matchers::Integrations::Libraries::ActiveModel
  include ::Shoulda::Matchers::Integrations::Inclusion
  include ::Shoulda::Matchers::Integrations::Rails

  # source://shoulda-matchers//lib/shoulda/matchers/integrations/libraries/active_model.rb#12
  def integrate_with(test_framework); end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/integrations/libraries/active_model.rb#19
  def matchers_module; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/integrations/libraries/active_record.rb#6
class Shoulda::Matchers::Integrations::Libraries::ActiveRecord
  include ::Shoulda::Matchers::Integrations::Inclusion
  include ::Shoulda::Matchers::Integrations::Rails

  # source://shoulda-matchers//lib/shoulda/matchers/integrations/libraries/active_record.rb#12
  def integrate_with(test_framework); end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/integrations/libraries/active_record.rb#19
  def matchers_module; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/integrations/libraries/missing_library.rb#6
class Shoulda::Matchers::Integrations::Libraries::MissingLibrary
  # source://shoulda-matchers//lib/shoulda/matchers/integrations/libraries/missing_library.rb#9
  def integrate_with(test_framework); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/integrations/libraries/missing_library.rb#12
  def rails?; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/integrations/libraries/rails.rb#6
class Shoulda::Matchers::Integrations::Libraries::Rails
  include ::Shoulda::Matchers::Integrations::Rails

  # source://shoulda-matchers//lib/shoulda/matchers/integrations/libraries/rails.rb#18
  def integrate_with(test_framework); end
end

# source://shoulda-matchers//lib/shoulda/matchers/integrations/libraries/rails.rb#11
Shoulda::Matchers::Integrations::Libraries::Rails::SUB_LIBRARIES = T.let(T.unsafe(nil), Array)

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/integrations/libraries/routing.rb#6
class Shoulda::Matchers::Integrations::Libraries::Routing
  include ::Shoulda::Matchers::Integrations::Inclusion
  include ::Shoulda::Matchers::Integrations::Rails

  # source://shoulda-matchers//lib/shoulda/matchers/integrations/libraries/routing.rb#12
  def integrate_with(test_framework); end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/integrations/libraries/routing.rb#20
  def matchers_module; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/integrations/rails.rb#5
module Shoulda::Matchers::Integrations::Rails
  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/integrations/rails.rb#6
  def rails?; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/integrations/registry.rb#5
class Shoulda::Matchers::Integrations::Registry
  # source://shoulda-matchers//lib/shoulda/matchers/integrations/registry.rb#10
  def find!(name); end

  # source://shoulda-matchers//lib/shoulda/matchers/integrations/registry.rb#6
  def register(klass, name); end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/integrations/registry.rb#20
  def find_class!(name); end

  # source://shoulda-matchers//lib/shoulda/matchers/integrations/registry.rb#16
  def registry; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/integrations/test_frameworks/active_support_test_case.rb#4
module Shoulda::Matchers::Integrations::TestFrameworks; end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/integrations/test_frameworks/active_support_test_case.rb#6
class Shoulda::Matchers::Integrations::TestFrameworks::ActiveSupportTestCase
  # source://shoulda-matchers//lib/shoulda/matchers/integrations/test_frameworks/active_support_test_case.rb#12
  def include(*modules, **_options); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/integrations/test_frameworks/active_support_test_case.rb#16
  def n_unit?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/integrations/test_frameworks/active_support_test_case.rb#20
  def present?; end

  # source://shoulda-matchers//lib/shoulda/matchers/integrations/test_frameworks/active_support_test_case.rb#9
  def validate!; end

  protected

  # Returns the value of attribute configuration.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/integrations/test_frameworks/active_support_test_case.rb#26
  def configuration; end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/integrations/test_frameworks/active_support_test_case.rb#30
  def test_case_class; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/integrations/test_frameworks/minitest_4.rb#6
class Shoulda::Matchers::Integrations::TestFrameworks::Minitest4
  # source://shoulda-matchers//lib/shoulda/matchers/integrations/test_frameworks/minitest_4.rb#12
  def include(*modules, **_options); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/integrations/test_frameworks/minitest_4.rb#19
  def n_unit?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/integrations/test_frameworks/minitest_4.rb#23
  def present?; end

  # source://shoulda-matchers//lib/shoulda/matchers/integrations/test_frameworks/minitest_4.rb#9
  def validate!; end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/integrations/test_frameworks/minitest_4.rb#29
  def test_case_class; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/integrations/test_frameworks/minitest_5.rb#6
class Shoulda::Matchers::Integrations::TestFrameworks::Minitest5
  # source://shoulda-matchers//lib/shoulda/matchers/integrations/test_frameworks/minitest_5.rb#13
  def include(*modules, **_options); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/integrations/test_frameworks/minitest_5.rb#20
  def n_unit?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/integrations/test_frameworks/minitest_5.rb#24
  def present?; end

  # source://shoulda-matchers//lib/shoulda/matchers/integrations/test_frameworks/minitest_5.rb#10
  def validate!; end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/integrations/test_frameworks/minitest_5.rb#30
  def test_case_class; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/integrations/test_frameworks/missing_test_framework.rb#6
class Shoulda::Matchers::Integrations::TestFrameworks::MissingTestFramework
  # source://shoulda-matchers//lib/shoulda/matchers/integrations/test_frameworks/missing_test_framework.rb#26
  def include(*modules, **options); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/integrations/test_frameworks/missing_test_framework.rb#29
  def n_unit?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/integrations/test_frameworks/missing_test_framework.rb#33
  def present?; end

  # @raise [TestFrameworkNotConfigured]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/integrations/test_frameworks/missing_test_framework.rb#9
  def validate!; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/integrations/test_frameworks/rspec.rb#6
class Shoulda::Matchers::Integrations::TestFrameworks::Rspec
  # source://shoulda-matchers//lib/shoulda/matchers/integrations/test_frameworks/rspec.rb#12
  def include(*modules, **options); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/integrations/test_frameworks/rspec.rb#18
  def n_unit?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/integrations/test_frameworks/rspec.rb#22
  def present?; end

  # source://shoulda-matchers//lib/shoulda/matchers/integrations/test_frameworks/rspec.rb#9
  def validate!; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/integrations/test_frameworks/test_unit.rb#6
class Shoulda::Matchers::Integrations::TestFrameworks::TestUnit
  # source://shoulda-matchers//lib/shoulda/matchers/integrations/test_frameworks/test_unit.rb#12
  def include(*modules, **_options); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/integrations/test_frameworks/test_unit.rb#19
  def n_unit?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/integrations/test_frameworks/test_unit.rb#23
  def present?; end

  # source://shoulda-matchers//lib/shoulda/matchers/integrations/test_frameworks/test_unit.rb#9
  def validate!; end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/integrations/test_frameworks/test_unit.rb#29
  def test_case_class; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/util/word_wrap.rb#116
class Shoulda::Matchers::Line
  # @return [Line] a new instance of Line
  #
  # source://shoulda-matchers//lib/shoulda/matchers/util/word_wrap.rb#119
  def initialize(line, indent: T.unsafe(nil)); end

  # source://shoulda-matchers//lib/shoulda/matchers/util/word_wrap.rb#126
  def wrap; end

  protected

  # Returns the value of attribute indent.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/util/word_wrap.rb#156
  def indent; end

  # Returns the value of attribute indentation.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/util/word_wrap.rb#156
  def indentation; end

  # Returns the value of attribute line_to_wrap.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/util/word_wrap.rb#156
  def line_to_wrap; end

  # Returns the value of attribute original_line.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/util/word_wrap.rb#156
  def original_line; end

  # Returns the value of attribute previous_line_to_wrap.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/util/word_wrap.rb#156
  def previous_line_to_wrap; end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/util/word_wrap.rb#194
  def determine_where_to_break_line(line, args); end

  # source://shoulda-matchers//lib/shoulda/matchers/util/word_wrap.rb#206
  def normalize_whitespace(string); end

  # source://shoulda-matchers//lib/shoulda/matchers/util/word_wrap.rb#161
  def read_indentation; end

  # source://shoulda-matchers//lib/shoulda/matchers/util/word_wrap.rb#172
  def wrap_line(line); end
end

# source://shoulda-matchers//lib/shoulda/matchers/util/word_wrap.rb#117
Shoulda::Matchers::Line::OFFSETS = T.let(T.unsafe(nil), Hash)

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/matcher_context.rb#4
class Shoulda::Matchers::MatcherContext
  # @return [MatcherContext] a new instance of MatcherContext
  #
  # source://shoulda-matchers//lib/shoulda/matchers/matcher_context.rb#5
  def initialize(context); end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/matcher_context.rb#9
  def subject_is_a_class?; end

  protected

  # Returns the value of attribute context.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/matcher_context.rb#19
  def context; end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/matcher_context.rb#31
  def assume_that_subject_is_not_a_class; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/matcher_context.rb#23
  def inside_a_shoulda_context_project?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/matcher_context.rb#27
  def outside_a_should_block?; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/util/word_wrap.rb#60
class Shoulda::Matchers::Paragraph
  # @return [Paragraph] a new instance of Paragraph
  #
  # source://shoulda-matchers//lib/shoulda/matchers/util/word_wrap.rb#61
  def initialize(paragraph, indent: T.unsafe(nil)); end

  # source://shoulda-matchers//lib/shoulda/matchers/util/word_wrap.rb#66
  def wrap; end

  protected

  # Returns the value of attribute indent.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/util/word_wrap.rb#78
  def indent; end

  # Returns the value of attribute paragraph.
  #
  # source://shoulda-matchers//lib/shoulda/matchers/util/word_wrap.rb#78
  def paragraph; end

  private

  # source://shoulda-matchers//lib/shoulda/matchers/util/word_wrap.rb#90
  def combine_list_item_lines(lines); end

  # source://shoulda-matchers//lib/shoulda/matchers/util/word_wrap.rb#110
  def combine_paragraph_into_one_line; end

  # source://shoulda-matchers//lib/shoulda/matchers/util/word_wrap.rb#86
  def lines; end

  # source://shoulda-matchers//lib/shoulda/matchers/util/word_wrap.rb#106
  def wrap_generic_paragraph; end

  # source://shoulda-matchers//lib/shoulda/matchers/util/word_wrap.rb#102
  def wrap_lines(lines); end

  # source://shoulda-matchers//lib/shoulda/matchers/util/word_wrap.rb#82
  def wrap_list_item; end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/rails_shim.rb#4
module Shoulda::Matchers::RailsShim
  class << self
    # @return [Boolean]
    #
    # source://shoulda-matchers//lib/shoulda/matchers/rails_shim.rb#6
    def action_pack_gte_5?; end

    # @return [Boolean]
    #
    # source://shoulda-matchers//lib/shoulda/matchers/rails_shim.rb#10
    def action_pack_lt_5?; end

    # source://shoulda-matchers//lib/shoulda/matchers/rails_shim.rb#14
    def action_pack_version; end

    # @return [Boolean]
    #
    # source://shoulda-matchers//lib/shoulda/matchers/rails_shim.rb#20
    def active_record_gte_5?; end

    # @return [Boolean]
    #
    # source://shoulda-matchers//lib/shoulda/matchers/rails_shim.rb#24
    def active_record_gte_6?; end

    # source://shoulda-matchers//lib/shoulda/matchers/rails_shim.rb#28
    def active_record_version; end

    # source://shoulda-matchers//lib/shoulda/matchers/rails_shim.rb#84
    def attribute_serialization_coder_for(model, attribute_name); end

    # source://shoulda-matchers//lib/shoulda/matchers/rails_shim.rb#159
    def attribute_type_for(model, attribute_name); end

    # source://shoulda-matchers//lib/shoulda/matchers/rails_shim.rb#145
    def attribute_types_for(model); end

    # source://shoulda-matchers//lib/shoulda/matchers/rails_shim.rb#125
    def digestible_attributes_in(record); end

    # source://shoulda-matchers//lib/shoulda/matchers/rails_shim.rb#34
    def generate_validation_message(record, attribute, type, model_name, options); end

    # @return [Boolean]
    #
    # source://shoulda-matchers//lib/shoulda/matchers/rails_shim.rb#116
    def has_secure_password?(record, attribute_name); end

    # source://shoulda-matchers//lib/shoulda/matchers/rails_shim.rb#60
    def make_controller_request(context, verb, action, request_params); end

    # source://shoulda-matchers//lib/shoulda/matchers/rails_shim.rb#108
    def parent_of(mod); end

    # source://shoulda-matchers//lib/shoulda/matchers/rails_shim.rb#139
    def secure_password_module; end

    # source://shoulda-matchers//lib/shoulda/matchers/rails_shim.rb#71
    def serialized_attributes_for(model); end

    # @return [Boolean]
    #
    # source://shoulda-matchers//lib/shoulda/matchers/rails_shim.rb#169
    def supports_full_attributes_api?(model); end

    # source://shoulda-matchers//lib/shoulda/matchers/rails_shim.rb#88
    def tables_and_views(connection); end

    # source://shoulda-matchers//lib/shoulda/matchers/rails_shim.rb#100
    def validation_message_key_for_association_required_option; end

    # source://shoulda-matchers//lib/shoulda/matchers/rails_shim.rb#96
    def verb_for_update; end

    private

    # source://shoulda-matchers//lib/shoulda/matchers/rails_shim.rb#176
    def simply_generate_validation_message(attribute, type, model_name, options); end
  end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/routing.rb#4
module Shoulda::Matchers::Routing
  # source://shoulda-matchers//lib/shoulda/matchers/routing.rb#5
  def route(method, path, port: T.unsafe(nil)); end
end

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/warn.rb#4
Shoulda::Matchers::TERMINAL_MAX_WIDTH = T.let(T.unsafe(nil), Integer)

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/util/word_wrap.rb#43
class Shoulda::Matchers::Text < ::String
  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/util/word_wrap.rb#46
  def indented?; end

  # @return [Boolean]
  #
  # source://shoulda-matchers//lib/shoulda/matchers/util/word_wrap.rb#50
  def list_item?; end

  # source://shoulda-matchers//lib/shoulda/matchers/util/word_wrap.rb#54
  def match_as_list_item; end
end

# source://shoulda-matchers//lib/shoulda/matchers/util/word_wrap.rb#44
Shoulda::Matchers::Text::LIST_ITEM_REGEXP = T.let(T.unsafe(nil), Regexp)

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/util.rb#6
module Shoulda::Matchers::Util
  class << self
    # source://shoulda-matchers//lib/shoulda/matchers/util.rb#42
    def a_or_an(next_word); end

    # source://shoulda-matchers//lib/shoulda/matchers/util.rb#9
    def deconstantize(path); end

    # source://shoulda-matchers//lib/shoulda/matchers/util.rb#88
    def dummy_value_for(column_type, array: T.unsafe(nil)); end

    # source://shoulda-matchers//lib/shoulda/matchers/util.rb#35
    def indent(string, width); end

    # source://shoulda-matchers//lib/shoulda/matchers/util.rb#74
    def inspect_hash(hash); end

    # source://shoulda-matchers//lib/shoulda/matchers/util.rb#70
    def inspect_range(range); end

    # source://shoulda-matchers//lib/shoulda/matchers/util.rb#50
    def inspect_value(value); end

    # source://shoulda-matchers//lib/shoulda/matchers/util.rb#66
    def inspect_values(values); end

    # source://shoulda-matchers//lib/shoulda/matchers/util.rb#20
    def safe_constantize(camel_cased_word); end
  end
end

# source://shoulda-matchers//lib/shoulda/matchers/util.rb#7
Shoulda::Matchers::Util::MAXIMUM_LENGTH_OF_VALUE_TO_DISPLAY = T.let(T.unsafe(nil), Integer)

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/version.rb#4
Shoulda::Matchers::VERSION = T.let(T.unsafe(nil), String)

# @private
#
# source://shoulda-matchers//lib/shoulda/matchers/util/word_wrap.rb#4
module Shoulda::Matchers::WordWrap
  # source://shoulda-matchers//lib/shoulda/matchers/util/word_wrap.rb#7
  def word_wrap(document, options = T.unsafe(nil)); end
end

# source://shoulda-matchers//lib/shoulda/matchers/util/word_wrap.rb#5
Shoulda::Matchers::WordWrap::TERMINAL_WIDTH = T.let(T.unsafe(nil), Integer)
