# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `good_job` gem.
# Please instead update this file by running `bin/tapioca gem good_job`.


# source://good_job//lib/active_job/queue_adapters/good_job_adapter.rb#3
module ActiveJob
  class << self
    # source://activejob/7.2.1.1/lib/active_job/queue_adapter.rb#7
    def adapter_name(adapter); end

    # source://activejob/7.2.1.1/lib/active_job/deprecator.rb#4
    def deprecator; end

    # source://activejob/7.2.1.1/lib/active_job/gem_version.rb#5
    def gem_version; end

    # source://activejob/7.2.1.1/lib/active_job/enqueuing.rb#14
    def perform_all_later(*jobs); end

    # source://activejob/7.2.1.1/lib/active_job.rb#52
    def use_big_decimal_serializer; end

    # source://activejob/7.2.1.1/lib/active_job.rb#58
    def use_big_decimal_serializer=(value); end

    # source://activejob/7.2.1.1/lib/active_job.rb#69
    def verbose_enqueue_logs; end

    # source://activejob/7.2.1.1/lib/active_job.rb#69
    def verbose_enqueue_logs=(_arg0); end

    # source://activejob/7.2.1.1/lib/active_job/version.rb#7
    def version; end

    private

    # source://activejob/7.2.1.1/lib/active_job/instrumentation.rb#6
    def instrument_enqueue_all(queue_adapter, jobs); end
  end
end

# source://good_job//lib/active_job/queue_adapters/good_job_adapter.rb#4
module ActiveJob::QueueAdapters
  class << self
    # source://activejob/7.2.1.1/lib/active_job/queue_adapters.rb#138
    def lookup(name); end
  end
end

# See {GoodJob::Adapter} for details.
#
# source://good_job//lib/active_job/queue_adapters/good_job_adapter.rb#6
class ActiveJob::QueueAdapters::GoodJobAdapter < ::GoodJob::Adapter; end

# GoodJob is a multithreaded, Postgres-based, ActiveJob backend for Ruby on Rails.
#
# +GoodJob+ is the top-level namespace and exposes configuration attributes.
#
# source://good_job//lib/good_job/version.rb#3
module GoodJob
  include ::GoodJob::Dependencies
  include ::GoodJob::ThreadStatus
  extend ::GoodJob::Dependencies::ClassMethods
  extend ::GoodJob::ThreadStatus::ClassMethods

  # source://good_job//lib/good_job.rb#138
  def _active_record_configuration; end

  # source://good_job//lib/good_job.rb#138
  def _active_record_configuration=(val); end

  # source://good_job//lib/good_job/dependencies.rb#9
  def _framework_ready; end

  # source://good_job//lib/good_job/dependencies.rb#9
  def _framework_ready=(val); end

  # source://good_job//lib/good_job.rb#67
  def active_record_parent_class; end

  # source://good_job//lib/good_job.rb#67
  def active_record_parent_class=(val); end

  # source://good_job//lib/good_job.rb#117
  def capsule; end

  # source://good_job//lib/good_job.rb#117
  def capsule=(val); end

  # source://good_job//lib/good_job.rb#111
  def configuration; end

  # source://good_job//lib/good_job.rb#111
  def configuration=(val); end

  # source://good_job//lib/good_job.rb#76
  def logger; end

  # source://good_job//lib/good_job.rb#76
  def logger=(val); end

  # source://good_job//lib/good_job.rb#105
  def on_thread_error; end

  # source://good_job//lib/good_job.rb#105
  def on_thread_error=(val); end

  # source://good_job//lib/good_job.rb#86
  def preserve_job_records; end

  # source://good_job//lib/good_job.rb#86
  def preserve_job_records=(val); end

  # source://good_job//lib/good_job.rb#95
  def retry_on_unhandled_error; end

  # source://good_job//lib/good_job.rb#95
  def retry_on_unhandled_error=(val); end

  class << self
    # source://good_job//lib/good_job.rb#138
    def _active_record_configuration; end

    # source://good_job//lib/good_job.rb#138
    def _active_record_configuration=(val); end

    # source://good_job//lib/good_job/dependencies.rb#9
    def _framework_ready; end

    # source://good_job//lib/good_job/dependencies.rb#9
    def _framework_ready=(val); end

    # Called with exception when a GoodJob thread raises an exception
    #
    # @param exception [Exception] Exception that was raised
    # @return [void]
    #
    # source://good_job//lib/good_job.rb#122
    def _on_thread_error(exception); end

    # Sends +#shutdown+ or +#restart+ to executable objects ({GoodJob::Notifier}, {GoodJob::Poller}, {GoodJob::Scheduler}, {GoodJob::MultiScheduler}, {GoodJob::CronManager}, {GoodJob::SharedExecutor})
    #
    # @param executables [Array<Notifier, Poller, Scheduler, MultiScheduler, CronManager, SharedExecutor>] Objects to shut down.
    # @param method_name [Symbol] Method to call, e.g. +:shutdown+ or +:restart+.
    # @param timeout [nil, Numeric] Seconds to wait for actively executing jobs to finish.
    # @param after [Array<Notifier, Poller, Scheduler, MultiScheduler, CronManager, SharedExecutor>] Objects to shut down after initial executables shut down.
    # @return [void]
    #
    # source://good_job//lib/good_job.rb#180
    def _shutdown_all(executables, method_name = T.unsafe(nil), timeout: T.unsafe(nil), after: T.unsafe(nil)); end

    # The ActiveRecord parent class inherited by +GoodJob::Job+ (default: +ActiveRecord::Base+).
    # Use this when using multiple databases or other custom ActiveRecord configuration.
    #
    # @example Change the base class:
    #   GoodJob.active_record_parent_class = "CustomApplicationRecord"
    # @return [ActiveRecord::Base]
    #
    # source://good_job//lib/good_job.rb#67
    def active_record_parent_class; end

    # The ActiveRecord parent class inherited by +GoodJob::Job+ (default: +ActiveRecord::Base+).
    # Use this when using multiple databases or other custom ActiveRecord configuration.
    #
    # @example Change the base class:
    #   GoodJob.active_record_parent_class = "CustomApplicationRecord"
    # @return [ActiveRecord::Base]
    #
    # source://good_job//lib/good_job.rb#67
    def active_record_parent_class=(val); end

    # Global/default execution capsule for GoodJob.
    #
    # @return [GoodJob::Capsule, nil]
    #
    # source://good_job//lib/good_job.rb#117
    def capsule; end

    # Global/default execution capsule for GoodJob.
    #
    # @return [GoodJob::Capsule, nil]
    #
    # source://good_job//lib/good_job.rb#117
    def capsule=(val); end

    # Destroys preserved job and batch records.
    # By default, GoodJob destroys job records when the job is performed and this
    # method is not necessary. However, when `GoodJob.preserve_job_records = true`,
    # the jobs will be preserved in the database. This is useful when wanting to
    # analyze or inspect job performance.
    # If you are preserving job records this way, use this method regularly to
    # destroy old records and preserve space in your database.
    #
    # @param older_than [nil, Numeric, ActiveSupport::Duration] Jobs older than this will be destroyed (default: +86400+).
    # @return [Integer] Number of job execution records and batches that were destroyed.
    #
    # source://good_job//lib/good_job.rb#207
    def cleanup_preserved_jobs(older_than: T.unsafe(nil), in_batches_of: T.unsafe(nil)); end

    # Global configuration object for GoodJob.
    #
    # @return [GoodJob::Configuration, nil]
    #
    # source://good_job//lib/good_job.rb#111
    def configuration; end

    # Global configuration object for GoodJob.
    #
    # @return [GoodJob::Configuration, nil]
    #
    # source://good_job//lib/good_job.rb#111
    def configuration=(val); end

    # Custom Active Record configuration that is class_eval'ed into +GoodJob::BaseRecord+
    #
    # @example
    #   GoodJob.configure_active_record do
    #   connects_to database: :special_database
    #   end
    # @param block Custom Active Record configuration
    # @return [void]
    #
    # source://good_job//lib/good_job.rb#134
    def configure_active_record(&block); end

    # Deprecator for providing deprecation warnings.
    #
    # @return [ActiveSupport::Deprecation]
    #
    # source://good_job//lib/good_job.rb#282
    def deprecator; end

    # The logger used by GoodJob (default: +Rails.logger+).
    # Use this to redirect logs to a special location or file.
    #
    # @example Output GoodJob logs to a file:
    #   GoodJob.logger = ActiveSupport::TaggedLogging.new(ActiveSupport::Logger.new("log/my_logs.log"))
    # @return [Logger, nil]
    #
    # source://good_job//lib/good_job.rb#76
    def logger; end

    # The logger used by GoodJob (default: +Rails.logger+).
    # Use this to redirect logs to a special location or file.
    #
    # @example Output GoodJob logs to a file:
    #   GoodJob.logger = ActiveSupport::TaggedLogging.new(ActiveSupport::Logger.new("log/my_logs.log"))
    # @return [Logger, nil]
    #
    # source://good_job//lib/good_job.rb#76
    def logger=(val); end

    # Whether all GoodJob migrations have been applied.
    # For use in tests/CI to validate GoodJob is up-to-date.
    #
    # @return [Boolean]
    #
    # source://good_job//lib/good_job.rb#292
    def migrated?; end

    # This callable will be called when an exception reaches GoodJob (default: +nil+).
    # It can be useful for logging errors to bug tracking services, like Sentry or Airbrake.
    #
    # @example Send errors to Sentry
    #   # config/initializers/good_job.rb
    #   GoodJob.on_thread_error = -> (exception) { Raven.capture_exception(exception) }
    # @return [Proc, nil]
    #
    # source://good_job//lib/good_job.rb#105
    def on_thread_error; end

    # This callable will be called when an exception reaches GoodJob (default: +nil+).
    # It can be useful for logging errors to bug tracking services, like Sentry or Airbrake.
    #
    # @example Send errors to Sentry
    #   # config/initializers/good_job.rb
    #   GoodJob.on_thread_error = -> (exception) { Raven.capture_exception(exception) }
    # @return [Proc, nil]
    #
    # source://good_job//lib/good_job.rb#105
    def on_thread_error=(val); end

    # Perform all queued jobs in the current thread.
    # This is primarily intended for usage in a test environment.
    # Unhandled job errors will be raised.
    #
    # @param queue_string [String] Queues to execute jobs from
    # @param limit [Integer, nil] Maximum number of iterations for the loop
    # @return [void]
    #
    # source://good_job//lib/good_job.rb#256
    def perform_inline(queue_string = T.unsafe(nil), limit: T.unsafe(nil)); end

    # Whether to preserve job records in the database after they have finished (default: +true+).
    # If you want to preserve jobs for latter inspection, set this to +true+.
    # If you want to preserve only jobs that finished with error for latter inspection, set this to +:on_unhandled_error+.
    # If you do not want to preserve jobs, set this to +false+.
    # When using GoodJob's cron functionality, job records will be preserved for a brief time to prevent duplicate jobs.
    #
    # @return [Boolean, Symbol, nil]
    #
    # source://good_job//lib/good_job.rb#86
    def preserve_job_records; end

    # Whether to preserve job records in the database after they have finished (default: +true+).
    # If you want to preserve jobs for latter inspection, set this to +true+.
    # If you want to preserve only jobs that finished with error for latter inspection, set this to +:on_unhandled_error+.
    # If you do not want to preserve jobs, set this to +false+.
    # When using GoodJob's cron functionality, job records will be preserved for a brief time to prevent duplicate jobs.
    #
    # @return [Boolean, Symbol, nil]
    #
    # source://good_job//lib/good_job.rb#86
    def preserve_job_records=(val); end

    # source://railties/7.2.1.1/lib/rails/engine.rb#412
    def railtie_helpers_paths; end

    # source://railties/7.2.1.1/lib/rails/engine.rb#395
    def railtie_namespace; end

    # source://railties/7.2.1.1/lib/rails/engine.rb#416
    def railtie_routes_url_helpers(include_path_helpers = T.unsafe(nil)); end

    # Stops and restarts executing jobs.
    # GoodJob does its work in pools of background threads.
    # When forking processes you should shut down these background threads before forking, and restart them after forking.
    # For example, you should use +shutdown+ and +restart+ when using async execution mode with Puma.
    # See the {file:README.md#executing-jobs-async--in-process} for more explanation and examples.
    #
    # @param timeout [Numeric] Seconds to wait for active threads to finish.
    # @return [void]
    #
    # source://good_job//lib/good_job.rb#168
    def restart(timeout: T.unsafe(nil)); end

    # Whether to re-perform a job when a type of +StandardError+ is raised to GoodJob (default: +false+).
    # If +true+, causes jobs to be re-queued and retried if they raise an instance of +StandardError+.
    # If +false+, jobs will be discarded or marked as finished if they raise an instance of +StandardError+.
    # Instances of +Exception+, like +SIGINT+, will *always* be retried, regardless of this attribute's value.
    #
    # @return [Boolean, nil]
    #
    # source://good_job//lib/good_job.rb#95
    def retry_on_unhandled_error; end

    # Whether to re-perform a job when a type of +StandardError+ is raised to GoodJob (default: +false+).
    # If +true+, causes jobs to be re-queued and retried if they raise an instance of +StandardError+.
    # If +false+, jobs will be discarded or marked as finished if they raise an instance of +StandardError+.
    # Instances of +Exception+, like +SIGINT+, will *always* be retried, regardless of this attribute's value.
    #
    # @return [Boolean, nil]
    #
    # source://good_job//lib/good_job.rb#95
    def retry_on_unhandled_error=(val); end

    # Stop executing jobs.
    # GoodJob does its work in pools of background threads.
    # When forking processes you should shut down these background threads before forking, and restart them after forking.
    # For example, you should use +shutdown+ and +restart+ when using async execution mode with Puma.
    # See the {file:README.md#executing-jobs-async--in-process} for more explanation and examples.
    #
    # @param timeout [nil, Numeric] Seconds to wait for actively executing jobs to finish
    #   * +nil+, the scheduler will trigger a shutdown but not wait for it to complete.
    #   * +-1+, the scheduler will wait until the shutdown is complete.
    #   * +0+, the scheduler will immediately shutdown and stop any active tasks.
    #   * +1..+, the scheduler will wait that many seconds before stopping any remaining active tasks.
    # @return [void]
    #
    # source://good_job//lib/good_job.rb#151
    def shutdown(timeout: T.unsafe(nil)); end

    # Tests whether jobs have stopped executing.
    #
    # @return [Boolean] whether background threads are shut down
    #
    # source://good_job//lib/good_job.rb#157
    def shutdown?; end

    # source://railties/7.2.1.1/lib/rails/engine.rb#401
    def table_name_prefix; end

    # source://railties/7.2.1.1/lib/rails/engine.rb#408
    def use_relative_model_naming?; end

    # Tests whether GoodJob can be safely upgraded to v4
    #
    # @return [Boolean]
    #
    # source://good_job//lib/good_job.rb#272
    def v4_ready?; end
  end
end

# source://good_job//lib/good_job/active_job_extensions/batches.rb#4
module GoodJob::ActiveJobExtensions; end

# source://good_job//lib/good_job/active_job_extensions/batches.rb#5
module GoodJob::ActiveJobExtensions::Batches
  extend ::ActiveSupport::Concern

  # source://good_job//lib/good_job/active_job_extensions/batches.rb#14
  def batch; end

  # source://good_job//lib/good_job/active_job_extensions/batches.rb#14
  def batch?; end
end

# source://good_job//lib/good_job/active_job_extensions/concurrency.rb#5
module GoodJob::ActiveJobExtensions::Concurrency
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::GoodJob::ActiveJobExtensions::Concurrency::ClassMethods

  # Generates the concurrency key from the configuration
  #
  # @raise [TypeError]
  # @return [Object] concurrency key
  #
  # source://good_job//lib/good_job/active_job_extensions/concurrency.rb#202
  def _good_job_concurrency_key; end

  # Generates the default concurrency key when the configuration doesn't provide one
  #
  # @return [String] concurrency key
  #
  # source://good_job//lib/good_job/active_job_extensions/concurrency.rb#216
  def _good_job_default_concurrency_key; end

  # Existing or dynamically generated concurrency key
  #
  # @return [Object] concurrency key
  #
  # source://good_job//lib/good_job/active_job_extensions/concurrency.rb#196
  def good_job_concurrency_key; end

  module GeneratedClassMethods
    def good_job_concurrency_config; end
    def good_job_concurrency_config=(value); end
    def good_job_concurrency_config?; end
  end

  module GeneratedInstanceMethods; end
end

# source://good_job//lib/good_job/active_job_extensions/concurrency.rb#0
module GoodJob::ActiveJobExtensions::Concurrency::ClassMethods
  # source://good_job//lib/good_job/active_job_extensions/concurrency.rb#189
  def good_job_control_concurrency_with(config); end
end

# source://good_job//lib/good_job/active_job_extensions/concurrency.rb#10
class GoodJob::ActiveJobExtensions::Concurrency::ConcurrencyExceededError < ::StandardError
  # source://good_job//lib/good_job/active_job_extensions/concurrency.rb#11
  def backtrace; end
end

# source://good_job//lib/good_job/active_job_extensions/concurrency.rb#18
module GoodJob::ActiveJobExtensions::Concurrency::Prepends
  # source://good_job//lib/good_job/active_job_extensions/concurrency.rb#19
  def deserialize(job_data); end
end

# source://good_job//lib/good_job/active_job_extensions/concurrency.rb#16
class GoodJob::ActiveJobExtensions::Concurrency::ThrottleExceededError < ::GoodJob::ActiveJobExtensions::Concurrency::ConcurrencyExceededError; end

# source://good_job//lib/good_job/active_job_extensions/concurrency.rb#8
GoodJob::ActiveJobExtensions::Concurrency::VALID_TYPES = T.let(T.unsafe(nil), Array)

# source://good_job//lib/good_job/active_job_extensions/interrupt_errors.rb#5
module GoodJob::ActiveJobExtensions::InterruptErrors
  extend ::ActiveSupport::Concern
end

# source://good_job//lib/good_job/active_job_extensions/labels.rb#5
module GoodJob::ActiveJobExtensions::Labels
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods

  module GeneratedClassMethods
    def good_job_labels; end
    def good_job_labels=(value); end
  end

  module GeneratedInstanceMethods; end
end

# source://good_job//lib/good_job/active_job_extensions/labels.rb#8
module GoodJob::ActiveJobExtensions::Labels::Prepends
  # source://good_job//lib/good_job/active_job_extensions/labels.rb#9
  def initialize(*_arg0, **_arg1, &_arg2); end

  # source://good_job//lib/good_job/active_job_extensions/labels.rb#19
  def deserialize(job_data); end

  # source://good_job//lib/good_job/active_job_extensions/labels.rb#14
  def enqueue(options = T.unsafe(nil)); end
end

# Allows configuring whether GoodJob should emit a NOTIFY event when a job is enqueued.
# Configuration will apply either globally to the Job Class, or individually to jobs
# on initial enqueue and subsequent retries.
#
# @example
#   # Include the concern to your job class:
#   class MyJob < ApplicationJob
#   include GoodJob::ActiveJobExtensions::NotifyOptions
#   self.good_job_notify = false
#   end
#
#   # Or, configure jobs individually to not notify:
#   MyJob.set(good_job_notify: false).perform_later
#
# source://good_job//lib/good_job/active_job_extensions/notify_options.rb#19
module GoodJob::ActiveJobExtensions::NotifyOptions
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods

  module GeneratedClassMethods
    def good_job_notify; end
    def good_job_notify=(value); end
  end

  module GeneratedInstanceMethods; end
end

# source://good_job//lib/good_job/active_job_extensions/notify_options.rb#22
module GoodJob::ActiveJobExtensions::NotifyOptions::Prepends
  # source://good_job//lib/good_job/active_job_extensions/notify_options.rb#35
  def deserialize(job_data); end

  # source://good_job//lib/good_job/active_job_extensions/notify_options.rb#23
  def enqueue(options = T.unsafe(nil)); end

  # source://good_job//lib/good_job/active_job_extensions/notify_options.rb#28
  def serialize; end
end

# ActiveJob Adapter.
#
# source://good_job//lib/good_job/adapter.rb#7
class GoodJob::Adapter
  # @param execution_mode [Symbol, nil] specifies how and where jobs should be executed. You can also set this with the environment variable +GOOD_JOB_EXECUTION_MODE+.
  #
  #   - +:inline+ executes jobs immediately in whatever process queued them (usually the web server process). This should only be used in test and development environments.
  #   - +:external+ causes the adapter to enqueue jobs, but not execute them. When using this option (the default for production environments), you'll need to use the command-line tool to actually execute your jobs.
  #   - +:async+ (or +:async_server+) executes jobs in separate threads within the Rails web server process (`bundle exec rails server`). It can be more economical for small workloads because you don't need a separate machine or environment for running your jobs, but if your web server is under heavy load or your jobs require a lot of resources, you should choose +:external+ instead.
  #   When not in the Rails web server, jobs will execute in +:external+ mode to ensure jobs are not executed within `rails console`, `rails db:migrate`, `rails assets:prepare`, etc.
  #   - +:async_all+ executes jobs in any Rails process.
  #
  #   The default value depends on the Rails environment:
  #
  #   - +development+: +:async:+
  #   -+test+: +:inline+
  #   - +production+ and all other environments: +:external+
  # @return [Adapter] a new instance of Adapter
  #
  # source://good_job//lib/good_job/adapter.rb#28
  def initialize(execution_mode: T.unsafe(nil), _capsule: T.unsafe(nil)); end

  # Whether the async executors are running
  #
  # @return [Boolean]
  #
  # source://good_job//lib/good_job/adapter.rb#224
  def async_started?; end

  # Enqueues the ActiveJob job to be performed.
  # For use by Rails; you should generally not call this directly.
  #
  # @param active_job [ActiveJob::Base] the job to be enqueued from +#perform_later+
  # @return [GoodJob::Job]
  #
  # source://good_job//lib/good_job/adapter.rb#41
  def enqueue(active_job); end

  # Defines if enqueueing this job from inside an Active Record transaction
  # automatically defers the enqueue to after the transaction commit.
  #
  # @return [Boolean]
  #
  # source://good_job//lib/good_job/adapter.rb#47
  def enqueue_after_transaction_commit?; end

  # Enqueues multiple ActiveJob instances at once
  #
  # @param active_jobs [Array<ActiveJob::Base>] jobs to be enqueued
  # @return [Integer] number of jobs that were successfully enqueued
  #
  # source://good_job//lib/good_job/adapter.rb#54
  def enqueue_all(active_jobs); end

  # Enqueues an ActiveJob job to be run at a specific time.
  # For use by Rails; you should generally not call this directly.
  #
  # @param active_job [ActiveJob::Base] the job to be enqueued from +#perform_later+
  # @param timestamp [Integer, nil] the epoch time to perform the job
  # @return [GoodJob::Job]
  #
  # source://good_job//lib/good_job/adapter.rb#133
  def enqueue_at(active_job, timestamp); end

  # Whether in +:async+ execution mode.
  #
  # @return [Boolean]
  #
  # source://good_job//lib/good_job/adapter.rb#194
  def execute_async?; end

  # Whether in +:external+ execution mode.
  #
  # @return [Boolean]
  #
  # source://good_job//lib/good_job/adapter.rb#201
  def execute_externally?; end

  # Whether in +:inline+ execution mode.
  #
  # @return [Boolean]
  #
  # source://good_job//lib/good_job/adapter.rb#209
  def execute_inline?; end

  # This adapter's execution mode
  #
  # @return [Symbol, nil]
  #
  # source://good_job//lib/good_job/adapter.rb#188
  def execution_mode; end

  # Shut down the thread pool executors.
  #
  # @param timeout [nil, Numeric, NONE] Seconds to wait for active threads.
  #   * +nil+ trigger a shutdown but not wait for it to complete.
  #   * +-1+ wait until the shutdown is complete.
  #   * +0+ immediately shutdown and stop any threads.
  #   * A positive number will wait that many seconds before stopping any remaining active threads.
  # @return [void]
  #
  # source://good_job//lib/good_job/adapter.rb#181
  def shutdown(timeout: T.unsafe(nil)); end

  # Start async executors
  #
  # @return [void]
  #
  # source://good_job//lib/good_job/adapter.rb#215
  def start_async; end

  private

  # @param job [GoodJob::Job] the job to perform, which must be enqueued and advisory locked already
  # @param notify [Boolean] whether to send a NOTIFY event for a retried job
  #
  # source://good_job//lib/good_job/adapter.rb#239
  def perform_inline(job, notify: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://good_job//lib/good_job/adapter.rb#230
  def send_notify?(active_job); end

  class << self
    # List of all instantiated Adapters in the current process.
    #
    # @return [Array<GoodJob::Adapter>, nil]
    #
    # source://good_job//lib/good_job/adapter.rb#12
    def instances; end
  end
end

# The InlineBuffer is integrated into the Adapter and captures jobs that have been enqueued inline.
# The purpose is allow job records to be persisted, in a locked state, while within a transaction,
# and then execute the jobs after the transaction has been committed to ensure that the jobs
# do not run within a transaction.
#
# @private This is intended for internal GoodJob usage only.
#
# source://good_job//lib/good_job/adapter/inline_buffer.rb#13
class GoodJob::Adapter::InlineBuffer
  # @return [InlineBuffer] a new instance of InlineBuffer
  #
  # source://good_job//lib/good_job/adapter/inline_buffer.rb#58
  def initialize; end

  # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#74
  def current_buffer; end

  # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#116
  def current_buffer=(obj); end

  # source://good_job//lib/good_job/adapter/inline_buffer.rb#62
  def defer(callable); end

  # source://good_job//lib/good_job/adapter/inline_buffer.rb#66
  def to_proc; end

  class << self
    # This block should be used to wrap the transaction that could enqueue jobs.
    #
    # @example Wrapping a transaction
    #   buffer = GoodJob::Adapter::InlineBuffer.capture do
    #   ActiveRecord::Base.transaction do
    #   MyJob.perform_later
    #   end
    #   end
    #   buffer.call
    # @return [Proc] A proc that will execute enqueued jobs after the transaction has been committed.
    # @yield The block that may enqueue jobs.
    #
    # source://good_job//lib/good_job/adapter/inline_buffer.rb#30
    def capture; end

    # Current buffer of jobs to be enqueued.
    #
    # @return [GoodJob::Adapter::InlineBuffer, nil]
    #
    # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#49
    def current_buffer; end

    # Current buffer of jobs to be enqueued.
    #
    # @return [GoodJob::Adapter::InlineBuffer, nil]
    #
    # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#108
    def current_buffer=(obj); end

    # @return [Boolean]
    #
    # source://good_job//lib/good_job/adapter/inline_buffer.rb#54
    def defer?; end

    # Used within the adapter to wrap inline job execution
    #
    # source://good_job//lib/good_job/adapter/inline_buffer.rb#46
    def perform_now_or_defer(&block); end
  end
end

module GoodJob::AdvisoryLockable
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::GoodJob::AdvisoryLockable::ClassMethods

  def advisory_lock(key: T.unsafe(nil), function: T.unsafe(nil)); end
  def advisory_lock!(key: T.unsafe(nil), function: T.unsafe(nil)); end
  def advisory_locked?(key: T.unsafe(nil)); end
  def advisory_unlock(key: T.unsafe(nil), function: T.unsafe(nil)); end
  def advisory_unlock!(key: T.unsafe(nil), function: T.unsafe(nil)); end
  def advisory_unlocked?(key: T.unsafe(nil)); end
  def lockable_column_key(column: T.unsafe(nil)); end
  def lockable_key; end
  def owns_advisory_lock?(key: T.unsafe(nil)); end
  def pg_or_jdbc_query(*_arg0, **_arg1, &_arg2); end
  def with_advisory_lock(key: T.unsafe(nil), function: T.unsafe(nil)); end

  module GeneratedClassMethods
    def advisory_lockable_column; end
    def advisory_lockable_column=(value); end
    def advisory_lockable_column?; end
    def advisory_lockable_function; end
    def advisory_lockable_function=(value); end
    def advisory_lockable_function?; end
  end

  module GeneratedInstanceMethods
    def advisory_lockable_function; end
    def advisory_lockable_function=(value); end
    def advisory_lockable_function?; end
  end
end

module GoodJob::AdvisoryLockable::ClassMethods
  def _advisory_lockable_column; end
  def advisory_lock_key(key, function: T.unsafe(nil)); end
  def advisory_locked_key?(key); end
  def advisory_unlock_key(key, function: T.unsafe(nil)); end
  def advisory_unlock_session; end
  def advisory_unlockable_function(function = T.unsafe(nil)); end
  def owns_advisory_lock_key?(key); end
  def pg_or_jdbc_query(query); end
  def supports_cte_materialization_specifiers?; end
  def with_advisory_lock(column: T.unsafe(nil), function: T.unsafe(nil), unlock_session: T.unsafe(nil), select_limit: T.unsafe(nil)); end
end

class GoodJob::AdvisoryLockable::RecordAlreadyAdvisoryLockedError < ::StandardError; end

class GoodJob::ApplicationController < ::ActionController::Base
  private

  # source://actionview/7.2.1.1/lib/action_view/layouts.rb#328
  def _layout(lookup_context, formats); end

  def current_locale; end
  def default_url_options(options = T.unsafe(nil)); end
  def use_good_job_locale(&action); end
  def use_original_locale; end

  class << self
    # source://activesupport/7.2.1.1/lib/active_support/callbacks.rb#70
    def __callbacks; end

    # source://actionpack/7.2.1.1/lib/action_controller/metal.rb#288
    def middleware_stack; end
  end
end

module GoodJob::ApplicationController::HelperMethods
  include ::ActionController::Base::HelperMethods
  include ::GoodJob::IconsHelper
  include ::GoodJob::ApplicationHelper
end

module GoodJob::ApplicationHelper
  include ::GoodJob::IconsHelper

  def format_duration(sec); end
  def number_to_human(count); end
  def number_with_delimiter(count); end
  def relative_time(timestamp, **options); end
  def translate_hash(key, **options); end
  def translation_exists?(key, **options); end
end

class GoodJob::BaseChart
  def start_end_binds; end
  def string_to_hsl(string); end
end

class GoodJob::BaseFilter
  def initialize(params, base_query = T.unsafe(nil)); end

  def base_query; end
  def base_query=(_arg0); end
  def filtered_count; end
  def filtered_query(filtered_params = T.unsafe(nil)); end
  def job_classes; end
  def last; end
  def params; end
  def params=(_arg0); end
  def queues; end
  def records; end
  def state_names; end
  def states; end
  def to_params(override = T.unsafe(nil)); end

  private

  def default_base_query; end
  def query_for_records; end
end

GoodJob::BaseFilter::DEFAULT_LIMIT = T.let(T.unsafe(nil), Integer)
GoodJob::BaseFilter::EMPTY = T.let(T.unsafe(nil), String)

class GoodJob::Batch
  include ::GlobalID::Identification

  def initialize(_record: T.unsafe(nil), **properties); end

  def _record; end
  def active_jobs; end
  def add(active_jobs = T.unsafe(nil), &block); end
  def assign_properties(properties); end
  def callback_active_jobs; end
  def callback_priority(*_arg0, **_arg1, &_arg2); end
  def callback_priority=(arg); end
  def callback_queue_name(*_arg0, **_arg1, &_arg2); end
  def callback_queue_name=(arg); end
  def created_at(*_arg0, **_arg1, &_arg2); end

  # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#74
  def current_batch_callback_id; end

  # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#116
  def current_batch_callback_id=(obj); end

  # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#74
  def current_batch_id; end

  # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#116
  def current_batch_id=(obj); end

  def description(*_arg0, **_arg1, &_arg2); end
  def description=(arg); end
  def discarded?(*_arg0, **_arg1, &_arg2); end
  def discarded_at(*_arg0, **_arg1, &_arg2); end
  def enqueue(active_jobs = T.unsafe(nil), **properties, &block); end
  def enqueued?(*_arg0, **_arg1, &_arg2); end
  def enqueued_at(*_arg0, **_arg1, &_arg2); end
  def finished?(*_arg0, **_arg1, &_arg2); end
  def finished_at(*_arg0, **_arg1, &_arg2); end
  def id(*_arg0, **_arg1, &_arg2); end
  def jobs_finished?(*_arg0, **_arg1, &_arg2); end
  def jobs_finished_at(*_arg0, **_arg1, &_arg2); end
  def on_discard(*_arg0, **_arg1, &_arg2); end
  def on_discard=(arg); end
  def on_finish(*_arg0, **_arg1, &_arg2); end
  def on_finish=(arg); end
  def on_success(*_arg0, **_arg1, &_arg2); end
  def on_success=(arg); end
  def persisted?(*_arg0, **_arg1, &_arg2); end
  def properties(*_arg0, **_arg1, &_arg2); end
  def properties=(arg); end
  def reload(*_arg0, **_arg1, &_arg2); end
  def retry; end
  def save(*_arg0, **_arg1, &_arg2); end
  def succeeded?(*_arg0, **_arg1, &_arg2); end
  def updated_at(*_arg0, **_arg1, &_arg2); end

  private

  def record; end
  def record=(_arg0); end

  class << self
    # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#49
    def current_batch_callback_id; end

    # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#108
    def current_batch_callback_id=(obj); end

    # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#49
    def current_batch_id; end

    # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#108
    def current_batch_id=(obj); end

    def enqueue(active_jobs = T.unsafe(nil), **properties, &block); end
    def find(id); end
    def primary_key; end
    def within_thread(batch_id: T.unsafe(nil), batch_callback_id: T.unsafe(nil)); end
  end
end

GoodJob::Batch::PROTECTED_PROPERTIES = T.let(T.unsafe(nil), Array)

class GoodJob::BatchesController < ::GoodJob::ApplicationController
  def index; end
  def retry; end
  def show; end

  private

  # source://actionview/7.2.1.1/lib/action_view/layouts.rb#328
  def _layout(lookup_context, formats); end

  class << self
    # source://actionpack/7.2.1.1/lib/action_controller/metal.rb#288
    def middleware_stack; end
  end
end

class GoodJob::BatchesFilter < ::GoodJob::BaseFilter
  def default_base_query; end
  def filtered_query(_filtered_params = T.unsafe(nil)); end
  def records; end
end

# source://good_job//lib/good_job/bulk.rb#6
module GoodJob::Bulk
  # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#74
  def current_buffer; end

  # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#116
  def current_buffer=(obj); end

  class << self
    # Capture jobs to a buffer. Pass either a block, or specific Active Jobs to be buffered.
    #
    # @param active_jobs [Array<ActiveJob::Base>] Active Jobs to be buffered.
    # @param queue_adapter Override the jobs implicit queue adapter with an explicit one.
    # @raise [ArgumentError]
    # @return [nil, Array<ActiveJob::Base>] The ActiveJob instances that have been buffered; nil if no active buffer
    #
    # source://good_job//lib/good_job/bulk.rb#19
    def capture(active_jobs = T.unsafe(nil), queue_adapter: T.unsafe(nil), &block); end

    # Current buffer of jobs to be enqueued.
    #
    # @return [GoodJob::Bulk::Buffer, nil]
    #
    # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#49
    def current_buffer; end

    # Current buffer of jobs to be enqueued.
    #
    # @return [GoodJob::Bulk::Buffer, nil]
    #
    # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#108
    def current_buffer=(obj); end

    # Capture jobs to a buffer and enqueue them all at once; or enqueue the current buffer.
    #
    # @param active_jobs [Array<ActiveJob::Base>] Active Jobs to be enqueued.
    # @raise [ArgumentError]
    # @return [Array<ActiveJob::Base>] The ActiveJob instances that have been captured; check provider_job_id to confirm enqueued.
    #
    # source://good_job//lib/good_job/bulk.rb#34
    def enqueue(active_jobs = T.unsafe(nil), &block); end

    # Temporarily unset the current buffer; used to enqueue buffered jobs.
    #
    # @return [void]
    #
    # source://good_job//lib/good_job/bulk.rb#54
    def unbuffer; end
  end
end

# source://good_job//lib/good_job/bulk.rb#62
class GoodJob::Bulk::Buffer
  # @return [Buffer] a new instance of Buffer
  #
  # source://good_job//lib/good_job/bulk.rb#63
  def initialize; end

  # source://good_job//lib/good_job/bulk.rb#120
  def active_jobs; end

  # source://good_job//lib/good_job/bulk.rb#113
  def active_jobs_by_queue_adapter; end

  # source://good_job//lib/good_job/bulk.rb#75
  def add(active_jobs, queue_adapter: T.unsafe(nil)); end

  # source://good_job//lib/good_job/bulk.rb#67
  def capture; end

  # source://good_job//lib/good_job/bulk.rb#89
  def enqueue; end
end

# source://good_job//lib/good_job/bulk.rb#7
class GoodJob::Bulk::Error < ::StandardError; end

# Implements the +good_job+ command-line tool, which executes jobs and
# provides other utilities. The actual entry point is in +exe/good_job+, but
# it just sets up and calls this class.
#
# The +good_job+ command-line tool is based on Thor, a CLI framework for
# Ruby. For more on general usage, see http://whatisthor.com/ and
# https://github.com/erikhuda/thor/wiki.
#
# source://good_job//lib/good_job/cli.rb#15
class GoodJob::CLI < ::Thor
  # The +good_job cleanup_preserved_jobs+ command. Destroys preserved job records.
  #
  # @return [void]
  #
  # source://good_job//lib/good_job/cli.rb#156
  def cleanup_preserved_jobs; end

  # source://good_job//lib/good_job/cli.rb#169
  def set_up_application!; end

  # The +good_job start+ command. Executes queued jobs.
  #
  # @return [void]
  #
  # source://good_job//lib/good_job/cli.rb#105
  def start; end

  class << self
    # @return [Boolean]
    #
    # source://good_job//lib/good_job/cli.rb#38
    def exit_on_failure?; end

    # Whether to log to STDOUT
    #
    # @return [Boolean, nil]
    #
    # source://good_job//lib/good_job/cli.rb#34
    def log_to_stdout; end

    # Whether to log to STDOUT
    #
    # @return [Boolean, nil]
    #
    # source://good_job//lib/good_job/cli.rb#34
    def log_to_stdout=(_arg0); end

    # Whether to log to STDOUT
    #
    # @return [Boolean, nil]
    #
    # source://good_job//lib/good_job/cli.rb#34
    def log_to_stdout?; end

    # Whether the CLI is running from the executable
    #
    # @return [Boolean, nil]
    #
    # source://good_job//lib/good_job/cli.rb#29
    def within_exe; end

    # Whether the CLI is running from the executable
    #
    # @return [Boolean, nil]
    #
    # source://good_job//lib/good_job/cli.rb#29
    def within_exe=(_arg0); end

    # Whether the CLI is running from the executable
    #
    # @return [Boolean, nil]
    #
    # source://good_job//lib/good_job/cli.rb#29
    def within_exe?; end
  end
end

# Path to the local Rails application's environment configuration.
# Requiring this loads the application's configuration and classes.
#
# source://good_job//lib/good_job/cli.rb#18
GoodJob::CLI::RAILS_ENVIRONMENT_RB = T.let(T.unsafe(nil), String)

# Number of seconds between checking shutdown conditions
#
# source://good_job//lib/good_job/cli.rb#21
GoodJob::CLI::SHUTDOWN_EVENT_TIMEOUT = T.let(T.unsafe(nil), Integer)

# Number of seconds between checking shutdown conditions when idle-timeout is enabled
#
# source://good_job//lib/good_job/cli.rb#24
GoodJob::CLI::SHUTDOWN_EVENT_TIMEOUT_FOR_IDLE_TIMEOUT = T.let(T.unsafe(nil), Integer)

# An object that has case-equality to a Proc or Lambda by responding to #call.
# This can be used to duck-type match in a case statement.
#
# source://good_job//lib/good_job/callable.rb#6
module GoodJob::Callable
  class << self
    # Whether the object responds to #call
    #
    # source://good_job//lib/good_job/callable.rb#8
    def ===(other); end
  end
end

# A GoodJob::Capsule contains the resources necessary to execute jobs, including
# a {GoodJob::Scheduler}, {GoodJob::Poller}, {GoodJob::Notifier}, and {GoodJob::CronManager}.
# GoodJob creates a default capsule on initialization.
#
# source://good_job//lib/good_job/capsule.rb#7
class GoodJob::Capsule
  # @param configuration [GoodJob::Configuration] Configuration to use for this capsule.
  # @return [Capsule] a new instance of Capsule
  #
  # source://good_job//lib/good_job/capsule.rb#19
  def initialize(configuration: T.unsafe(nil)); end

  # source://good_job//lib/good_job/capsule.rb#14
  def _tracker_id_for_lock(*_arg0, **_arg1, &_arg2); end

  # source://good_job//lib/good_job/capsule.rb#14
  def _tracker_register(*_arg0, **_arg1, &_arg2); end

  # source://good_job//lib/good_job/capsule.rb#14
  def _tracker_renew(*_arg0, **_arg1, &_arg2); end

  # source://good_job//lib/good_job/capsule.rb#14
  def _tracker_unregister(*_arg0, **_arg1, &_arg2); end

  # Creates an execution thread(s) with the given attributes.
  #
  # @param job_state [Hash, nil] See {GoodJob::Scheduler#create_thread}.
  # @return [Boolean, nil] Whether the thread was created.
  #
  # source://good_job//lib/good_job/capsule.rb#102
  def create_thread(job_state = T.unsafe(nil)); end

  # @param duration [nil, Numeric] Length of idleness to check for (in seconds).
  # @return [Boolean] Whether the capsule is idle
  #
  # source://good_job//lib/good_job/capsule.rb#87
  def idle?(duration = T.unsafe(nil)); end

  # UUID for this capsule; to be used for inspection (not directly for locking jobs).
  #
  # @return [String]
  #
  # source://good_job//lib/good_job/capsule.rb#109
  def process_id; end

  # Shutdown and then start the capsule again.
  #
  # @param timeout [Numeric, NONE] Seconds to wait for active threads.
  # @raise [ArgumentError]
  # @return [void]
  #
  # source://good_job//lib/good_job/capsule.rb#68
  def restart(timeout: T.unsafe(nil)); end

  # @return [Boolean] Whether the capsule is currently running.
  #
  # source://good_job//lib/good_job/capsule.rb#76
  def running?; end

  # Shut down the thread pool executors.
  #
  # @param timeout [nil, Numeric, NONE] Seconds to wait for active threads.
  #   * +-1+ will wait for all active threads to complete.
  #   * +0+ will interrupt active threads.
  #   * +N+ will wait at most N seconds and then interrupt active threads.
  #   * +nil+ will trigger a shutdown but not wait for it to complete.
  # @return [void]
  #
  # source://good_job//lib/good_job/capsule.rb#58
  def shutdown(timeout: T.unsafe(nil)); end

  # @return [Boolean] Whether the capsule has been shutdown.
  #
  # source://good_job//lib/good_job/capsule.rb#81
  def shutdown?; end

  # Start the capsule once. After a shutdown, {#restart} must be used to start again.
  #
  # @return [nil, Boolean] Whether the capsule was started.
  #
  # source://good_job//lib/good_job/capsule.rb#33
  def start(force: T.unsafe(nil)); end

  # Returns the value of attribute tracker.
  #
  # source://good_job//lib/good_job/capsule.rb#16
  def tracker; end

  private

  # source://good_job//lib/good_job/capsule.rb#115
  def configuration; end

  # @return [Boolean]
  #
  # source://good_job//lib/good_job/capsule.rb#119
  def startable?(force: T.unsafe(nil)); end

  class << self
    # List of all instantiated Capsules in the current process.
    #
    # @return [Array<GoodJob::Capsule>, nil]
    #
    # source://good_job//lib/good_job/capsule.rb#12
    def instances; end
  end
end

# CapsuleTracker save a record in the database and periodically refreshes it. The intention is to
# create a heartbeat that can be used to determine whether a capsule/process is still active
# and use that to lock (or unlock) jobs.
#
# source://good_job//lib/good_job/capsule_tracker.rb#7
class GoodJob::CapsuleTracker
  # @param executor [Concurrent::AbstractExecutorService] The executor to use for refreshing the process record.
  # @return [CapsuleTracker] a new instance of CapsuleTracker
  #
  # source://good_job//lib/good_job/capsule_tracker.rb#26
  def initialize(executor: T.unsafe(nil)); end

  # Tests whether an active advisory lock has been taken on the record.
  #
  # @return [Boolean]
  #
  # source://good_job//lib/good_job/capsule_tracker.rb#146
  def advisory_locked?; end

  # Number of tracked job executions with advisory locks.
  #
  # @return [Integer]
  #
  # source://good_job//lib/good_job/capsule_tracker.rb#17
  def advisory_locks; end

  # The UUID to use for locking. May be nil if the process is not registered or is unusable/expired.
  # If UUID has not yet been persisted to the database, this method will make a query to insert or update it.
  #
  # @return [String, nil]
  #
  # source://good_job//lib/good_job/capsule_tracker.rb#43
  def id_for_lock; end

  # Number of tracked job executions.
  #
  # source://good_job//lib/good_job/capsule_tracker.rb#13
  def locks; end

  # The expected UUID of the process for use in inspection.
  # Use {#id_for_lock} if using this as a lock key.
  #
  # @return [String]
  #
  # source://good_job//lib/good_job/capsule_tracker.rb#62
  def process_id; end

  # The database record used for tracking.
  #
  # @return [GoodJob::Process, nil]
  #
  # source://good_job//lib/good_job/capsule_tracker.rb#10
  def record; end

  # Registers the current process around a job execution site.
  # +register+ is expected to be called multiple times in a process, but should be advisory locked only once (in a single thread).
  #
  # @param with_advisory_lock [Boolean] Whether the lock strategy should us an advisory lock; the connection must be retained to support advisory locks.
  # @return [void]
  # @yield [void] If a block is given, the process will be unregistered after the block completes.
  #
  # source://good_job//lib/good_job/capsule_tracker.rb#71
  def register(with_advisory_lock: T.unsafe(nil)); end

  # Refreshes the process record in the database.
  #
  # @param silent [Boolean] Whether to silence logging.
  # @return [void]
  #
  # source://good_job//lib/good_job/capsule_tracker.rb#136
  def renew(silent: T.unsafe(nil)); end

  # source://good_job//lib/good_job/capsule_tracker.rb#151
  def task_observer(_time, _output, thread_error); end

  # Unregisters the current process from the database.
  #
  # @param with_advisory_lock [Boolean] Whether the lock strategy should unlock an advisory lock; the connection must be able to support advisory locks.
  # @return [void]
  #
  # source://good_job//lib/good_job/capsule_tracker.rb#103
  def unregister(with_advisory_lock: T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://good_job//lib/good_job/capsule_tracker.rb#157
  def advisory_locked_connection?; end

  # source://good_job//lib/good_job/capsule_tracker.rb#189
  def cancel_refresh_task; end

  # source://good_job//lib/good_job/capsule_tracker.rb#169
  def create_refresh_task(delay: T.unsafe(nil)); end

  # source://good_job//lib/good_job/capsule_tracker.rb#165
  def jitter; end

  # source://good_job//lib/good_job/capsule_tracker.rb#198
  def ns_reset; end

  # source://good_job//lib/good_job/capsule_tracker.rb#194
  def reset; end

  # Synchronize must always be called from within a Rails Executor; it may deadlock if the order is reversed.
  #
  # source://good_job//lib/good_job/capsule_tracker.rb#204
  def synchronize(&block); end

  # source://good_job//lib/good_job/capsule_tracker.rb#161
  def task_interval; end

  class << self
    # List of all instantiated CapsuleTrackers in the current process.
    #
    # @return [Array<GoodJob::CapsuleTracker>, nil]
    #
    # source://good_job//lib/good_job/capsule_tracker.rb#23
    def instances; end
  end
end

# Tracks thresholds for cleaning up old jobs.
#
# source://good_job//lib/good_job/cleanup_tracker.rb#5
class GoodJob::CleanupTracker
  # @raise [ArgumentError]
  # @return [CleanupTracker] a new instance of CleanupTracker
  #
  # source://good_job//lib/good_job/cleanup_tracker.rb#11
  def initialize(cleanup_interval_seconds: T.unsafe(nil), cleanup_interval_jobs: T.unsafe(nil)); end

  # Whether a cleanup should be run.
  #
  # @return [Boolean]
  #
  # source://good_job//lib/good_job/cleanup_tracker.rb#28
  def cleanup?; end

  # Returns the value of attribute cleanup_interval_jobs.
  #
  # source://good_job//lib/good_job/cleanup_tracker.rb#6
  def cleanup_interval_jobs; end

  # Sets the attribute cleanup_interval_jobs
  #
  # @param value the value to set the attribute cleanup_interval_jobs to.
  #
  # source://good_job//lib/good_job/cleanup_tracker.rb#6
  def cleanup_interval_jobs=(_arg0); end

  # Returns the value of attribute cleanup_interval_seconds.
  #
  # source://good_job//lib/good_job/cleanup_tracker.rb#6
  def cleanup_interval_seconds; end

  # Sets the attribute cleanup_interval_seconds
  #
  # @param value the value to set the attribute cleanup_interval_seconds to.
  #
  # source://good_job//lib/good_job/cleanup_tracker.rb#6
  def cleanup_interval_seconds=(_arg0); end

  # Increments job count.
  #
  # @return [Integer]
  #
  # source://good_job//lib/good_job/cleanup_tracker.rb#22
  def increment; end

  # Returns the value of attribute job_count.
  #
  # source://good_job//lib/good_job/cleanup_tracker.rb#6
  def job_count; end

  # Sets the attribute job_count
  #
  # @param value the value to set the attribute job_count to.
  #
  # source://good_job//lib/good_job/cleanup_tracker.rb#6
  def job_count=(_arg0); end

  # Returns the value of attribute last_at.
  #
  # source://good_job//lib/good_job/cleanup_tracker.rb#6
  def last_at; end

  # Sets the attribute last_at
  #
  # @param value the value to set the attribute last_at to.
  #
  # source://good_job//lib/good_job/cleanup_tracker.rb#6
  def last_at=(_arg0); end

  # Resets the counters.
  #
  # @return [void]
  #
  # source://good_job//lib/good_job/cleanup_tracker.rb#36
  def reset; end
end

# +GoodJob::Configuration+ provides normalized configuration information to
# the rest of GoodJob. It combines environment information with explicitly
# set options to get the final values for each option.
#
# source://good_job//lib/good_job/configuration.rb#9
class GoodJob::Configuration
  # @param options [Hash] Any explicitly specified configuration options to
  #   use. Keys are symbols that match the various methods on this class.
  # @param env [Hash] A +Hash+ from which to read environment variables that
  #   might specify additional configuration values.
  # @return [Configuration] a new instance of Configuration
  #
  # source://good_job//lib/good_job/configuration.rb#83
  def initialize(options, env: T.unsafe(nil)); end

  # Whether to take an advisory lock on the process record in the notifier reactor.
  #
  # @return [Boolean]
  #
  # source://good_job//lib/good_job/configuration.rb#388
  def advisory_lock_heartbeat; end

  # Whether to automatically destroy discarded jobs that have been preserved.
  #
  # @return [Boolean]
  #
  # source://good_job//lib/good_job/configuration.rb#253
  def cleanup_discarded_jobs?; end

  # Number of jobs a {Scheduler} will execute before automatically cleaning up preserved jobs.
  # Positive values will clean up after that many jobs have run, false or 0 will disable, and -1 will clean up after every job.
  #
  # @return [Integer, Boolean, nil]
  #
  # source://good_job//lib/good_job/configuration.rb#274
  def cleanup_interval_jobs; end

  # Number of seconds a {Scheduler} will wait before automatically cleaning up preserved jobs.
  # Positive values will clean up after that many jobs have run, false or 0 will disable, and -1 will clean up after every job.
  #
  # @return [Integer, Boolean, nil]
  #
  # source://good_job//lib/good_job/configuration.rb#293
  def cleanup_interval_seconds; end

  # Number of seconds to preserve jobs before automatic destruction.
  #
  # @return [Integer]
  #
  # source://good_job//lib/good_job/configuration.rb#262
  def cleanup_preserved_jobs_before_seconds_ago; end

  # source://good_job//lib/good_job/configuration.rb#208
  def cron; end

  # source://good_job//lib/good_job/configuration.rb#218
  def cron_entries; end

  # source://good_job//lib/good_job/configuration.rb#222
  def cron_graceful_restart_period; end

  # Tests whether to daemonize the process.
  #
  # @return [Boolean]
  #
  # source://good_job//lib/good_job/configuration.rb#311
  def daemonize?; end

  # source://good_job//lib/good_job/configuration.rb#354
  def dashboard_default_locale; end

  # source://good_job//lib/good_job/configuration.rb#358
  def dashboard_live_poll_enabled; end

  # Whether to run cron
  #
  # @return [Boolean]
  #
  # source://good_job//lib/good_job/configuration.rb#196
  def enable_cron; end

  # Whether to run cron
  #
  # @return [Boolean]
  #
  # source://good_job//lib/good_job/configuration.rb#196
  def enable_cron?; end

  # source://good_job//lib/good_job/configuration.rb#346
  def enable_listen_notify; end

  # Whether the Adapter should have Active Job enqueue jobs after the transaction has committed.
  #
  # @return [Boolean]
  #
  # source://good_job//lib/good_job/configuration.rb#366
  def enqueue_after_transaction_commit; end

  # The environment from which to read GoodJob's environment variables. By
  # default, this is the current process's environment, but it can be set
  # to something else in {#initialize}.
  #
  # @return [Hash]
  #
  # source://good_job//lib/good_job/configuration.rb#52
  def env; end

  # Specifies how and where jobs should be executed. See {Adapter#initialize}
  # for more details on possible values.
  #
  # @return [Symbol]
  #
  # source://good_job//lib/good_job/configuration.rb#97
  def execution_mode; end

  # The number of seconds that a good_job process will idle with out running a job before exiting
  #
  # @return [Integer, nil] Number of seconds or nil means do not idle out.
  #
  # source://good_job//lib/good_job/configuration.rb#243
  def idle_timeout; end

  # Whether running in a web server process.
  #
  # @return [Boolean, nil]
  #
  # source://good_job//lib/good_job/configuration.rb#374
  def in_webserver?; end

  # @return [Boolean]
  #
  # source://good_job//lib/good_job/configuration.rb#165
  def inline_execution_respects_schedule?; end

  # The maximum number of future-scheduled jobs to store in memory.
  # Storing future-scheduled jobs in memory reduces execution latency
  # at the cost of increased memory usage. 10,000 stored jobs = ~20MB.
  #
  # @return [Integer]
  #
  # source://good_job//lib/good_job/configuration.rb#173
  def max_cache; end

  # Indicates the number of threads to use per {Scheduler}. Note that
  # {#queue_string} may provide more specific thread counts to use with
  # individual schedulers.
  #
  # @return [Integer]
  #
  # source://good_job//lib/good_job/configuration.rb#124
  def max_threads; end

  # The options that were explicitly set when initializing +Configuration+.
  # It is safe to modify this hash in place; be sure to symbolize keys.
  #
  # @return [Hash]
  #
  # source://good_job//lib/good_job/configuration.rb#46
  def options; end

  # Path of the pidfile to create when running as a daemon.
  #
  # @return [Pathname, String]
  #
  # source://good_job//lib/good_job/configuration.rb#317
  def pidfile; end

  # The number of seconds between polls for jobs. GoodJob will execute jobs
  # on queues continuously until a queue is empty, at which point it will
  # poll (using this interval) for new queued jobs to execute.
  #
  # @return [Integer]
  #
  # source://good_job//lib/good_job/configuration.rb#150
  def poll_interval; end

  # Rack compliant application to be run on the ProbeServer
  #
  # @return [nil, Class]
  #
  # source://good_job//lib/good_job/configuration.rb#342
  def probe_app; end

  # Probe server handler
  #
  # @return [nil, Symbol]
  #
  # source://good_job//lib/good_job/configuration.rb#333
  def probe_handler; end

  # Port of the probe server
  #
  # @return [nil, Integer]
  #
  # source://good_job//lib/good_job/configuration.rb#325
  def probe_port; end

  # The number of queued jobs to select when polling for a job to run.
  # This limit is intended to avoid locking a large number of rows when selecting eligible jobs
  # from the queue. This value should be higher than the total number of threads across all good_job
  # processes to ensure a thread can retrieve an eligible and unlocked job.
  #
  # @return [Integer, nil]
  #
  # source://good_job//lib/good_job/configuration.rb#233
  def queue_select_limit; end

  # Describes which queues to execute jobs from and how those queues should
  # be grouped into {Scheduler} instances. See
  # {file:README.md#optimize-queues-threads-and-processes} for more details
  # on the format of this string.
  #
  # @return [String]
  #
  # source://good_job//lib/good_job/configuration.rb#139
  def queue_string; end

  # The number of seconds to wait for jobs to finish when shutting down
  # before stopping the thread. +-1+ is forever.
  #
  # @return [Float]
  #
  # source://good_job//lib/good_job/configuration.rb#185
  def shutdown_timeout; end

  # source://good_job//lib/good_job/configuration.rb#90
  def validate!; end

  private

  # source://good_job//lib/good_job/configuration.rb#398
  def rails_config; end

  class << self
    # Returns the maximum number of threads GoodJob might consume
    #
    # @param warn [Boolean] whether to print a warning when over the limit
    # @return [Integer]
    #
    # source://good_job//lib/good_job/configuration.rb#57
    def total_estimated_threads(warn: T.unsafe(nil)); end

    # @raise [ArgumentError]
    #
    # source://good_job//lib/good_job/configuration.rb#39
    def validate_execution_mode(execution_mode); end
  end
end

# Default number of jobs to execute between preserved job cleanup runs
#
# source://good_job//lib/good_job/configuration.rb#23
GoodJob::Configuration::DEFAULT_CLEANUP_INTERVAL_JOBS = T.let(T.unsafe(nil), Integer)

# Default number of seconds to wait between preserved job cleanup runs
#
# source://good_job//lib/good_job/configuration.rb#25
GoodJob::Configuration::DEFAULT_CLEANUP_INTERVAL_SECONDS = T.let(T.unsafe(nil), Integer)

# Default number of seconds to preserve jobs for {CLI#cleanup_preserved_jobs} and {GoodJob.cleanup_preserved_jobs}
#
# source://good_job//lib/good_job/configuration.rb#21
GoodJob::Configuration::DEFAULT_CLEANUP_PRESERVED_JOBS_BEFORE_SECONDS_AGO = T.let(T.unsafe(nil), Integer)

# Default Dashboard I18n locale
#
# source://good_job//lib/good_job/configuration.rb#33
GoodJob::Configuration::DEFAULT_DASHBOARD_DEFAULT_LOCALE = T.let(T.unsafe(nil), Symbol)

# Default Dashboard Live Poll button enabled
#
# source://good_job//lib/good_job/configuration.rb#35
GoodJob::Configuration::DEFAULT_DASHBOARD_LIVE_POLL_ENABLED = T.let(T.unsafe(nil), TrueClass)

# Default poll interval for async in development environment
#
# source://good_job//lib/good_job/configuration.rb#17
GoodJob::Configuration::DEFAULT_DEVELOPMENT_ASYNC_POLL_INTERVAL = T.let(T.unsafe(nil), Integer)

# Default to not running cron
#
# source://good_job//lib/good_job/configuration.rb#29
GoodJob::Configuration::DEFAULT_ENABLE_CRON = T.let(T.unsafe(nil), FalseClass)

# Default to enabling LISTEN/NOTIFY
#
# source://good_job//lib/good_job/configuration.rb#31
GoodJob::Configuration::DEFAULT_ENABLE_LISTEN_NOTIFY = T.let(T.unsafe(nil), TrueClass)

# Default enqueue_after_transaction_commit
#
# source://good_job//lib/good_job/configuration.rb#37
GoodJob::Configuration::DEFAULT_ENQUEUE_AFTER_TRANSACTION_COMMIT = T.let(T.unsafe(nil), FalseClass)

# Default number of threads to use per {Scheduler}
#
# source://good_job//lib/good_job/configuration.rb#19
GoodJob::Configuration::DEFAULT_MAX_CACHE = T.let(T.unsafe(nil), Integer)

# Default number of threads to use per {Scheduler}
#
# source://good_job//lib/good_job/configuration.rb#13
GoodJob::Configuration::DEFAULT_MAX_THREADS = T.let(T.unsafe(nil), Integer)

# Default number of seconds between polls for jobs
#
# source://good_job//lib/good_job/configuration.rb#15
GoodJob::Configuration::DEFAULT_POLL_INTERVAL = T.let(T.unsafe(nil), Integer)

# Default to always wait for jobs to finish for {Adapter#shutdown}
#
# source://good_job//lib/good_job/configuration.rb#27
GoodJob::Configuration::DEFAULT_SHUTDOWN_TIMEOUT = T.let(T.unsafe(nil), Integer)

# Valid execution modes.
#
# source://good_job//lib/good_job/configuration.rb#11
GoodJob::Configuration::EXECUTION_MODES = T.let(T.unsafe(nil), Array)

class GoodJob::CronEntriesController < ::GoodJob::ApplicationController
  def disable; end
  def enable; end
  def enqueue; end
  def index; end
  def show; end

  private

  # source://actionview/7.2.1.1/lib/action_view/layouts.rb#328
  def _layout(lookup_context, formats); end

  class << self
    # source://actionpack/7.2.1.1/lib/action_controller/metal.rb#288
    def middleware_stack; end
  end
end

class GoodJob::CronEntry
  include ::ActiveModel::Validations
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveModel::Conversion
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::API
  include ::ActiveModel::Access
  include ::ActiveModel::Model
  extend ::ActiveModel::Validations::ClassMethods
  extend ::ActiveModel::Naming
  extend ::Ahoy::Model
  extend ::ActiveModel::Callbacks
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveModel::Translation
  extend ::ActiveModel::Validations::HelperMethods
  extend ::ActiveModel::Conversion::ClassMethods

  def initialize(params = T.unsafe(nil)); end

  # source://activesupport/7.2.1.1/lib/active_support/callbacks.rb#70
  def __callbacks; end

  # source://activesupport/7.2.1.1/lib/active_support/callbacks.rb#70
  def __callbacks?; end

  # source://activesupport/7.2.1.1/lib/active_support/callbacks.rb#912
  def _run_validate_callbacks(&block); end

  # source://activesupport/7.2.1.1/lib/active_support/callbacks.rb#924
  def _validate_callbacks; end

  # source://activemodel/7.2.1.1/lib/active_model/validations.rb#71
  def _validators; end

  # source://activemodel/7.2.1.1/lib/active_model/validations.rb#71
  def _validators?; end

  def args; end
  def description; end
  def disable; end
  def display_properties; end
  def display_schedule; end
  def enable; end
  def enabled?; end
  def enqueue(cron_at = T.unsafe(nil)); end
  def id; end
  def job_class; end
  def jobs; end
  def key; end
  def kwargs; end
  def last_job; end
  def last_job_at; end

  # source://activemodel/7.2.1.1/lib/active_model/naming.rb#255
  def model_name(&_arg0); end

  def next_at(previously_at: T.unsafe(nil)); end

  # source://activemodel/7.2.1.1/lib/active_model/conversion.rb#32
  def param_delimiter=(_arg0); end

  def params; end
  def set; end
  def to_param; end

  # source://activemodel/7.2.1.1/lib/active_model/validations.rb#67
  def validation_context; end

  def within(period, previously_at: T.unsafe(nil)); end

  private

  def args_value; end
  def cron; end
  def cron_proc?; end
  def display_property(value); end
  def enabled_by_default?; end
  def fugit; end
  def kwargs_value; end
  def set_value; end

  # source://activemodel/7.2.1.1/lib/active_model/validations.rb#67
  def validation_context=(_arg0); end

  class << self
    # source://activesupport/7.2.1.1/lib/active_support/callbacks.rb#70
    def __callbacks; end

    # source://activesupport/7.2.1.1/lib/active_support/callbacks.rb#70
    def __callbacks=(value); end

    # source://activesupport/7.2.1.1/lib/active_support/callbacks.rb#70
    def __callbacks?; end

    # source://activesupport/7.2.1.1/lib/active_support/callbacks.rb#916
    def _validate_callbacks; end

    # source://activesupport/7.2.1.1/lib/active_support/callbacks.rb#920
    def _validate_callbacks=(value); end

    # source://activemodel/7.2.1.1/lib/active_model/validations.rb#71
    def _validators; end

    # source://activemodel/7.2.1.1/lib/active_model/validations.rb#71
    def _validators=(value); end

    # source://activemodel/7.2.1.1/lib/active_model/validations.rb#71
    def _validators?; end

    def all(configuration: T.unsafe(nil)); end
    def find(key, configuration: T.unsafe(nil)); end

    # source://activemodel/7.2.1.1/lib/active_model/conversion.rb#32
    def param_delimiter; end

    # source://activemodel/7.2.1.1/lib/active_model/conversion.rb#32
    def param_delimiter=(value); end

    # source://activemodel/7.2.1.1/lib/active_model/conversion.rb#32
    def param_delimiter?; end
  end
end

# CronManagers enqueue jobs on a repeating schedule.
#
# source://good_job//lib/good_job/cron_manager.rb#11
class GoodJob::CronManager
  # @param cron_entries [Array<CronEntry>]
  # @param start_on_initialize [Boolean]
  # @return [CronManager] a new instance of CronManager
  #
  # source://good_job//lib/good_job/cron_manager.rb#34
  def initialize(cron_entries = T.unsafe(nil), start_on_initialize: T.unsafe(nil), graceful_restart_period: T.unsafe(nil), executor: T.unsafe(nil)); end

  # Uses the graceful restart period to re-enqueue jobs that were scheduled to run during the period.
  # The existing uniqueness logic should ensure this does not create duplicate jobs.
  #
  # @param cron_entry [CronEntry] the CronEntry object to schedule
  #
  # source://good_job//lib/good_job/cron_manager.rb#106
  def create_graceful_tasks(cron_entry); end

  # Enqueues a scheduled task
  #
  # @param cron_entry [CronEntry] the CronEntry object to schedule
  # @param previously_at [Date, Time, ActiveSupport::TimeWithZone, nil] the last, +in-memory+, scheduled time the cron task was intended to run
  #
  # source://good_job//lib/good_job/cron_manager.rb#86
  def create_task(cron_entry, previously_at: T.unsafe(nil)); end

  # Execution configuration to be scheduled
  #
  # @return [Hash]
  #
  # source://good_job//lib/good_job/cron_manager.rb#30
  def cron_entries; end

  # Stop and restart
  #
  # @param timeout [Numeric, nil] Unused but retained for compatibility
  #
  # source://good_job//lib/good_job/cron_manager.rb#66
  def restart(timeout: T.unsafe(nil)); end

  # Tests whether the manager is running.
  #
  # @return [Boolean, nil]
  #
  # source://good_job//lib/good_job/cron_manager.rb#73
  def running?; end

  # Stop/cancel any scheduled tasks
  #
  # @param timeout [Numeric, nil] Unused but retained for compatibility
  #
  # source://good_job//lib/good_job/cron_manager.rb#58
  def shutdown(timeout: T.unsafe(nil)); end

  # Tests whether the manager is shutdown.
  #
  # @return [Boolean, nil]
  #
  # source://good_job//lib/good_job/cron_manager.rb#79
  def shutdown?; end

  # Schedule tasks that will enqueue jobs based on their schedule
  #
  # source://good_job//lib/good_job/cron_manager.rb#46
  def start; end

  class << self
    # List of all instantiated CronManagers in the current process.
    #
    # @return [Array<GoodJob::CronManager>, nil]
    #
    # source://good_job//lib/good_job/cron_manager.rb#16
    def instances; end

    # Task observer for cron task
    #
    # @param time [Time]
    # @param output [Object]
    # @param thread_error [Exception]
    #
    # source://good_job//lib/good_job/cron_manager.rb#22
    def task_observer(time, output, thread_error); end
  end
end

# Thread-local attributes for passing values from Instrumentation.
# (Cannot use ActiveSupport::CurrentAttributes because ActiveJob resets it)
#
# source://good_job//lib/good_job/current_thread.rb#8
module GoodJob::CurrentThread
  # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#74
  def cron_at; end

  # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#116
  def cron_at=(obj); end

  # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#74
  def cron_key; end

  # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#116
  def cron_key=(obj); end

  # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#74
  def error_on_discard; end

  # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#116
  def error_on_discard=(obj); end

  # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#74
  def error_on_retry; end

  # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#116
  def error_on_retry=(obj); end

  # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#74
  def error_on_retry_stopped; end

  # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#116
  def error_on_retry_stopped=(obj); end

  # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#74
  def execution_interrupted; end

  # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#116
  def execution_interrupted=(obj); end

  # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#74
  def job; end

  # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#116
  def job=(obj); end

  # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#74
  def retried_job; end

  # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#116
  def retried_job=(obj); end

  # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#74
  def retry_now; end

  # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#116
  def retry_now=(obj); end

  class << self
    # @return [String] UUID of the currently executing GoodJob::Job
    #
    # source://good_job//lib/good_job/current_thread.rb#94
    def active_job_id; end

    # Cron At
    #
    # @return [DateTime, nil]
    #
    # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#49
    def cron_at; end

    # Cron At
    #
    # @return [DateTime, nil]
    #
    # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#108
    def cron_at=(obj); end

    # Cron Key
    #
    # @return [String, nil]
    #
    # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#49
    def cron_key; end

    # Cron Key
    #
    # @return [String, nil]
    #
    # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#108
    def cron_key=(obj); end

    # Error captured by discard_on
    #
    # @return [Exception, nil]
    #
    # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#49
    def error_on_discard; end

    # Error captured by discard_on
    #
    # @return [Exception, nil]
    #
    # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#108
    def error_on_discard=(obj); end

    # Error captured by retry_on
    #
    # @return [Exception, nil]
    #
    # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#49
    def error_on_retry; end

    # Error captured by retry_on
    #
    # @return [Exception, nil]
    #
    # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#108
    def error_on_retry=(obj); end

    # Error captured by retry_stopped
    #
    # @return [Exception, nil]
    #
    # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#49
    def error_on_retry_stopped; end

    # Error captured by retry_stopped
    #
    # @return [Exception, nil]
    #
    # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#108
    def error_on_retry_stopped=(obj); end

    # Execution Interrupted
    #
    # @return [Boolean, nil]
    #
    # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#49
    def execution_interrupted; end

    # Execution Interrupted
    #
    # @return [Boolean, nil]
    #
    # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#108
    def execution_interrupted=(obj); end

    # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#49
    def job; end

    # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#108
    def job=(obj); end

    # @return [Integer] Current process ID
    #
    # source://good_job//lib/good_job/current_thread.rb#99
    def process_id; end

    # Resets attributes
    #
    # @param values [Hash] to assign
    # @return [void]
    #
    # source://good_job//lib/good_job/current_thread.rb#79
    def reset(values = T.unsafe(nil)); end

    # Execution Retried
    #
    # @return [GoodJob::Job, nil]
    #
    # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#49
    def retried_job; end

    # Execution Retried
    #
    # @return [GoodJob::Job, nil]
    #
    # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#108
    def retried_job=(obj); end

    # Execution Retried
    #
    # @return [Boolean, nil]
    #
    # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#49
    def retry_now; end

    # Execution Retried
    #
    # @return [Boolean, nil]
    #
    # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#108
    def retry_now=(obj); end

    # @return [String] Current thread name
    #
    # source://good_job//lib/good_job/current_thread.rb#104
    def thread_name; end

    # Exports values to hash
    #
    # @return [Hash]
    #
    # source://good_job//lib/good_job/current_thread.rb#87
    def to_h; end

    # Wrap the yielded block with CurrentThread values and reset after the block
    #
    # @return [void]
    # @yield [self]
    #
    # source://good_job//lib/good_job/current_thread.rb#111
    def within; end
  end
end

# Resettable accessors for thread-local values.
#
# source://good_job//lib/good_job/current_thread.rb#10
GoodJob::CurrentThread::ACCESSORS = T.let(T.unsafe(nil), Array)

# Default logger for GoodJob; overridden by Rails.logger in Railtie.
#
# source://good_job//lib/good_job.rb#58
GoodJob::DEFAULT_LOGGER = T.let(T.unsafe(nil), ActiveSupport::Logger)

# Manages daemonization of the current process.
#
# source://good_job//lib/good_job/daemon.rb#7
class GoodJob::Daemon
  # @param pidfile [Pathname, String] Pidfile path
  # @return [Daemon] a new instance of Daemon
  #
  # source://good_job//lib/good_job/daemon.rb#13
  def initialize(pidfile:); end

  # Daemonizes the current process and writes out a pidfile.
  #
  # @return [void]
  #
  # source://good_job//lib/good_job/daemon.rb#19
  def daemonize; end

  # The path of the generated pidfile.
  #
  # @return [Pathname, String]
  #
  # source://good_job//lib/good_job/daemon.rb#10
  def pidfile; end

  private

  # @return [void]
  #
  # source://good_job//lib/good_job/daemon.rb#51
  def check_pid; end

  # @return [void]
  #
  # source://good_job//lib/good_job/daemon.rb#43
  def check_pid_dir; end

  # @return [void]
  #
  # source://good_job//lib/good_job/daemon.rb#38
  def delete_pid; end

  # @param pidfile [Pathname, String]
  # @return [Symbol]
  #
  # source://good_job//lib/good_job/daemon.rb#62
  def pid_status(pidfile); end

  # @return [void]
  #
  # source://good_job//lib/good_job/daemon.rb#29
  def write_pid; end
end

# Extends GoodJob module to track Rails boot dependencies.
#
# source://good_job//lib/good_job/dependencies.rb#5
module GoodJob::Dependencies
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::GoodJob::Dependencies::ClassMethods
end

# source://good_job//lib/good_job/dependencies.rb#0
module GoodJob::Dependencies::ClassMethods
  # source://good_job//lib/good_job/dependencies.rb#18
  def _start_async_adapters; end

  # source://good_job//lib/good_job/dependencies.rb#14
  def async_ready?; end
end

# Ruby on Rails integration.
#
# source://good_job//lib/good_job/engine.rb#5
class GoodJob::Engine < ::Rails::Engine
  class << self
    # source://activesupport/7.2.1.1/lib/active_support/callbacks.rb#70
    def __callbacks; end
  end
end

module GoodJob::ErrorEvents
  extend ::ActiveSupport::Concern
end

class GoodJob::ExecutionResult
  def initialize(value:, handled_error: T.unsafe(nil), unhandled_error: T.unsafe(nil), error_event: T.unsafe(nil), unexecutable: T.unsafe(nil), retried_job: T.unsafe(nil)); end

  def error_event; end
  def handled_error; end
  def retried?; end
  def retried_job; end
  def succeeded?; end
  def unexecutable; end
  def unhandled_error; end
  def value; end
end

module GoodJob::Filterable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::GoodJob::Filterable::ClassMethods
end

module GoodJob::Filterable::ClassMethods
  def database_supports_websearch_to_tsquery?; end
end

class GoodJob::FrontendsController < ::ActionController::Base
  def module; end
  def static; end

  private

  # source://actionview/7.2.1.1/lib/action_view/layouts.rb#328
  def _layout(lookup_context, formats); end

  class << self
    # source://activesupport/7.2.1.1/lib/active_support/callbacks.rb#70
    def __callbacks; end

    def js_modules; end

    # source://actionpack/7.2.1.1/lib/action_controller/metal.rb#288
    def middleware_stack; end
  end
end

GoodJob::FrontendsController::MODULE_OVERRIDES = T.let(T.unsafe(nil), Hash)
GoodJob::FrontendsController::STATIC_ASSETS = T.let(T.unsafe(nil), Hash)

# GoodJob version as Gem::Version object
#
# source://good_job//lib/good_job/version.rb#8
GoodJob::GEM_VERSION = T.let(T.unsafe(nil), Gem::Version)

class GoodJob::I18nConfig < ::I18n::Config
  def available_locales; end
  def available_locales_set; end
  def backend; end
  def default_locale; end
end

GoodJob::I18nConfig::AVAILABLE_LOCALES = T.let(T.unsafe(nil), Array)
GoodJob::I18nConfig::AVAILABLE_LOCALES_SET = T.let(T.unsafe(nil), Set)
GoodJob::I18nConfig::BACKEND = T.let(T.unsafe(nil), I18n::Backend::Simple)

module GoodJob::IconsHelper
  def icons_path; end
  def render_icon(name, class: T.unsafe(nil), **options); end
  def status_badge(status); end
  def status_icon(status, **options); end
end

GoodJob::IconsHelper::STATUS_COLOR = T.let(T.unsafe(nil), Hash)
GoodJob::IconsHelper::STATUS_ICONS = T.let(T.unsafe(nil), Hash)

# Exception raised when a job is interrupted by a SIGKILL or power failure.
#
# source://good_job//lib/good_job/interrupt_error.rb#5
class GoodJob::InterruptError < ::StandardError; end

# JobPerformer queries the database for jobs and performs them on behalf of a
# {Scheduler}. It mainly functions as glue between a {Scheduler} and the jobs
# it should be executing.
#
# The JobPerformer must be safe to execute across multiple threads.
#
# source://good_job//lib/good_job/job_performer.rb#13
class GoodJob::JobPerformer
  # @param queue_string [String] Queues to execute jobs from
  # @return [JobPerformer] a new instance of JobPerformer
  #
  # source://good_job//lib/good_job/job_performer.rb#17
  def initialize(queue_string, capsule: T.unsafe(nil)); end

  # Destroy expired preserved jobs
  #
  # @return [void]
  #
  # source://good_job//lib/good_job/job_performer.rb#88
  def cleanup; end

  # A meaningful name to identify the performer in logs and for debugging.
  #
  # @return [String] The queues from which Jobs are worked
  #
  # source://good_job//lib/good_job/job_performer.rb#25
  def name; end

  # Perform the next eligible job
  #
  # @return [Object, nil] Returns job result or +nil+ if no job was found
  # @yield [Execution] Yields the execution, if one is dequeued
  #
  # source://good_job//lib/good_job/job_performer.rb#32
  def next; end

  # Tests whether this performer should be used in GoodJob's current state.
  #
  # For example, state will be a LISTEN/NOTIFY message that is passed down
  # from the Notifier to the Scheduler. The Scheduler is able to ask
  # its performer "does this message relate to you?", and if not, ignore it
  # to minimize thread wake-ups, database queries, and thundering herds.
  #
  # @return [Boolean] whether the performer's {#next} method should be
  #   called in the current state.
  #
  # source://good_job//lib/good_job/job_performer.rb#65
  def next?(state = T.unsafe(nil)); end

  # The Returns timestamps of when next tasks may be available.
  #
  # @param after [DateTime, Time, nil] future jobs scheduled after this time
  # @param limit [Integer] number of future timestamps to return
  # @param now_limit [Integer] number of past timestamps to return
  # @return [Array<DateTime, Time>, nil]
  #
  # source://good_job//lib/good_job/job_performer.rb#82
  def next_at(after: T.unsafe(nil), limit: T.unsafe(nil), now_limit: T.unsafe(nil)); end

  # source://good_job//lib/good_job/job_performer.rb#14
  def performing_active_job_ids; end

  # source://good_job//lib/good_job/job_performer.rb#14
  def performing_active_job_ids=(val); end

  # Reset metrics about this performer
  #
  # @return [void]
  #
  # source://good_job//lib/good_job/job_performer.rb#102
  def reset_stats; end

  # Metrics about this performer
  #
  # @return [Hash]
  #
  # source://good_job//lib/good_job/job_performer.rb#94
  def stats; end

  private

  # source://good_job//lib/good_job/job_performer.rb#110
  def job_query; end

  # source://good_job//lib/good_job/job_performer.rb#114
  def parsed_queues; end

  # Returns the value of attribute queue_string.
  #
  # source://good_job//lib/good_job/job_performer.rb#108
  def queue_string; end

  class << self
    # source://good_job//lib/good_job/job_performer.rb#14
    def performing_active_job_ids; end

    # source://good_job//lib/good_job/job_performer.rb#14
    def performing_active_job_ids=(val); end
  end
end

# Metrics for the scheduler.
#
# source://good_job//lib/good_job/job_performer/metrics.rb#8
class GoodJob::JobPerformer::Metrics
  # @return [Metrics] a new instance of Metrics
  #
  # source://good_job//lib/good_job/job_performer/metrics.rb#9
  def initialize; end

  # Increments number of dequeue attempts with no executions.
  #
  # @return [Integer]
  #
  # source://good_job//lib/good_job/job_performer/metrics.rb#34
  def increment_empty_executions; end

  # Increments number of failed executions.
  #
  # @return [Integer]
  #
  # source://good_job//lib/good_job/job_performer/metrics.rb#20
  def increment_errored_executions; end

  # Increments number of succeeded executions.
  #
  # @return [Integer]
  #
  # source://good_job//lib/good_job/job_performer/metrics.rb#27
  def increment_succeeded_executions; end

  # Reset counters.
  #
  # @return [void]
  #
  # source://good_job//lib/good_job/job_performer/metrics.rb#66
  def reset; end

  # All metrics in a Hash.
  #
  # @return [Hash]
  #
  # source://good_job//lib/good_job/job_performer/metrics.rb#52
  def to_h; end

  # Last time the queue was checked for jobs.
  #
  # @return [Time, nil]
  #
  # source://good_job//lib/good_job/job_performer/metrics.rb#46
  def touch_check_queue_at; end

  # Last time a job was executed (started or finished).
  #
  # @return [Time, nil]
  #
  # source://good_job//lib/good_job/job_performer/metrics.rb#40
  def touch_execution_at; end
end

class GoodJob::JobsFilter < ::GoodJob::BaseFilter
  def filtered_count; end
  def filtered_query(filter_params = T.unsafe(nil)); end
  def state_names; end
  def states; end

  private

  def default_base_query; end
  def query_for_records; end
end

# Listens to GoodJob notifications and logs them.
#
# Each method corresponds to the name of a notification. For example, when
# the {Scheduler} shuts down, it sends a notification named
# +"scheduler_shutdown.good_job"+ and the {#scheduler_shutdown} method will
# be called here. See the
# {https://api.rubyonrails.org/classes/ActiveSupport/LogSubscriber.html ActiveSupport::LogSubscriber}
# documentation for more.
#
# source://good_job//lib/good_job/log_subscriber.rb#14
class GoodJob::LogSubscriber < ::ActiveSupport::LogSubscriber
  # Responds to the +cleanup_preserved_jobs.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  #
  # source://good_job//lib/good_job/log_subscriber.rb#147
  def cleanup_preserved_jobs(event); end

  # Responds to the +cron_manager_start.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  #
  # source://good_job//lib/good_job/log_subscriber.rb#54
  def cron_manager_start(event); end

  # source://good_job//lib/good_job/log_subscriber.rb#259
  def debug(progname = T.unsafe(nil), tags: T.unsafe(nil), &block); end

  # source://good_job//lib/good_job/log_subscriber.rb#259
  def error(progname = T.unsafe(nil), tags: T.unsafe(nil), &block); end

  # source://good_job//lib/good_job/log_subscriber.rb#259
  def fatal(progname = T.unsafe(nil), tags: T.unsafe(nil), &block); end

  # Responds to the +finished_job_task.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  #
  # source://good_job//lib/good_job/log_subscriber.rb#33
  def finished_job_task(event); end

  # Responds to the +finished_timer_task.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  #
  # source://good_job//lib/good_job/log_subscriber.rb#23
  def finished_timer_task(event); end

  # source://good_job//lib/good_job/log_subscriber.rb#259
  def info(progname = T.unsafe(nil), tags: T.unsafe(nil), &block); end

  # Get the logger associated with this {LogSubscriber} instance.
  #
  # @return [Logger]
  #
  # source://good_job//lib/good_job/log_subscriber.rb#178
  def logger; end

  # Responds to the +notifier_listen.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  #
  # source://good_job//lib/good_job/log_subscriber.rb#115
  def notifier_listen(event); end

  # Responds to the +notifier_notified.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  #
  # source://good_job//lib/good_job/log_subscriber.rb#122
  def notifier_notified(event); end

  # Responds to the +notifier_notify_error.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  #
  # source://good_job//lib/good_job/log_subscriber.rb#131
  def notifier_notify_error(event); end

  # Responds to the +notifier_unlisten.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  #
  # source://good_job//lib/good_job/log_subscriber.rb#140
  def notifier_unlisten(event); end

  # Responds to the +perform_job.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  #
  # source://good_job//lib/good_job/log_subscriber.rb#104
  def perform_job(event); end

  # Responds to the +scheduler_create_pool.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  #
  # source://good_job//lib/good_job/log_subscriber.rb#43
  def scheduler_create_pool(event); end

  # Responds to the +scheduler_restart_pools.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  #
  # source://good_job//lib/good_job/log_subscriber.rb#95
  def scheduler_restart_pools(event); end

  # Responds to the +scheduler_shutdown.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  #
  # source://good_job//lib/good_job/log_subscriber.rb#73
  def scheduler_shutdown(event); end

  # source://good_job//lib/good_job/log_subscriber.rb#81
  def scheduler_shutdown_kill(event); end

  # Responds to the +scheduler_shutdown_start.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  #
  # source://good_job//lib/good_job/log_subscriber.rb#64
  def scheduler_shutdown_start(event); end

  # Responds to the +systemd_watchdog_error.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  #
  # source://good_job//lib/good_job/log_subscriber.rb#166
  def systemd_watchdog_error(event); end

  # Responds to the +systemd_watchdog_start.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  #
  # source://good_job//lib/good_job/log_subscriber.rb#157
  def systemd_watchdog_start(event); end

  # source://good_job//lib/good_job/log_subscriber.rb#259
  def unknown(progname = T.unsafe(nil), tags: T.unsafe(nil), &block); end

  # source://good_job//lib/good_job/log_subscriber.rb#259
  def warn(progname = T.unsafe(nil), tags: T.unsafe(nil), &block); end

  private

  # Add "GoodJob" plus any specified tags to every
  # {ActiveSupport::TaggedLogging} logger in {LogSubscriber.loggers}. Tags
  # are only applicable inside the block passed to this method.
  #
  # @return [void]
  # @yield [void]
  #
  # source://good_job//lib/good_job/log_subscriber.rb#230
  def tag_logger(*tags, &block); end

  class << self
    # Represents all the loggers attached to {LogSubscriber} with a single
    # logging interface. Writing to this logger is a shortcut for writing to
    # each of the loggers in {LogSubscriber.loggers}.
    #
    # @return [Logger]
    #
    # source://good_job//lib/good_job/log_subscriber.rb#202
    def logger; end

    # Tracks all loggers that {LogSubscriber} is writing to. You can write to
    # multiple logs by appending to this array. After updating it, you should
    # usually call {LogSubscriber.reset_logger} to make sure they are all
    # written to.
    #
    # Defaults to {GoodJob.logger}.
    #
    # @example Write to STDOUT and to a file:
    #   GoodJob::LogSubscriber.loggers << ActiveSupport::TaggedLogging.new(ActiveSupport::Logger.new(STDOUT))
    #   GoodJob::LogSubscriber.loggers << ActiveSupport::TaggedLogging.new(ActiveSupport::Logger.new("log/my_logs.log"))
    #   GoodJob::LogSubscriber.reset_logger
    # @return [Array<Logger>]
    #
    # source://good_job//lib/good_job/log_subscriber.rb#194
    def loggers; end

    # Reset {LogSubscriber.logger} and force it to rebuild a new shortcut to
    # all the loggers in {LogSubscriber.loggers}. You should usually call
    # this after modifying the {LogSubscriber.loggers} array.
    #
    # @return [void]
    #
    # source://good_job//lib/good_job/log_subscriber.rb#218
    def reset_logger; end
  end
end

class GoodJob::MetricsController < ::GoodJob::ApplicationController
  def job_status; end
  def primary_nav; end

  private

  # source://actionview/7.2.1.1/lib/action_view/layouts.rb#328
  def _layout(lookup_context, formats); end

  class << self
    # source://actionpack/7.2.1.1/lib/action_controller/metal.rb#288
    def middleware_stack; end
  end
end

# Delegates the interface of a single {Scheduler} to multiple Schedulers.
#
# source://good_job//lib/good_job/multi_scheduler.rb#5
class GoodJob::MultiScheduler
  # @param schedulers [Array<Scheduler>]
  # @return [MultiScheduler] a new instance of MultiScheduler
  #
  # source://good_job//lib/good_job/multi_scheduler.rb#33
  def initialize(schedulers); end

  # Delegates to {Scheduler#create_thread}.
  #
  # @param state [Hash]
  # @return [Boolean, nil]
  #
  # source://good_job//lib/good_job/multi_scheduler.rb#66
  def create_thread(state = T.unsafe(nil)); end

  # Delegates to {Scheduler#restart}.
  #
  # @param timeout [Numeric, nil]
  # @return [void]
  #
  # source://good_job//lib/good_job/multi_scheduler.rb#59
  def restart(timeout: T.unsafe(nil)); end

  # Delegates to {Scheduler#running?}.
  #
  # @return [Boolean, nil]
  #
  # source://good_job//lib/good_job/multi_scheduler.rb#39
  def running?; end

  # @return [Array<Scheduler>] List of the scheduler delegates
  #
  # source://good_job//lib/good_job/multi_scheduler.rb#30
  def schedulers; end

  # Delegates to {Scheduler#shutdown}.
  #
  # @param timeout [Numeric, nil]
  # @return [void]
  #
  # source://good_job//lib/good_job/multi_scheduler.rb#52
  def shutdown(timeout: T.unsafe(nil)); end

  # Delegates to {Scheduler#shutdown?}.
  #
  # @return [Boolean, nil]
  #
  # source://good_job//lib/good_job/multi_scheduler.rb#45
  def shutdown?; end

  # source://good_job//lib/good_job/multi_scheduler.rb#88
  def stats; end

  class << self
    # Creates MultiScheduler from a GoodJob::Configuration instance.
    #
    # @param configuration [GoodJob::Configuration]
    # @param warm_cache_on_initialize [Boolean]
    # @return [GoodJob::MultiScheduler]
    #
    # source://good_job//lib/good_job/multi_scheduler.rb#10
    def from_configuration(configuration, capsule: T.unsafe(nil), warm_cache_on_initialize: T.unsafe(nil)); end
  end
end

# Default, null, blank value placeholder.
#
# source://good_job//lib/good_job.rb#55
module GoodJob::NONE; end

# Notifiers hook into Postgres LISTEN/NOTIFY functionality to emit and listen for notifications across processes.
#
# Notifiers can emit NOTIFY messages through Postgres.
# A notifier will LISTEN for messages by creating a background thread that runs in an instance of +Concurrent::ThreadPoolExecutor+.
# When a message is received, the notifier passes the message to each of its recipients.
#
# source://good_job//lib/good_job/notifier/process_heartbeat.rb#4
class GoodJob::Notifier
  include ::ActiveSupport::Callbacks
  include ::GoodJob::Notifier::ProcessHeartbeat
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker

  # @param recipients [Array<#call, Array(Object, Symbol)>]
  # @param enable_listening [true, false]
  # @return [Notifier] a new instance of Notifier
  #
  # source://good_job//lib/good_job/notifier.rb#68
  def initialize(*recipients, enable_listening: T.unsafe(nil), capsule: T.unsafe(nil), executor: T.unsafe(nil)); end

  # source://activesupport/7.2.1.1/lib/active_support/callbacks.rb#70
  def __callbacks; end

  # source://activesupport/7.2.1.1/lib/active_support/callbacks.rb#70
  def __callbacks?; end

  # source://activesupport/7.2.1.1/lib/active_support/callbacks.rb#924
  def _listen_callbacks; end

  # source://activesupport/7.2.1.1/lib/active_support/callbacks.rb#912
  def _run_listen_callbacks(&block); end

  # source://activesupport/7.2.1.1/lib/active_support/callbacks.rb#912
  def _run_tick_callbacks(&block); end

  # source://activesupport/7.2.1.1/lib/active_support/callbacks.rb#912
  def _run_unlisten_callbacks(&block); end

  # source://activesupport/7.2.1.1/lib/active_support/callbacks.rb#924
  def _tick_callbacks; end

  # source://activesupport/7.2.1.1/lib/active_support/callbacks.rb#924
  def _unlisten_callbacks; end

  # Tests whether the notifier is active and has acquired a dedicated database connection.
  #
  # @param timeout [Numeric, nil] Seconds to wait for condition to be true, -1 is forever
  # @return [true, false, nil]
  #
  # source://good_job//lib/good_job/notifier.rb#96
  def connected?(timeout: T.unsafe(nil)); end

  # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#74
  def connection; end

  # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#116
  def connection=(obj); end

  # Invoked on completion of ThreadPoolExecutor task
  #
  # @return [void]
  #
  # source://good_job//lib/good_job/notifier.rb#158
  def listen_observer(_time, _result, thread_error); end

  # Tests whether the notifier is listening for new messages.
  #
  # @param timeout [Numeric, nil] Seconds to wait for condition to be true, -1 is forever
  # @return [true, false, nil]
  #
  # source://good_job//lib/good_job/notifier.rb#107
  def listening?(timeout: T.unsafe(nil)); end

  # List of recipients that will receive notifications.
  #
  # @return [Array<#call, Array(Object, Symbol)>]
  #
  # source://good_job//lib/good_job/notifier.rb#64
  def recipients; end

  # Restart the notifier.
  # When shutdown, start; or shutdown and start.
  #
  # @param timeout [nil, Numeric] Seconds to wait; shares same values as {#shutdown}.
  # @return [void]
  #
  # source://good_job//lib/good_job/notifier.rb#148
  def restart(timeout: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://good_job//lib/good_job/notifier.rb#89
  def running?; end

  # Shut down the notifier.
  # This stops the background LISTENing thread.
  # Use {#shutdown?} to determine whether threads have stopped.
  #
  # @param timeout [Numeric, nil] Seconds to wait for active threads.
  #   * +nil+, the scheduler will trigger a shutdown but not wait for it to complete.
  #   * +-1+, the scheduler will wait until the shutdown is complete.
  #   * A positive number will wait that many seconds before stopping any remaining active threads.
  # @return [void]
  #
  # source://good_job//lib/good_job/notifier.rb#127
  def shutdown(timeout: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://good_job//lib/good_job/notifier.rb#115
  def shutdown?; end

  # source://good_job//lib/good_job/notifier.rb#190
  def synchronize(*_arg0, **_arg1, &_arg2); end

  private

  # source://good_job//lib/good_job/notifier.rb#202
  def create_listen_task(delay: T.unsafe(nil)); end

  # source://good_job//lib/good_job/notifier.rb#293
  def reset_connection_errors; end

  # source://good_job//lib/good_job/notifier.rb#192
  def start; end

  # source://good_job//lib/good_job/notifier.rb#269
  def wait_for_notify; end

  # source://good_job//lib/good_job/notifier.rb#255
  def with_connection; end

  class << self
    # source://activesupport/7.2.1.1/lib/active_support/callbacks.rb#70
    def __callbacks; end

    # source://activesupport/7.2.1.1/lib/active_support/callbacks.rb#70
    def __callbacks=(value); end

    # source://activesupport/7.2.1.1/lib/active_support/callbacks.rb#70
    def __callbacks?; end

    # source://activesupport/7.2.1.1/lib/active_support/callbacks.rb#916
    def _listen_callbacks; end

    # source://activesupport/7.2.1.1/lib/active_support/callbacks.rb#920
    def _listen_callbacks=(value); end

    # source://activesupport/7.2.1.1/lib/active_support/callbacks.rb#916
    def _tick_callbacks; end

    # source://activesupport/7.2.1.1/lib/active_support/callbacks.rb#920
    def _tick_callbacks=(value); end

    # source://activesupport/7.2.1.1/lib/active_support/callbacks.rb#916
    def _unlisten_callbacks; end

    # source://activesupport/7.2.1.1/lib/active_support/callbacks.rb#920
    def _unlisten_callbacks=(value); end

    # ActiveRecord Connection that has been established for the Notifier.
    #
    # @return [ActiveRecord::ConnectionAdapters::AbstractAdapter, nil]
    #
    # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#49
    def connection; end

    # ActiveRecord Connection that has been established for the Notifier.
    #
    # @return [ActiveRecord::ConnectionAdapters::AbstractAdapter, nil]
    #
    # source://activesupport/7.2.1.1/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#108
    def connection=(obj); end

    # List of all instantiated Notifiers in the current process.
    #
    # @return [Array<GoodJob::Notifier>, nil]
    #
    # source://good_job//lib/good_job/notifier.rb#45
    def instances; end

    # Send a message via Postgres NOTIFY
    #
    # @param message [#to_json]
    #
    # source://good_job//lib/good_job/notifier.rb#55
    def notify(message); end
  end
end

# Default Postgres channel for LISTEN/NOTIFY
#
# source://good_job//lib/good_job/notifier.rb#23
GoodJob::Notifier::CHANNEL = T.let(T.unsafe(nil), String)

# Connection errors that will wait {RECONNECT_INTERVAL} before reconnecting
#
# source://good_job//lib/good_job/notifier.rb#34
GoodJob::Notifier::CONNECTION_ERRORS = T.let(T.unsafe(nil), Array)

# Number of consecutive connection errors before reporting an error
#
# source://good_job//lib/good_job/notifier.rb#29
GoodJob::Notifier::CONNECTION_ERRORS_REPORTING_THRESHOLD = T.let(T.unsafe(nil), Integer)

# Interval for emitting a noop SQL query to keep the connection alive
#
# source://good_job//lib/good_job/notifier.rb#31
GoodJob::Notifier::KEEPALIVE_INTERVAL = T.let(T.unsafe(nil), Integer)

# Extends the Notifier to register the process in the database.
#
# source://good_job//lib/good_job/notifier/process_heartbeat.rb#6
module GoodJob::Notifier::ProcessHeartbeat
  extend ::ActiveSupport::Concern

  # Deregisters the current process.
  #
  # source://good_job//lib/good_job/notifier/process_heartbeat.rb#35
  def deregister_process; end

  # source://good_job//lib/good_job/notifier/process_heartbeat.rb#24
  def refresh_process; end

  # Registers the current process.
  #
  # source://good_job//lib/good_job/notifier/process_heartbeat.rb#16
  def register_process; end
end

# Seconds to wait if database cannot be connected to
#
# source://good_job//lib/good_job/notifier.rb#27
GoodJob::Notifier::RECONNECT_INTERVAL = T.let(T.unsafe(nil), Integer)

# Seconds to block while LISTENing for a message
#
# source://good_job//lib/good_job/notifier.rb#25
GoodJob::Notifier::WAIT_INTERVAL = T.let(T.unsafe(nil), Integer)

# Extends an ActiveRecord odel to override the connection and use
# an explicit connection that has been removed from the pool.
#
# source://good_job//lib/good_job/overridable_connection.rb#6
module GoodJob::OverridableConnection
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::GoodJob::OverridableConnection::ClassMethods
end

# source://good_job//lib/good_job/overridable_connection.rb#0
module GoodJob::OverridableConnection::ClassMethods
  # source://good_job//lib/good_job/overridable_connection.rb#16
  def connection; end

  # source://good_job//lib/good_job/overridable_connection.rb#23
  def override_connection(conn); end
end

class GoodJob::PerformanceController < ::GoodJob::ApplicationController
  def index; end
  def show; end

  private

  # source://actionview/7.2.1.1/lib/action_view/layouts.rb#328
  def _layout(lookup_context, formats); end

  class << self
    # source://actionpack/7.2.1.1/lib/action_controller/metal.rb#288
    def middleware_stack; end
  end
end

class GoodJob::PerformanceIndexChart < ::GoodJob::BaseChart
  def data; end
end

class GoodJob::PerformanceShowChart < ::GoodJob::BaseChart
  def initialize(job_class); end

  def data; end
end

GoodJob::PerformanceShowChart::BUCKET_INTERVALS = T.let(T.unsafe(nil), Array)

# Pollers regularly wake up execution threads to check for new work.
#
# source://good_job//lib/good_job/poller.rb#9
class GoodJob::Poller
  # @param recipients [Array<Proc, #call, Array(Object, Symbol)>]
  # @param poll_interval [Integer, nil] number of seconds between polls
  # @return [Poller] a new instance of Poller
  #
  # source://good_job//lib/good_job/poller.rb#36
  def initialize(*recipients, poll_interval: T.unsafe(nil)); end

  # List of recipients that will receive notifications.
  #
  # @return [Array<#call, Array(Object, Symbol)>]
  #
  # source://good_job//lib/good_job/poller.rb#32
  def recipients; end

  # Restart the poller.
  # When shutdown, start; or shutdown and start.
  #
  # @param timeout [Numeric, nil] Seconds to wait; shares same values as {#shutdown}.
  # @return [void]
  #
  # source://good_job//lib/good_job/poller.rb#79
  def restart(timeout: T.unsafe(nil)); end

  # Tests whether the timer is running.
  #
  # @return [true, false, nil]
  #
  # source://good_job//lib/good_job/poller.rb#48
  def running?(*_arg0, **_arg1, &_arg2); end

  # Shut down the poller.
  # Use {#shutdown?} to determine whether threads have stopped.
  #
  # @param timeout [nil, Numeric] Seconds to wait for active threads.
  #   * +nil+, the scheduler will trigger a shutdown but not wait for it to complete.
  #   * +-1+, the scheduler will wait until the shutdown is complete.
  #   * +0+, the scheduler will immediately shutdown and stop any threads.
  #   * A positive number will wait that many seconds before stopping any remaining active threads.
  # @return [void]
  #
  # source://good_job//lib/good_job/poller.rb#64
  def shutdown(timeout: T.unsafe(nil)); end

  # Tests whether the timer is shutdown.
  #
  # @return [true, false, nil]
  #
  # source://good_job//lib/good_job/poller.rb#52
  def shutdown?; end

  # Invoked on completion of TimerTask task.
  #
  # @param time [Integer]
  # @param executed_task [Object, nil]
  # @param thread_error [Exception, nil]
  # @return [void]
  #
  # source://good_job//lib/good_job/poller.rb#90
  def timer_observer(time, executed_task, thread_error); end

  private

  # @return [void]
  #
  # source://good_job//lib/good_job/poller.rb#101
  def create_timer; end

  # @return [Concurrent::TimerTask]
  #
  # source://good_job//lib/good_job/poller.rb#98
  def timer; end

  class << self
    # Creates GoodJob::Poller from a GoodJob::Configuration instance.
    #
    # @param configuration [GoodJob::Configuration]
    # @return [GoodJob::Poller]
    #
    # source://good_job//lib/good_job/poller.rb#26
    def from_configuration(configuration); end

    # List of all instantiated Pollers in the current process.
    #
    # @return [Array<GoodJob::Poller>, nil]
    #
    # source://good_job//lib/good_job/poller.rb#21
    def instances; end
  end
end

# Defaults for instance of Concurrent::TimerTask.
# The timer controls how and when sleeping threads check for new work.
#
# source://good_job//lib/good_job/poller.rb#12
GoodJob::Poller::DEFAULT_TIMER_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://good_job//lib/good_job/probe_server.rb#4
class GoodJob::ProbeServer
  # @return [ProbeServer] a new instance of ProbeServer
  #
  # source://good_job//lib/good_job/probe_server.rb#18
  def initialize(port:, handler: T.unsafe(nil), app: T.unsafe(nil)); end

  # source://good_job//lib/good_job/probe_server.rb#38
  def build_handler(port:, handler:, app:); end

  # @return [Boolean]
  #
  # source://good_job//lib/good_job/probe_server.rb#29
  def running?; end

  # source://good_job//lib/good_job/probe_server.rb#23
  def start; end

  # source://good_job//lib/good_job/probe_server.rb#33
  def stop; end

  class << self
    # source://good_job//lib/good_job/probe_server.rb#11
    def default_app; end

    # source://good_job//lib/good_job/probe_server.rb#5
    def task_observer(time, output, thread_error); end
  end
end

# source://good_job//lib/good_job/probe_server/healthcheck_middleware.rb#5
class GoodJob::ProbeServer::HealthcheckMiddleware
  # @return [HealthcheckMiddleware] a new instance of HealthcheckMiddleware
  #
  # source://good_job//lib/good_job/probe_server/healthcheck_middleware.rb#6
  def initialize(app); end

  # source://good_job//lib/good_job/probe_server/healthcheck_middleware.rb#10
  def call(env); end
end

# source://good_job//lib/good_job/probe_server/not_found_app.rb#5
module GoodJob::ProbeServer::NotFoundApp
  class << self
    # source://good_job//lib/good_job/probe_server/not_found_app.rb#6
    def call(_env); end
  end
end

# source://good_job//lib/good_job/probe_server/simple_handler.rb#5
class GoodJob::ProbeServer::SimpleHandler
  # @return [SimpleHandler] a new instance of SimpleHandler
  #
  # source://good_job//lib/good_job/probe_server/simple_handler.rb#8
  def initialize(app, options = T.unsafe(nil)); end

  # source://good_job//lib/good_job/probe_server/simple_handler.rb#25
  def build_future; end

  # @return [Boolean]
  #
  # source://good_job//lib/good_job/probe_server/simple_handler.rb#21
  def running?; end

  # source://good_job//lib/good_job/probe_server/simple_handler.rb#16
  def stop; end

  private

  # source://good_job//lib/good_job/probe_server/simple_handler.rb#48
  def handle_connections; end

  # source://good_job//lib/good_job/probe_server/simple_handler.rb#69
  def parse_request(request); end

  # source://good_job//lib/good_job/probe_server/simple_handler.rb#75
  def respond(client, status, headers, body); end

  # source://good_job//lib/good_job/probe_server/simple_handler.rb#31
  def run; end

  # source://good_job//lib/good_job/probe_server/simple_handler.rb#41
  def start_server; end
end

# in seconds
#
# source://good_job//lib/good_job/probe_server/simple_handler.rb#6
GoodJob::ProbeServer::SimpleHandler::SOCKET_READ_TIMEOUT = T.let(T.unsafe(nil), Integer)

# source://good_job//lib/good_job/probe_server/webrick_handler.rb#5
class GoodJob::ProbeServer::WebrickHandler
  # @return [WebrickHandler] a new instance of WebrickHandler
  #
  # source://good_job//lib/good_job/probe_server/webrick_handler.rb#6
  def initialize(app, options = T.unsafe(nil)); end

  # source://good_job//lib/good_job/probe_server/webrick_handler.rb#31
  def build_future; end

  # @return [Boolean]
  #
  # source://good_job//lib/good_job/probe_server/webrick_handler.rb#27
  def running?; end

  # source://good_job//lib/good_job/probe_server/webrick_handler.rb#23
  def stop; end
end

class GoodJob::ProcessesController < ::GoodJob::ApplicationController
  def index; end

  private

  # source://actionview/7.2.1.1/lib/action_view/layouts.rb#328
  def _layout(lookup_context, formats); end

  class << self
    # source://actionpack/7.2.1.1/lib/action_controller/metal.rb#288
    def middleware_stack; end
  end
end

module GoodJob::Reportable
  def last_status_at; end
  def status; end
end

class GoodJob::ScheduledByQueueChart < ::GoodJob::BaseChart
  def initialize(filter); end

  def data; end
end

# Schedulers are generic thread pools that are responsible for
# periodically checking for available tasks, executing tasks within a thread,
# and efficiently scaling active threads.
#
# Every scheduler has a single {JobPerformer} that will execute tasks.
# The scheduler is responsible for calling its performer efficiently across threads managed by an instance of +Concurrent::ThreadPoolExecutor+.
# If a performer does not have work, the thread will go to sleep.
# The scheduler maintains an instance of +Concurrent::TimerTask+, which wakes sleeping threads and causes them to check whether the performer has new work.
#
# source://good_job//lib/good_job/scheduler.rb#19
class GoodJob::Scheduler
  # @param performer [GoodJob::JobPerformer]
  # @param max_threads [Numeric, nil] number of seconds between polls for jobs
  # @param max_cache [Numeric, nil] maximum number of scheduled jobs to cache in memory
  # @param warm_cache_on_initialize [Boolean] whether to warm the cache immediately, or manually by calling +warm_cache+
  # @param cleanup_interval_seconds [Numeric, nil] number of seconds between cleaning up job records
  # @param cleanup_interval_jobs [Numeric, nil] number of executed jobs between cleaning up job records
  # @raise [ArgumentError]
  # @return [Scheduler] a new instance of Scheduler
  #
  # source://good_job//lib/good_job/scheduler.rb#48
  def initialize(performer, max_threads: T.unsafe(nil), max_cache: T.unsafe(nil), warm_cache_on_initialize: T.unsafe(nil), cleanup_interval_seconds: T.unsafe(nil), cleanup_interval_jobs: T.unsafe(nil)); end

  # Preload existing runnable and future-scheduled jobs
  #
  # @return [void]
  #
  # source://good_job//lib/good_job/scheduler.rb#238
  def cleanup; end

  # Wakes a thread to allow the performer to execute a task.
  #
  # @param state [Hash, nil] Contextual information for the performer. See {JobPerformer#next?}.
  # @return [Boolean, nil] Whether work was started.
  #   * +nil+ if the scheduler is unable to take new work, for example if the thread pool is shut down or at capacity.
  #   * +true+ if the performer started executing work.
  #   * +false+ if the performer decides not to attempt to execute a task based on the +state+ that is passed to it.
  #
  # source://good_job//lib/good_job/scheduler.rb#131
  def create_thread(state = T.unsafe(nil)); end

  # Human readable name of the scheduler that includes configuration values.
  #
  # @return [String]
  #
  # source://good_job//lib/good_job/scheduler.rb#40
  def name; end

  # Restart the Scheduler.
  # When shutdown, start; or shutdown and start.
  #
  # @param timeout [Numeric] Seconds to wait for actively executing jobs to finish; shares same values as {#shutdown}.
  # @raise [ArgumentError]
  # @return [void]
  #
  # source://good_job//lib/good_job/scheduler.rb#114
  def restart(timeout: T.unsafe(nil)); end

  # Tests whether the scheduler is running.
  #
  # @return [Boolean, nil]
  #
  # source://good_job//lib/good_job/scheduler.rb#72
  def running?(*_arg0, **_arg1, &_arg2); end

  # Shut down the scheduler.
  # This stops all threads in the thread pool.
  # Use {#shutdown?} to determine whether threads have stopped.
  #
  # @param timeout [Numeric, nil] Seconds to wait for actively executing jobs to finish
  #   * +nil+, the scheduler will trigger a shutdown but not wait for it to complete.
  #   * +-1+, the scheduler will wait until the shutdown is complete.
  #   * +0+, the scheduler will immediately shutdown and stop any active tasks.
  #   * A positive number will wait that many seconds before stopping any remaining active tasks.
  # @return [void]
  #
  # source://good_job//lib/good_job/scheduler.rb#89
  def shutdown(timeout: T.unsafe(nil)); end

  # Tests whether the scheduler is shutdown and no tasks are running.
  #
  # @return [Boolean, nil]
  #
  # source://good_job//lib/good_job/scheduler.rb#76
  def shutdown?; end

  # Information about the Scheduler
  #
  # @return [Hash]
  #
  # source://good_job//lib/good_job/scheduler.rb#197
  def stats; end

  # Invoked on completion of ThreadPoolExecutor task
  #
  # @return [void]
  #
  # source://good_job//lib/good_job/scheduler.rb#178
  def task_observer(time, output, thread_error); end

  # Preload existing runnable and future-scheduled jobs
  #
  # @return [void]
  #
  # source://good_job//lib/good_job/scheduler.rb#214
  def warm_cache; end

  private

  # source://good_job//lib/good_job/scheduler.rb#298
  def cache_count; end

  # @return [void]
  #
  # source://good_job//lib/good_job/scheduler.rb#260
  def create_executor; end

  # @param delay [Integer]
  # @param fanout [Boolean] Whether to eagerly create a 2nd execution thread if a job is found.
  # @return [void]
  #
  # source://good_job//lib/good_job/scheduler.rb#270
  def create_task(delay = T.unsafe(nil), fanout: T.unsafe(nil)); end

  # Returns the value of attribute executor.
  #
  # source://good_job//lib/good_job/scheduler.rb#257
  def executor; end

  # @param name [String]
  # @param payload [Hash]
  # @return [void]
  #
  # source://good_job//lib/good_job/scheduler.rb#288
  def instrument(name, payload = T.unsafe(nil), &block); end

  # Returns the value of attribute performer.
  #
  # source://good_job//lib/good_job/scheduler.rb#257
  def performer; end

  # source://good_job//lib/good_job/scheduler.rb#302
  def remaining_cache_count; end

  # Returns the value of attribute timer_set.
  #
  # source://good_job//lib/good_job/scheduler.rb#257
  def timer_set; end

  class << self
    # List of all instantiated Schedulers in the current process.
    #
    # @return [Array<GoodJob::Scheduler>, nil]
    #
    # source://good_job//lib/good_job/scheduler.rb#36
    def instances; end
  end
end

# Defaults for instance of Concurrent::ThreadPoolExecutor
# The thread pool executor is where work is performed.
#
# source://good_job//lib/good_job/scheduler.rb#22
GoodJob::Scheduler::DEFAULT_EXECUTOR_OPTIONS = T.let(T.unsafe(nil), Hash)

# Custom sub-class of +Concurrent::ThreadPoolExecutor+ to add additional worker status.
#
# @private
#
# source://good_job//lib/good_job/scheduler.rb#308
class GoodJob::Scheduler::ThreadPoolExecutor < ::Concurrent::ThreadPoolExecutor
  # Number of inactive threads available to execute tasks.
  # https://github.com/ruby-concurrency/concurrent-ruby/issues/684#issuecomment-427594437
  #
  # @return [Integer]
  #
  # source://good_job//lib/good_job/scheduler.rb#312
  def ready_worker_count; end
end

# Custom sub-class of +Concurrent::TimerSet+ for additional behavior.
#
# @private
#
# source://good_job//lib/good_job/scheduler.rb#327
class GoodJob::Scheduler::TimerSet < ::Concurrent::TimerSet
  # Number of scheduled jobs in the queue
  #
  # @return [Integer]
  #
  # source://good_job//lib/good_job/scheduler.rb#330
  def length; end

  # Clear the queue
  #
  # @return [void]
  #
  # source://good_job//lib/good_job/scheduler.rb#336
  def reset; end
end

# SdNotify is a pure-Ruby implementation of sd_notify(3). It can be used to
# notify systemd about state changes. Methods of this package are no-op on
# non-systemd systems (eg. Darwin).
#
# The API maps closely to the original implementation of sd_notify(3),
# therefore be sure to check the official man pages prior to using SdNotify.
#
# @see https://www.freedesktop.org/software/systemd/man/sd_notify.html
#
# source://good_job//lib/good_job/sd_notify.rb#45
module GoodJob::SdNotify
  class << self
    # @param errno [Integer]
    #
    # source://good_job//lib/good_job/sd_notify.rb#77
    def errno(errno, unset_env = T.unsafe(nil)); end

    # source://good_job//lib/good_job/sd_notify.rb#90
    def fdstore(unset_env = T.unsafe(nil)); end

    # @param pid [Integer]
    #
    # source://good_job//lib/good_job/sd_notify.rb#82
    def mainpid(pid, unset_env = T.unsafe(nil)); end

    # Notify systemd with the provided state, via the notification socket, if
    # any.
    #
    # Generally this method will be used indirectly through the other methods
    # of the library.
    #
    # @param state [String]
    # @param unset_env [Boolean]
    # @raise [NotifyError] if there was an error communicating with the systemd
    #   socket
    # @return [Fixnum, nil] the number of bytes written to the notification
    #   socket or nil if there was no socket to report to (eg. the program wasn't
    #   started by systemd)
    # @see https://www.freedesktop.org/software/systemd/man/sd_notify.html
    #
    # source://good_job//lib/good_job/sd_notify.rb#138
    def notify(state, unset_env = T.unsafe(nil)); end

    # source://good_job//lib/good_job/sd_notify.rb#58
    def ready(unset_env = T.unsafe(nil)); end

    # source://good_job//lib/good_job/sd_notify.rb#62
    def reloading(unset_env = T.unsafe(nil)); end

    # @param status [String] a custom status string that describes the current
    #   state of the service
    #
    # source://good_job//lib/good_job/sd_notify.rb#72
    def status(status, unset_env = T.unsafe(nil)); end

    # source://good_job//lib/good_job/sd_notify.rb#66
    def stopping(unset_env = T.unsafe(nil)); end

    # source://good_job//lib/good_job/sd_notify.rb#86
    def watchdog(unset_env = T.unsafe(nil)); end

    # If the $WATCHDOG_USEC environment variable is set,
    # and the $WATCHDOG_PID variable is unset or set to the PID of the current
    # process
    #
    # @note Unlike sd_watchdog_enabled(3), this method does not mutate the
    #   environment.
    # @return [Boolean] true if the service manager expects watchdog keep-alive
    #   notification messages to be sent from this process.
    #
    # source://good_job//lib/good_job/sd_notify.rb#103
    def watchdog?; end
  end
end

# source://good_job//lib/good_job/sd_notify.rb#53
GoodJob::SdNotify::ERRNO = T.let(T.unsafe(nil), String)

# source://good_job//lib/good_job/sd_notify.rb#56
GoodJob::SdNotify::FDSTORE = T.let(T.unsafe(nil), String)

# source://good_job//lib/good_job/sd_notify.rb#54
GoodJob::SdNotify::MAINPID = T.let(T.unsafe(nil), String)

# Exception raised when there's an error writing to the notification socket
#
# source://good_job//lib/good_job/sd_notify.rb#47
class GoodJob::SdNotify::NotifyError < ::RuntimeError; end

# source://good_job//lib/good_job/sd_notify.rb#49
GoodJob::SdNotify::READY = T.let(T.unsafe(nil), String)

# source://good_job//lib/good_job/sd_notify.rb#50
GoodJob::SdNotify::RELOADING = T.let(T.unsafe(nil), String)

# source://good_job//lib/good_job/sd_notify.rb#52
GoodJob::SdNotify::STATUS = T.let(T.unsafe(nil), String)

# source://good_job//lib/good_job/sd_notify.rb#51
GoodJob::SdNotify::STOPPING = T.let(T.unsafe(nil), String)

# source://good_job//lib/good_job/sd_notify.rb#55
GoodJob::SdNotify::WATCHDOG = T.let(T.unsafe(nil), String)

# source://good_job//lib/good_job/shared_executor.rb#6
class GoodJob::SharedExecutor
  include ::Logger::Severity
  include ::Concurrent::Concern::Logging
  include ::Concurrent::ExecutorService

  # @return [SharedExecutor] a new instance of SharedExecutor
  #
  # source://good_job//lib/good_job/shared_executor.rb#20
  def initialize; end

  # Returns the value of attribute executor.
  #
  # source://good_job//lib/good_job/shared_executor.rb#18
  def executor; end

  # source://good_job//lib/good_job/shared_executor.rb#26
  def post(*args, &task); end

  # source://good_job//lib/good_job/shared_executor.rb#70
  def restart(timeout: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://good_job//lib/good_job/shared_executor.rb#38
  def running?; end

  # Shut down the SharedExecutor.
  # Use {#shutdown?} to determine whether threads have stopped.
  #
  # @param timeout [Numeric, nil] Seconds to wait for active threads.
  #   * +nil+, the scheduler will trigger a shutdown but not wait for it to complete.
  #   * +-1+, the scheduler will wait until the shutdown is complete.
  #   * +0+, the scheduler will immediately shutdown and stop any threads.
  #   * A positive number will wait that many seconds before stopping any remaining active threads.
  # @return [void]
  #
  # source://good_job//lib/good_job/shared_executor.rb#56
  def shutdown(timeout: T.unsafe(nil)); end

  # Tests whether the scheduler is shutdown and no tasks are running.
  #
  # @return [Boolean, nil]
  #
  # source://good_job//lib/good_job/shared_executor.rb#44
  def shutdown?; end

  private

  # source://good_job//lib/good_job/shared_executor.rb#77
  def create_executor; end

  class << self
    # List of all instantiated SharedExecutor in the current process.
    #
    # @return [Array<GoodJob::SharedExecutor>, nil]
    #
    # source://good_job//lib/good_job/shared_executor.rb#16
    def instances; end
  end
end

# source://good_job//lib/good_job/shared_executor.rb#10
GoodJob::SharedExecutor::MAX_THREADS = T.let(T.unsafe(nil), Integer)

# Manages communication with systemd to notify it about the status of the
# GoodJob CLI. If it doesn't look like systemd is controlling the process,
# SystemdService doesn't do anything.
#
# source://good_job//lib/good_job/systemd_service.rb#12
class GoodJob::SystemdService
  # Indicates whether the service is actively notifying systemd's watchdog.
  #
  # @return [Boolean]
  #
  # source://good_job//lib/good_job/systemd_service.rb#21
  def notifying?; end

  # Notify systemd that the process is ready. If the service is configured in
  # systemd to use the watchdog, this will also start pinging the watchdog.
  #
  # source://good_job//lib/good_job/systemd_service.rb#27
  def start; end

  # Notify systemd that the process is stopping and stop pinging the watchdog
  # if currently doing so. If given a block, it will wait for the block to
  # complete before stopping watchdog notifications, so systemd has a clear
  # indication when graceful shutdown started and finished.
  #
  # source://good_job//lib/good_job/systemd_service.rb#36
  def stop; end

  private

  # source://good_job//lib/good_job/systemd_service.rb#47
  def run_watchdog; end

  # source://good_job//lib/good_job/systemd_service.rb#63
  def watchdog_interval; end

  class << self
    # source://good_job//lib/good_job/systemd_service.rb#13
    def task_observer(_time, _output, thread_error); end
  end
end

# Provides methods for determining the status of the
# current job execution thread. This is useful for determining
# whether to continue processing a job or to shut down gracefully.
#
# source://good_job//lib/good_job/thread_status.rb#7
module GoodJob::ThreadStatus
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::GoodJob::ThreadStatus::ClassMethods
end

# source://good_job//lib/good_job/thread_status.rb#0
module GoodJob::ThreadStatus::ClassMethods
  # source://good_job//lib/good_job/thread_status.rb#13
  def current_thread_running?; end

  # source://good_job//lib/good_job/thread_status.rb#21
  def current_thread_shutting_down?; end
end

# GoodJob gem version.
#
# source://good_job//lib/good_job/version.rb#5
GoodJob::VERSION = T.let(T.unsafe(nil), String)
