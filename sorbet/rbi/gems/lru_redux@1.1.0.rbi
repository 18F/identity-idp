# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `lru_redux` gem.
# Please instead update this file by running `bin/tapioca gem lru_redux`.


# source://lru_redux//lib/lru_redux/util/safe_sync.rb#3
module LruRedux; end

# Ruby 1.9 makes our life easier, Hash is already ordered
#
# This is an ultra efficient 1.9 freindly implementation
#
# source://lru_redux//lib/lru_redux/cache.rb#4
class LruRedux::Cache
  # @raise [ArgumentError]
  # @return [Cache] a new instance of Cache
  #
  # source://lru_redux//lib/lru_redux/cache.rb#5
  def initialize(*args); end

  # source://lru_redux//lib/lru_redux/cache.rb#50
  def [](key); end

  # source://lru_redux//lib/lru_redux/cache.rb#60
  def []=(key, val); end

  # source://lru_redux//lib/lru_redux/cache.rb#94
  def clear; end

  # source://lru_redux//lib/lru_redux/cache.rb#98
  def count; end

  # source://lru_redux//lib/lru_redux/cache.rb#82
  def delete(key); end

  # source://lru_redux//lib/lru_redux/cache.rb#67
  def each; end

  # used further up the chain, non thread safe each
  #
  # source://lru_redux//lib/lru_redux/cache.rb#67
  def each_unsafe; end

  # source://lru_redux//lib/lru_redux/cache.rb#82
  def evict(key); end

  # source://lru_redux//lib/lru_redux/cache.rb#40
  def fetch(key); end

  # source://lru_redux//lib/lru_redux/cache.rb#28
  def getset(key); end

  # @return [Boolean]
  #
  # source://lru_redux//lib/lru_redux/cache.rb#88
  def has_key?(key); end

  # @return [Boolean]
  #
  # source://lru_redux//lib/lru_redux/cache.rb#88
  def key?(key); end

  # @raise [ArgumentError]
  #
  # source://lru_redux//lib/lru_redux/cache.rb#14
  def max_size=(max_size); end

  # source://lru_redux//lib/lru_redux/cache.rb#77
  def to_a; end

  # source://lru_redux//lib/lru_redux/cache.rb#24
  def ttl=(_); end

  protected

  # for cache validation only, ensures all is sound
  #
  # @return [Boolean]
  #
  # source://lru_redux//lib/lru_redux/cache.rb#105
  def valid?; end
end

# source://lru_redux//lib/lru_redux/ttl/cache.rb#2
module LruRedux::TTL; end

# source://lru_redux//lib/lru_redux/ttl/cache.rb#3
class LruRedux::TTL::Cache
  # @raise [ArgumentError]
  # @return [Cache] a new instance of Cache
  #
  # source://lru_redux//lib/lru_redux/ttl/cache.rb#6
  def initialize(*args); end

  # source://lru_redux//lib/lru_redux/ttl/cache.rb#78
  def [](key); end

  # source://lru_redux//lib/lru_redux/ttl/cache.rb#90
  def []=(key, val); end

  # source://lru_redux//lib/lru_redux/ttl/cache.rb#145
  def clear; end

  # source://lru_redux//lib/lru_redux/ttl/cache.rb#154
  def count; end

  # source://lru_redux//lib/lru_redux/ttl/cache.rb#128
  def delete(key); end

  # source://lru_redux//lib/lru_redux/ttl/cache.rb#109
  def each; end

  # used further up the chain, non thread safe each
  #
  # source://lru_redux//lib/lru_redux/ttl/cache.rb#109
  def each_unsafe; end

  # source://lru_redux//lib/lru_redux/ttl/cache.rb#128
  def evict(key); end

  # source://lru_redux//lib/lru_redux/ttl/cache.rb#150
  def expire; end

  # source://lru_redux//lib/lru_redux/ttl/cache.rb#66
  def fetch(key); end

  # source://lru_redux//lib/lru_redux/ttl/cache.rb#44
  def getset(key); end

  # @return [Boolean]
  #
  # source://lru_redux//lib/lru_redux/ttl/cache.rb#137
  def has_key?(key); end

  # @return [Boolean]
  #
  # source://lru_redux//lib/lru_redux/ttl/cache.rb#137
  def key?(key); end

  # Returns the value of attribute max_size.
  #
  # source://lru_redux//lib/lru_redux/ttl/cache.rb#4
  def max_size; end

  # @raise [ArgumentError]
  #
  # source://lru_redux//lib/lru_redux/ttl/cache.rb#22
  def max_size=(max_size); end

  # source://lru_redux//lib/lru_redux/ttl/cache.rb#121
  def to_a; end

  # Returns the value of attribute ttl.
  #
  # source://lru_redux//lib/lru_redux/ttl/cache.rb#4
  def ttl; end

  # @raise [ArgumentError]
  #
  # source://lru_redux//lib/lru_redux/ttl/cache.rb#33
  def ttl=(ttl); end

  protected

  # source://lru_redux//lib/lru_redux/ttl/cache.rb#179
  def resize; end

  # source://lru_redux//lib/lru_redux/ttl/cache.rb#165
  def ttl_evict; end

  # for cache validation only, ensures all is sound
  #
  # @return [Boolean]
  #
  # source://lru_redux//lib/lru_redux/ttl/cache.rb#161
  def valid?; end
end

# source://lru_redux//lib/lru_redux/ttl/thread_safe_cache.rb#1
class LruRedux::TTL::ThreadSafeCache < ::LruRedux::TTL::Cache
  include ::MonitorMixin
  include ::LruRedux::Util::SafeSync
end

# source://lru_redux//lib/lru_redux/thread_safe_cache.rb#1
class LruRedux::ThreadSafeCache < ::LruRedux::Cache
  include ::MonitorMixin
  include ::LruRedux::Util::SafeSync
end

# source://lru_redux//lib/lru_redux/util/safe_sync.rb#4
module LruRedux::Util; end

# source://lru_redux//lib/lru_redux/util/safe_sync.rb#5
module LruRedux::Util::SafeSync
  include ::MonitorMixin

  # source://lru_redux//lib/lru_redux/util/safe_sync.rb#8
  def initialize(*args); end

  # source://lru_redux//lib/lru_redux/util/safe_sync.rb#36
  def [](key); end

  # source://lru_redux//lib/lru_redux/util/safe_sync.rb#42
  def []=(key, value); end

  # source://lru_redux//lib/lru_redux/util/safe_sync.rb#84
  def clear; end

  # source://lru_redux//lib/lru_redux/util/safe_sync.rb#90
  def count; end

  # source://lru_redux//lib/lru_redux/util/safe_sync.rb#60
  def delete(key); end

  # source://lru_redux//lib/lru_redux/util/safe_sync.rb#48
  def each; end

  # source://lru_redux//lib/lru_redux/util/safe_sync.rb#66
  def evict(key); end

  # source://lru_redux//lib/lru_redux/util/safe_sync.rb#30
  def fetch(key); end

  # source://lru_redux//lib/lru_redux/util/safe_sync.rb#24
  def getset(key); end

  # @return [Boolean]
  #
  # source://lru_redux//lib/lru_redux/util/safe_sync.rb#78
  def has_key?(key); end

  # @return [Boolean]
  #
  # source://lru_redux//lib/lru_redux/util/safe_sync.rb#72
  def key?(key); end

  # source://lru_redux//lib/lru_redux/util/safe_sync.rb#12
  def max_size=(max_size); end

  # source://lru_redux//lib/lru_redux/util/safe_sync.rb#54
  def to_a; end

  # source://lru_redux//lib/lru_redux/util/safe_sync.rb#18
  def ttl=(ttl); end

  # @return [Boolean]
  #
  # source://lru_redux//lib/lru_redux/util/safe_sync.rb#96
  def valid?; end
end

# source://lru_redux//lib/lru_redux/version.rb#2
LruRedux::VERSION = T.let(T.unsafe(nil), String)
