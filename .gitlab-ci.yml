# Jobs defined here use the idp/ci docker image from ECR by default. To find
# other available images:
#   aws ecr describe-repositories | jq '.repositories[].repositoryUri'
# Images are built via the identity-devops GitLab pipeline.

variables:
  GITLAB_CI: 'true'
  FF_SCRIPT_SECTIONS: 'true'
  JUNIT_OUTPUT: 'true'
  ECR_REGISTRY: '${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com'
  IDP_CI_SHA: 'sha256:793fd67b1c88ed3e5ee05d9252c7fda1bf27625b016cfe9cfc665eeac9134d6c'
  PKI_IMAGE_TAG: 'main'
  DASHBOARD_IMAGE_TAG: 'main'

default:
  image: '${ECR_REGISTRY}/idp/ci@${IDP_CI_SHA}'

.bundle_install: &bundle_install
  - bundle check || bundle install --deployment --jobs=4 --retry=3 --without deploy development doc production --path vendor/ruby

.yarn_install: &yarn_install
  - yarn install --frozen-lockfile --ignore-engines --cache-folder .yarn-cache

.yarn_production_install: &yarn_production_install
  - yarn install --production --frozen-lockfile --ignore-engines --cache-folder .yarn-cache

.build_cache:
  - &ruby_cache
    key:
      files:
        - Gemfile.lock
    paths:
      - vendor/ruby
    policy: pull

  - &yarn_cache
    key:
      files:
        - yarn.lock
    paths:
      - .yarn-cache/
    policy: pull

  - &yarn_production_cache
    key:
      files:
        - yarn.lock
    paths:
      - .yarn-cache/
    policy: pull

  - &assets_cache
    key: $CI_COMMIT_SHA
    paths:
      - tmp/cache/assets
      - public/assets
      - public/packs
    policy: pull

stages:
  - build
  - test

workflow:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
      when: never
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" || $CI_PIPELINE_SOURCE == "external_pull_request_event"'
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" || $CI_PIPELINE_SOURCE == "external_pull_request_event" || $CI_PIPELINE_SOURCE == "web"'
    - if: '$CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "stages/prod"'
    - if: '$CI_MERGE_REQUEST_IID || $CI_EXTERNAL_PULL_REQUEST_IID'

install:
  stage: build
  variables:
    RAILS_ENV: test
    SKIP_YARN_INSTALL: 'true'
  cache:
    - <<: *ruby_cache
      policy: pull-push
    - <<: *yarn_cache
      policy: pull-push
    - <<: *assets_cache
      policy: push

  script:
    - *bundle_install
    - *yarn_install
    - bundle exec rake assets:precompile

specs:
  stage: test
  needs:
    - job: install
  cache:
    - <<: *ruby_cache
    - <<: *yarn_cache
    - <<: *assets_cache
  variables:
    AWS_ACCESS_KEY_ID: test
    AWS_DEFAULT_REGION: us-west-2
    AWS_REGION: us-west-2
    AWS_SECRET_ACCESS_KEY: test
    CAPYBARA_WAIT_TIME_SECONDS: 5
    COVERAGE: 'true'
    DOCKER_DB_HOST: db-postgres
    POSTGRES_DB: identity_idp_test
    POSTGRES_USER: postgres_user
    POSTGRES_PASSWORD: postgres_password
    POSTGRES_HOST_AUTH_METHOD: trust
    RAILS_ENV: test
  services:
    - name: postgis/postgis:13-3.3
      alias: db-postgres
      command: ['--fsync=false', '--synchronous_commit=false', '--full_page_writes=false']
    - name: redis:7.0
      alias: db-redis
  artifacts:
    expire_in: 31d
    when: always
    paths:
      - coverage/
      - rspec.xml
      - rspec_json/
    reports:
      junit: rspec.xml
  script:
    - *bundle_install
    - *yarn_install
    - cp config/application.yml.default config/application.yml
    - cp config/service_providers.localdev.yml config/service_providers.yml
    - cp config/agencies.localdev.yml config/agencies.yml
    - cp config/iaa_gtcs{.localdev,}.yml
    - cp config/iaa_orders{.localdev,}.yml
    - cp config/iaa_statuses{.localdev,}.yml
    - cp config/integration_statuses{.localdev,}.yml
    - cp config/integrations{.localdev,}.yml
    - cp config/partner_account_statuses{.localdev,}.yml
    - cp config/partner_accounts{.localdev,}.yml
    - cp -a keys.example keys
    - cp -a certs.example certs
    - cp pwned_passwords/pwned_passwords.txt.sample pwned_passwords/pwned_passwords.txt
    - "echo -e \"test:\n  redis_url: 'redis://redis:6379/0'\n  redis_throttle_url: 'redis://redis:6379/1'\" > config/application.yml"
    - bundle exec rake db:create db:migrate --trace
    - bundle exec rake db:seed
    - bundle exec rspec --format documentation --format RspecJunitFormatter --out rspec.xml --format json --out rspec_json/rspec.json

js_build:
  stage: test
  needs:
    - job: install
  cache:
    - <<: *ruby_cache
    - <<: *yarn_production_cache
  variables:
    NODE_ENV: 'production'
    SKIP_YARN_INSTALL: 'true'
  script:
    - *bundle_install
    - *yarn_production_install
    - bundle exec rake assets:precompile
    - make lint_asset_bundle_size

build-ci-image:
  stage: build
  interruptible: true
  needs: []
  tags:
    - build-pool
  image:
    name: gcr.io/kaniko-project/executor:debug
    entrypoint: ['']
  rules:
    # Build when there are changes to the Dockerfile
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH || $CI_PIPELINE_SOURCE == "merge_request_event" || $CI_PIPELINE_SOURCE == "external_pull_request_event" || $CI_PIPELINE_SOURCE == "web"'
      changes:
        compare_to: 'refs/heads/main'
        paths:
          - dockerfiles/idp_ci.Dockerfile
  script:
    - mkdir -p /kaniko/.docker
    - |-
      KANIKOCFG="\"credsStore\":\"ecr-login\""
      if [ "x${http_proxy}" != "x" -o "x${https_proxy}" != "x" ]; then
        KANIKOCFG="${KANIKOCFG}, \"proxies\": { \"default\": { \"httpProxy\": \"${http_proxy}\", \"httpsProxy\": \"${https_proxy}\", \"noProxy\": \"${no_proxy}\"}}"
      fi
      KANIKOCFG="{ ${KANIKOCFG} }"
      echo "${KANIKOCFG}" > /kaniko/.docker/config.json
    - >-
      /kaniko/executor
      --context "${CI_PROJECT_DIR}"
      --dockerfile "${CI_PROJECT_DIR}/dockerfiles/idp_ci.Dockerfile"
      --destination "${ECR_REGISTRY}/idp/ci:latest"
      --destination "${ECR_REGISTRY}/idp/ci:${CI_COMMIT_SHA}"
      --build-arg "http_proxy=${http_proxy}" --build-arg "https_proxy=${https_proxy}" --build-arg "no_proxy=${no_proxy}"

secret_detection:
  allow_failure: false
  variables:
    SECRET_DETECTION_EXCLUDED_PATHS: 'keys.example,config/artifacts.example,public/acuant/*/opencv.min.js,tmp/0.0.0.0-3000.key'
    SECRET_DETECTION_REPORT_FILE: 'gl-secret-detection-report.json'
  rules:
    - if: $SECRET_DETECTION_DISABLED
      when: never
    - if: '$CI_COMMIT_BRANCH || $CI_COMMIT_TAG'
    - if: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "main"
      variables:
        SECRET_DETECTION_LOG_OPTIONS: origin/${CI_MERGE_REQUEST_TARGET_BRANCH_NAME}..HEAD
    - if: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME != "main" && $CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME == "main"
      variables:
        SECRET_DETECTION_LOG_OPTIONS: origin/${CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME}..HEAD
  before_script:
    - apk add --no-cache jq
    - git fetch origin --quiet
  script:
    - |
      if [ -z "$SECRET_DETECTION_LOG_OPTIONS" ]; then
        /analyzer run
        if [ -f "$SECRET_DETECTION_REPORT_FILE" ]; then
          # check if '{ "vulnerabilities": [], ..' is empty in the report file if it exists
          if [ "$(jq ".vulnerabilities | length" $SECRET_DETECTION_REPORT_FILE)" -gt 0 ]; then
            echo "Vulnerabilities detected. Please analyze the artifact $SECRET_DETECTION_REPORT_FILE produced by the 'secret-detection' job."
            exit 80
          fi
        else
          echo "Artifact $SECRET_DETECTION_REPORT_FILE does not exist. The 'secret-detection' job likely didn't create one. Hence, no evaluation can be performed."
        fi
      else
        echo "Skipping because this is not a PR or is not targeting main"
        exit 0
      fi
