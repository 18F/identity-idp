# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `simple_xlsx_reader` gem.
# Please instead update this file by running `bin/tapioca gem simple_xlsx_reader`.


# source://simple_xlsx_reader//lib/simple_xlsx_reader/version.rb#3
module SimpleXlsxReader
  class << self
    # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#37
    def configuration; end

    # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#44
    def open(file_path); end

    # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#48
    def parse(string_or_io); end
  end
end

# source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#34
class SimpleXlsxReader::CellLoadError < ::StandardError; end

# source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#31
SimpleXlsxReader::DATE_SYSTEM_1900 = T.let(T.unsafe(nil), Date)

# source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#32
SimpleXlsxReader::DATE_SYSTEM_1904 = T.let(T.unsafe(nil), Date)

# Main class for the public API. See the README for usage examples,
# or read the code, it's pretty friendly.
#
# source://simple_xlsx_reader//lib/simple_xlsx_reader/document.rb#10
class SimpleXlsxReader::Document
  # @return [Document] a new instance of Document
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/document.rb#13
  def initialize(legacy_file_path = T.unsafe(nil), file_path: T.unsafe(nil), string_or_io: T.unsafe(nil)); end

  # source://simple_xlsx_reader//lib/simple_xlsx_reader/document.rb#19
  def sheets; end

  # Returns the value of attribute string_or_io.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/document.rb#11
  def string_or_io; end

  # Expensive because it slurps all the sheets into memory,
  # probably only appropriate for testing
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/document.rb#25
  def to_hash; end
end

# Waits until we call #each with a block to parse the rows
#
# source://simple_xlsx_reader//lib/simple_xlsx_reader/document.rb#55
class SimpleXlsxReader::Document::RowsProxy
  include ::Enumerable

  # @return [RowsProxy] a new instance of RowsProxy
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/document.rb#60
  def initialize(sheet_parser:); end

  # source://simple_xlsx_reader//lib/simple_xlsx_reader/document.rb#126
  def [](*args); end

  # By default, #each streams the rows to the provided block, either as
  # arrays, or as header => cell value pairs if provided a `headers:`
  # argument.
  #
  # `headers` can be:
  #
  # * `true` - simply takes the first row as the header row
  # * block - calls the block with successive rows until the block returns
  #   true, which it then uses that row for the headers. All data prior to
  #   finding the headers is ignored.
  # * hash - transforms the header row by replacing cells with keys matched
  #   by value, ex. `{id: /ID|Identity/, name: /Name/i, date: 'Date'}` would
  #   potentially yield the row `{id: 5, name: 'Jane', date: [Date object]}`
  #   instead of the headers from the sheet. It would also search for the
  #   row that matches at least one header, in case the header row isn't the
  #   first.
  #
  # If rows have been slurped, #each will iterate the slurped rows instead.
  #
  # Note, calls to this after slurping will raise if given the `headers:`
  # argument, as that's handled by the sheet parser. If this is important
  # to someone, speak up and we could potentially support it.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/document.rb#88
  def each(headers: T.unsafe(nil), &block); end

  # Returns the value of attribute load_errors.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/document.rb#58
  def load_errors; end

  # source://simple_xlsx_reader//lib/simple_xlsx_reader/document.rb#132
  def shift(*args); end

  # Mostly for legacy support, I'm not aware of a use case for doing this
  # when you don't have to.
  #
  # Note that #each will use slurped results if available, and since we're
  # leveraging Enumerable, all the other Enumerable methods will too.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/document.rb#110
  def slurp; end

  # Returns the value of attribute slurped.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/document.rb#58
  def slurped; end

  # source://simple_xlsx_reader//lib/simple_xlsx_reader/document.rb#120
  def slurped!; end

  # @return [Boolean]
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/document.rb#116
  def slurped?; end

  private

  # source://simple_xlsx_reader//lib/simple_xlsx_reader/document.rb#140
  def check_slurped; end
end

# `rows` is a RowsProxy that responds to #each
#
# source://simple_xlsx_reader//lib/simple_xlsx_reader/document.rb#30
class SimpleXlsxReader::Document::Sheet
  extend ::Forwardable

  # @return [Sheet] a new instance of Sheet
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/document.rb#37
  def initialize(name:, sheet_parser:); end

  # Legacy - consider `rows` or `rows.each(headers: true)` for better
  # performance
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/document.rb#49
  def data; end

  # Legacy - consider `rows.each(headers: true)` for better performance
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/document.rb#43
  def headers; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def load_errors(*args, **_arg1, &block); end

  # Returns the value of attribute name.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/document.rb#33
  def name; end

  # Returns the value of attribute rows.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/document.rb#33
  def rows; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def slurp(*args, **_arg1, &block); end
end

# We support hyperlinks as a "type" even though they're technically
# represented either as a function or an external reference in the xlsx spec.
#
# In practice, hyperlinks are usually a link or a mailto. In the case of a
# link, we probably want to follow it to download something, but in the case
# of an email, we probably just want the email and not the mailto. So we
# represent a hyperlink primarily as it is seen by the user, following the
# principle of least surprise, but the url is accessible via #url.
#
# Microsoft calls the visible part of a hyperlink cell the "friendly name,"
# so we expose that as a method too, in case you want to be explicit about
# how you're accessing it.
#
# See MS documentation on the HYPERLINK function for some background:
# https://support.office.com/en-us/article/HYPERLINK-function-333c7ce6-c5ae-4164-9c47-7de9b76f577f
#
# source://simple_xlsx_reader//lib/simple_xlsx_reader/hyperlink.rb#19
class SimpleXlsxReader::Hyperlink < ::String
  # @return [Hyperlink] a new instance of Hyperlink
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/hyperlink.rb#23
  def initialize(url, friendly_name = T.unsafe(nil)); end

  # Returns the value of attribute friendly_name.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/hyperlink.rb#20
  def friendly_name; end

  # Returns the value of attribute url.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/hyperlink.rb#21
  def url; end
end

# source://simple_xlsx_reader//lib/simple_xlsx_reader/loader.rb#4
class SimpleXlsxReader::Loader < ::Struct
  # Returns the value of attribute base_date.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader.rb#5
  def base_date; end

  # Sets the attribute base_date
  #
  # @param value the value to set the attribute base_date to.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader.rb#5
  def base_date=(_arg0); end

  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader.rb#7
  def init_sheets; end

  # Returns the value of attribute shared_strings.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader.rb#5
  def shared_strings; end

  # Sets the attribute shared_strings
  #
  # @param value the value to set the attribute shared_strings to.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader.rb#5
  def shared_strings=(_arg0); end

  # Returns the value of attribute sheet_parsers.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader.rb#5
  def sheet_parsers; end

  # Sets the attribute sheet_parsers
  #
  # @param value the value to set the attribute sheet_parsers to.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader.rb#5
  def sheet_parsers=(_arg0); end

  # Returns the value of attribute sheet_toc.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader.rb#5
  def sheet_toc; end

  # Sets the attribute sheet_toc
  #
  # @param value the value to set the attribute sheet_toc to.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader.rb#5
  def sheet_toc=(_arg0); end

  # Returns the value of attribute style_types.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader.rb#5
  def style_types; end

  # Sets the attribute style_types
  #
  # @param value the value to set the attribute style_types to.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader.rb#5
  def style_types=(_arg0); end

  class << self
    # The heart of typecasting. The ruby type is determined either explicitly
    # from the cell xml or implicitly from the cell style, and this
    # method expects that work to have been done already. This, then,
    # takes the type we determined it to be and casts the cell value
    # to that type.
    #
    # types:
    # - s: shared string (see #shared_string)
    # - n: number (cast to a float)
    # - b: boolean
    # - str: string
    # - inlineStr: string
    # - ruby symbol: for when type has been determined by style
    #
    # options:
    # - shared_strings: needed for 's' (shared string) type
    #
    # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader.rb#120
    def cast(value, type, style, options = T.unsafe(nil)); end
  end
end

# source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/style_types_parser.rb#11
SimpleXlsxReader::Loader::NumFmtMap = T.let(T.unsafe(nil), Hash)

# For performance reasons, excel uses an optional SpreadsheetML feature
# that puts all strings in a separate xml file, and then references
# them by their index in that file.
#
# http://msdn.microsoft.com/en-us/library/office/gg278314.aspx
#
# source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/shared_strings_parser.rb#10
class SimpleXlsxReader::Loader::SharedStringsParser < ::Nokogiri::XML::SAX::Document
  # @return [SharedStringsParser] a new instance of SharedStringsParser
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/shared_strings_parser.rb#17
  def initialize; end

  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/shared_strings_parser.rb#32
  def characters(string); end

  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/shared_strings_parser.rb#38
  def end_element(name); end

  # Returns the value of attribute result.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/shared_strings_parser.rb#23
  def result; end

  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/shared_strings_parser.rb#25
  def start_element(name, _attrs = T.unsafe(nil)); end

  class << self
    # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/shared_strings_parser.rb#11
    def parse(file); end
  end
end

# source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/sheet_parser.rb#7
class SimpleXlsxReader::Loader::SheetParser < ::Nokogiri::XML::SAX::Document
  extend ::Forwardable

  # @return [SheetParser] a new instance of SheetParser
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/sheet_parser.rb#17
  def initialize(file_io:, loader:); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def base_date(*args, **_arg1, &block); end

  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/sheet_parser.rb#233
  def cell_idx; end

  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/sheet_parser.rb#72
  def characters(string); end

  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/sheet_parser.rb#227
  def column_length; end

  # formula fits an exponential factorial function of the form:
  # 'A'   = 1
  # 'B'   = 2
  # 'Z'   = 26
  # 'AA'  = 26 * 1  + 1
  # 'AZ'  = 26 * 1  + 26
  # 'BA'  = 26 * 2  + 1
  # 'ZA'  = 26 * 26 + 1
  # 'ZZ'  = 26 * 26 + 26
  # 'AAA' = 26 * 26 * 1 + 26 * 1  + 1
  # 'AAZ' = 26 * 26 * 1 + 26 * 1  + 26
  # 'ABA' = 26 * 26 * 1 + 26 * 2  + 1
  # 'BZA' = 26 * 26 * 2 + 26 * 26 + 1
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/sheet_parser.rb#258
  def column_letter_to_number(column_letter); end

  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/sheet_parser.rb#117
  def end_element(name); end

  # Returns the value of attribute hyperlinks_by_cell.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/sheet_parser.rb#11
  def hyperlinks_by_cell; end

  # Sets the attribute hyperlinks_by_cell
  #
  # @param value the value to set the attribute hyperlinks_by_cell to.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/sheet_parser.rb#11
  def hyperlinks_by_cell=(_arg0); end

  # Returns the last column name, ex. 'E'
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/sheet_parser.rb#239
  def last_cell_letter; end

  # Returns the value of attribute load_errors.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/sheet_parser.rb#13
  def load_errors; end

  # This sax-parses the whole sheet, just to extract hyperlink refs at the end.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/sheet_parser.rb#190
  def load_gui_hyperlinks; end

  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/sheet_parser.rb#22
  def parse(headers: T.unsafe(nil), &block); end

  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/sheet_parser.rb#174
  def possibly_yield_empty_rows(headers:); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def shared_strings(*args, **_arg1, &block); end

  # SAX document hooks
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/sheet_parser.rb#56
  def start_element(name, attrs = T.unsafe(nil)); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def style_types(*args, **_arg1, &block); end

  # /End SAX hooks
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/sheet_parser.rb#159
  def test_headers_hash_against_current_row; end

  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/sheet_parser.rb#223
  def xrels; end

  # Returns the value of attribute xrels_file.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/sheet_parser.rb#10
  def xrels_file; end

  # Sets the attribute xrels_file
  #
  # @param value the value to set the attribute xrels_file to.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/sheet_parser.rb#10
  def xrels_file=(_arg0); end

  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/sheet_parser.rb#181
  def yield_row(row, headers:); end
end

# source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/sheet_parser.rb#195
class SimpleXlsxReader::Loader::SheetParser::HyperlinksParser < ::Nokogiri::XML::SAX::Document
  # @return [HyperlinksParser] a new instance of HyperlinksParser
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/sheet_parser.rb#196
  def initialize(file_io, xrels:); end

  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/sheet_parser.rb#205
  def parse; end

  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/sheet_parser.rb#211
  def start_element(name, attrs); end

  class << self
    # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/sheet_parser.rb#201
    def parse(file_io, xrels:); end
  end
end

# source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/style_types_parser.rb#5
class SimpleXlsxReader::Loader::StyleTypesParser < ::Struct
  # Map of (numFmtId >= 164) (custom styles) to our best guess at the type
  # ex. {164 => :date_time}
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/style_types_parser.rb#90
  def custom_style_types; end

  # This is the least deterministic part of reading xlsx files. Due to
  # custom styles, you can't know for sure when a date is a date other than
  # looking at its format and gessing. It's not impossible to guess right,
  # though.
  #
  # http://stackoverflow.com/questions/4948998/determining-if-an-xlsx-cell-is-date-formatted-for-excel-2007-spreadsheets
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/style_types_parser.rb#105
  def determine_custom_style_type(string); end

  # Returns the value of attribute file_io
  #
  # @return [Object] the current value of file_io
  def file_io; end

  # Sets the attribute file_io
  #
  # @param value [Object] the value to set the attribute file_io to.
  # @return [Object] the newly set value
  def file_io=(_); end

  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/style_types_parser.rb#47
  def parse; end

  # Finds the type we think a style is; For example, fmtId 14 is a date
  # style, so this would return :date.
  #
  # Note, custom styles usually (are supposed to?) have a numFmtId >= 164,
  # but in practice can sometimes be simply out of the usual "Any Language"
  # id range that goes up to 49. For example, I have seen a numFmtId of
  # 59 specified as a date. In Thai, 59 is a number format, so this seems
  # like a bad idea, but we try to be flexible and just go with it.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/style_types_parser.rb#81
  def style_type_by_num_fmt_id(id); end

  # Excel doesn't record types for some cells, only its display style, so
  # we have to back out the type from that style.
  #
  # Some of these styles can be determined from a known set (see NumFmtMap),
  # while others are 'custom' and we have to make a best guess.
  #
  # This is the array of types corresponding to the styles a spreadsheet
  # uses, and includes both the known style types and the custom styles.
  #
  # Note that the xml sheet cells that use this don't reference the
  # numFmtId, but instead the array index of a style in the stored list of
  # only the styles used in the spreadsheet (which can be either known or
  # custom). Hence this style types array, rather than a map of numFmtId to
  # type.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/style_types_parser.rb#65
  def style_types; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end

    # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/style_types_parser.rb#6
    def parse(file_io); end
  end
end

# source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/workbook_parser.rb#5
class SimpleXlsxReader::Loader::WorkbookParser < ::Struct
  # Returns the base_date from which to calculate dates.
  # Defaults to 1900 (minus two days due to excel quirk), but use 1904 if
  # it's set in the Workbook's workbookPr.
  # http://msdn.microsoft.com/en-us/library/ff530155(v=office.12).aspx
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/workbook_parser.rb#28
  def base_date; end

  # Returns the value of attribute file_io
  #
  # @return [Object] the current value of file_io
  def file_io; end

  # Sets the attribute file_io
  #
  # @param value [Object] the value to set the attribute file_io to.
  # @return [Object] the newly set value
  def file_io=(_); end

  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/workbook_parser.rb#11
  def parse; end

  # Table of contents for the sheets, ex. {'Authors' => 0, ...}
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/workbook_parser.rb#16
  def sheet_toc; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end

    # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader/workbook_parser.rb#6
    def parse(file_io); end
  end
end

# source://simple_xlsx_reader//lib/simple_xlsx_reader/loader.rb#22
class SimpleXlsxReader::Loader::ZipReader < ::Struct
  # @return [ZipReader] a new instance of ZipReader
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader.rb#25
  def initialize(*args); end

  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader.rb#84
  def add_sheet_parser_at_index(i); end

  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader.rb#67
  def entry_at(path, &block); end

  # Returns the value of attribute loader
  #
  # @return [Object] the current value of loader
  def loader; end

  # Sets the attribute loader
  #
  # @param value [Object] the value to set the attribute loader to.
  # @return [Object] the newly set value
  def loader=(_); end

  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader.rb#30
  def read; end

  # Returns the value of attribute string_or_io
  #
  # @return [Object] the current value of string_or_io
  def string_or_io; end

  # Sets the attribute string_or_io
  #
  # @param value [Object] the value to set the attribute string_or_io to.
  # @return [Object] the newly set value
  def string_or_io=(_); end

  # Returns the value of attribute zip.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader/loader.rb#23
  def zip; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://simple_xlsx_reader//lib/simple_xlsx_reader/version.rb#4
SimpleXlsxReader::VERSION = T.let(T.unsafe(nil), String)

# source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#27
SimpleXlsxReader::Zip = Zip::File
