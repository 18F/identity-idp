#!/usr/bin/env ruby
# frozen_string_literal: true
Dir.chdir(__dir__) { require 'bundler/setup' }

require 'active_support'
require 'active_support/core_ext/integer/time'
require 'active_support/core_ext/object/blank'
require 'active_support/time'
require 'aws-sdk-cloudwatchlogs'
require 'concurrent-ruby'

$LOAD_PATH.unshift(File.expand_path(File.join(__dir__, '../lib')))
require 'reporting/cloudwatch_client'
require 'reporting/cloudwatch_query_quoting'

require 'event_summarizer/example_matcher'

class SummarizeUserEvents
  attr_reader :uuid, :from_date, :to_date
  
  def initialize(argv:, stdin:, stdout:)
    # argv[0] == uuid
    # argv[1] == From date
    # argv[2] == to date

    @uuid = argv[0]
    @from_date = argv[1].present? ? Time.strptime(argv[1], '%m/%d/%Y') : 1.week.ago
    @to_date = argv[2].present? ? Time.strptime(argv[2], '%m/%d/%Y') : DateTime.now 
  end

  def matchers
    @matchers ||= [
      EventSummarizer::ExampleMatcher.new
    ]
  end

  def run
    find_cloudwatch_events do |event|
      event['@message'] = JSON.parse(event['@message']) if event['@message'].is_a?(String)

      matchers.each do |matcher|
        matcher.handle_cloudwatch_event(event)
      end
    end

    overall_results = []
    
    matchers.each do |matcher|
      results_for_matcher = matcher.finish
      overall_results.append(*results_for_matcher)
    end
    
    puts format_results(overall_results)
  end

  def format_results(results)
    results.map do |r|
      title = r[:title]

      [
        "## #{title}",
        *r[:attributes]&.map do |attr|
          "* #{attr[:description]}"
        end,
        ""
      ]
    end.join("\n")
  end

  def query
    format(<<~QUERY)
      fields
          name
        , properties.event_properties.success as success
        , @message
        , @timestamp
      | filter properties.user_id = '#{uuid}'
      | sort @timestamp asc
      | limit 10000
    QUERY
  end

  def find_events(&block)
    warn "$stdin.tty? = #{$stdin.tty?}"
    if $stdin.tty?
      cloudwatch_source(&block)
    else
      stdin_source(&block)
    end
  end

  def stdin_source(&block)
    $stdin.each_line do |line|
      next if line.blank?
      event = JSON.parse(line)
      block.call(event)
    end
  end

  def cloudwatch_source(&block)
    cloudwatch_client.fetch(
      query: query,
      from: from_date,
      to: to_date,
      &block
    )    
  end


  def cloudwatch_client
    @cloudwatch_client ||= Reporting::CloudwatchClient.new(
      num_threads: 5,
      ensure_complete_logs: true,
      log_group_name: 'prod_/srv/idp/shared/log/events.log',
    )
  end

  def find_cloudwatch_events(&block)
    if $stdin.tty?
      cloudwatch_source(&block)
    else
      warn "Reading Cloudwatch events as newline-delimited JSON (ndjson) from stdin"
      stdin_source(&block)
    end
  end

  def stdin_source(&block)
    $stdin.each_line do |line|
      next if line.blank?
      event = JSON.parse(line)
      block.call(event)
    end
  end

  def cloudwatch_source(&block)
    cloudwatch_client.fetch(
      query: query,
      from: from_date,
      to: to_date,
      &block
    )    
  end  
end


if $PROGRAM_NAME == __FILE__
  SummarizeUserEvents.new(argv: ARGV, stdin: STDIN, stdout: STDOUT).run
end