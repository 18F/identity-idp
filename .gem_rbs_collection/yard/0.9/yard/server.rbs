# !!! GENERATED FILE !!!
# Please see yard/0.9/_generators/README.md

# Namespace for classes and modules that handle serving documentation over HTTP
#
# == Implementing a Custom Server
# To customize the YARD server, see the {Adapter} and {Router} classes.
#
# == Rack Middleware
# If you want to use the YARD server as a Rack middleware, see the documentation
# in {RackMiddleware}.
#
# @since 0.6.0
module YARD::Server
  # Registers a static path to be used in static asset lookup.
  # @param [String] path the pathname to register
  # @return [void]
  # @since 0.6.2
  def self.register_static_path: (String path) -> void

  # :nodoc:
  CR: untyped

  # :nodoc:
  LF: untyped

  # :nodoc:
  CRLF: untyped
end

# This class implements the bridge between the {Router} and the server
# backend for a specific server type. YARD implements concrete adapters
# for WEBrick and Rack respectively, though other adapters can be made
# for other server architectures.
#
# == Subclassing Notes
# To create a concrete adapter class, implement the {#start} method to
# initiate the server backend.
#
# @abstract
class YARD::Server::Adapter
  # @return [String] the location where static files are located, if any.
  #   To set this field on initialization, pass +:DocumentRoot+ to the
  #   +server_opts+ argument in {#initialize}
  attr_accessor document_root: String
  # @return [Hash{String=>Array<LibraryVersion>}] a map of libraries.
  # @see LibraryVersion LibraryVersion for information on building a list of libraries
  # @see #add_library
  attr_accessor libraries: Hash[String, Array[YARD::Server::LibraryVersion]]
  # @return [Hash] options passed and processed by adapters. The actual
  #   options mostly depend on the adapters themselves.
  attr_accessor options: Hash[untyped, untyped]
  # @return [Hash] a set of options to pass to the server backend. Note
  #   that +:DocumentRoot+ also sets the {#document_root}.
  attr_accessor server_options: Hash[untyped, untyped]
  # @return [Router] the router object used to route URLs to commands
  attr_accessor router: YARD::Server::Router
  # Performs any global initialization for the adapter.
  # @note If you subclass this method, make sure to call +super+.
  # @return [void]
  def self.setup: () -> void
  # Performs any global shutdown procedures for the adapter.
  # @note If you subclass this method, make sure to call +super+.
  # @return [void]
  def self.shutdown: () -> void
  # Creates a new adapter object
  #
  # @param [Hash{String=>Array<LibraryVersion>}] libs a list of libraries,
  #   see {#libraries} for formulating this list.
  # @param [Hash] opts extra options to pass to the adapter
  # @option opts [Class] :router (Router) the router class to initialize as the
  #   adapter's router.
  # @option opts [Boolean] :caching (false) whether or not caching is enabled
  # @option opts [Boolean] :single_library (false) whether to server documentation
  #   for a single or multiple libraries (changes URL structure)
  def initialize: (Hash[String, Array[YARD::Server::LibraryVersion]] libs, ?Hash[untyped, untyped] opts, ?untyped server_opts) -> void
  # Adds a library to the {#libraries} mapping for a given library object.
  # @example Adding a new library to an adapter
  #   adapter.add_library LibraryVersion.new('mylib', '1.0', '/path/to/.yardoc')
  # @param [LibraryVersion] library a library to add
  def add_library: (YARD::Server::LibraryVersion library) -> untyped
  # Implement this method to connect your adapter to your server.
  # @abstract
  def start: () -> untyped
end

# Commands implement specific kinds of server responses which are routed
# to by the {Router} class. To implement a custom command, subclass {Commands::Base}.
module YARD::Server::Commands
end

# This is the base command class used to implement custom commands for
# a server. A command will be routed to by the {Router} class and return
# a Rack-style response.
#
# == Attribute Initializers
# All attributes can be initialized via options passed into the {#initialize}
# method. When creating a custom command, the {Adapter#options} will
# automatically be mapped to attributes by the same name on your class.
#
#   class MyCommand < Base
#     attr_accessor :myattr
#   end
#
#   Adapter.new(libs, {:myattr => 'foo'}).start
#
#   # when a request comes in, cmd.myattr == 'foo'
#
# == Subclassing Notes
# To implement a custom command, override the {#run} method, not {#call}.
# In your implementation, you should set the body and status for requests.
# See details in the +#run+ method documentation.
#
# Note that if your command deals directly with libraries, you should
# consider subclassing the more specific {LibraryCommand} class instead.
#
# @abstract
# @see #run
class YARD::Server::Commands::Base
  # @return [Hash] the options passed to the command's constructor
  attr_accessor command_options: Hash[untyped, untyped]
  # @return [Adapter] the server adapter
  attr_accessor adapter: YARD::Server::Adapter
  # @return [Boolean] whether to cache
  attr_accessor caching: bool
  # @return [String] the path after the command base URI
  attr_accessor path: String
  # @return [Hash{String => String}] response headers
  attr_accessor headers: Hash[String, String]
  # @return [Numeric] status code. Defaults to 200 per request
  attr_accessor status: Numeric
  # @return [String] the response body. Defaults to empty string.
  attr_accessor body: String
  # Creates a new command object, setting attributes named by keys
  # in the options hash. After initialization, the options hash
  # is saved in {#command_options} for further inspection.
  #
  # @example Creating a Command
  #   cmd = DisplayObjectCommand.new(:caching => true, :library => mylib)
  #   cmd.library # => mylib
  #   cmd.command_options # => {:caching => true, :library => mylib}
  # @param [Hash] opts the options hash, saved to {#command_options}
  #   after initialization.
  def initialize: (?Hash[untyped, untyped] opts) -> void
  # The main method called by a router with a request object.
  #
  # @note This command should not be overridden by subclasses. Implement
  #   the callback method {#run} instead.
  # @param [Adapter Dependent] request the request object
  # @return [Array(Numeric,Hash,Array<String>)] a Rack-style response
  #   of status, headers, and body wrapped in an array.
  def call: (untyped request) -> [ Numeric, Hash[untyped, untyped], Array[String] ]
  # Subclass this method to implement a custom command. This method
  # should set the {#status} and {#body}, and optionally modify the
  # {#headers}. Note that +#status+ defaults to 200.
  #
  # @example A custom command
  #   class ErrorCommand < Base
  #     def run
  #       self.body = 'ERROR! The System is down!'
  #       self.status = 500
  #       self.headers['Content-Type'] = 'text/plain'
  #     end
  #   end
  #
  # @abstract
  # @return [void]
  def run: () -> void
  # Renders a specific object if provided, or a regular template rendering
  # if object is not provided.
  #
  # @todo This method is dependent on +#options+, it should be in {LibraryCommand}.
  # @param [CodeObjects::Base, nil] object calls {CodeObjects::Base#format} if
  #   an object is provided, or {Templates::Engine.render} if object is nil. Both
  #   receive +#options+ as an argument.
  # @return [String] the resulting output to display
  def render: (?YARD::CodeObjects::Base? object) -> String
  # Override this method to implement custom caching mechanisms for
  #
  # @example Caching to memory
  #   $memory_cache = {}
  #   def cache(data)
  #     $memory_cache[path] = data
  #   end
  # @param [String] data the data to cache
  # @return [String] the same cached data (for chaining)
  # @see StaticCaching
  def cache: (String data) -> String
  # Sets the body and headers for a 404 response. Does not modify the
  # body if already set.
  #
  # @return [void]
  def not_found: () -> void
  # Sets the headers and status code for a redirection to a given URL
  # @param [String] url the URL to redirect to
  # @raise [FinishRequest] causes the request to terminate.
  def redirect: (String url) -> untyped
  # Add a conservative cache control policy to reduce load on
  # requests served with "?1234567890" style timestamp query strings.
  private def add_cache_control: () -> untyped
end

# Displays a README or extra file.
#
# @todo Implement better support for detecting binary (image) filetypes
class YARD::Server::Commands::DisplayFileCommand < ::YARD::Server::Commands::LibraryCommand
  attr_accessor index: untyped
  def run: () -> untyped
end

# Displays documentation for a specific object identified by the path
class YARD::Server::Commands::DisplayObjectCommand < ::YARD::Server::Commands::LibraryCommand
  def run: () -> untyped
  def index: () -> untyped
  def not_found: () -> untyped
  private def object_path: () -> untyped
  # Modifies {Templates::Helpers::HtmlHelper#url_for} to return a URL instead
  # of a disk location.
  # @param (see Templates::Helpers::HtmlHelper#url_for)
  # @return (see Templates::Helpers::HtmlHelper#url_for)
  def url_for: (String | YARD::CodeObjects::Base obj, ?String anchor, ?bool relative) -> String
  # Modifies {Templates::Helpers::HtmlHelper#url_for_file} to return a URL instead
  # of a disk location.
  # @param (see Templates::Helpers::HtmlHelper#url_for_file)
  # @return (see Templates::Helpers::HtmlHelper#url_for_file)
  def url_for_file: (String | YARD::CodeObjects::ExtraFileObject filename, ?String anchor) -> String
  # Modifies {Templates::Helpers::HtmlHelper#url_for_list} to return a URL
  # based on the list prefix instead of a HTML filename.
  # @param (see Templates::Helpers::HtmlHelper#url_for_list)
  # @return (see Templates::Helpers::HtmlHelper#url_for_list)
  def url_for_list: (String | Symbol type) -> String
  # Returns the frames URL for the page
  # @return (see Templates::Helpers::HtmlHelper#url_for_frameset)
  def url_for_frameset: () -> String
  # Returns the main URL, first checking a readme and then linking to the index
  # @return (see Templates::Helpers::HtmlHelper#url_for_main)
  def url_for_main: () -> String
  # Returns the URL for the alphabetic index page
  # @return (see Templates::Helpers::HtmlHelper#url_for_index)
  def url_for_index: () -> String
  # @param path_components [Array<String>] components of a URL
  # @return [String] the absolute path from any mounted base URI.
  def abs_url: (*Array[String] path_components) -> String
  # @example The base path for a library 'foo'
  #   base_path('docs') # => 'docs/foo'
  # @param [String] path the path prefix for a base path URI
  # @return [String] the base URI for a library with an extra +path+ prefix
  def base_path: (String path) -> String
  # @return [Router] convenience method for accessing the router
  def router: () -> YARD::Server::Router
  # @return [String] a timestamp for a given file
  def mtime: (untyped file) -> String
  # @return [String] a URL for a file with a timestamp
  def mtime_url: (untyped file) -> String
end

# Displays an object wrapped in frames
class YARD::Server::Commands::FramesCommand < ::YARD::Server::Commands::DisplayObjectCommand
  def run: () -> untyped
end

# This is the base command for all commands that deal directly with libraries.
# Some commands do not, but most (like {DisplayObjectCommand}) do. If your
# command deals with libraries directly, subclass this class instead.
# See {Base} for notes on how to subclass a command.
#
# @abstract
class YARD::Server::Commands::LibraryCommand < ::YARD::Server::Commands::Base
  # @return [LibraryVersion] the object containing library information
  attr_accessor library: YARD::Server::LibraryVersion
  # @return [LibraryOptions] default options for the library
  attr_accessor options: YARD::Server::Commands::LibraryOptions
  # @return [Serializers::Base] the serializer used to perform file linking
  attr_accessor serializer: YARD::Serializers::Base
  # @return [Boolean] whether router should route for multiple libraries
  attr_accessor single_library: bool
  # @return [Boolean] whether to reparse data
  attr_accessor incremental: bool
  # @return [Boolean] whether or not this adapter calls +fork+ when serving
  #   library requests. Defaults to false.
  attr_accessor use_fork: bool
  def initialize: (?untyped opts) -> void
  def call: (untyped request) -> untyped
  private def call_without_fork: (untyped request) -> untyped
  private def call_with_fork: (untyped request) -> untyped
  private def can_fork?: () -> bool
  private def save_default_template_info: () -> untyped
  private def restore_template_info: () -> untyped
  private def setup_library: () -> untyped
  private def setup_yardopts: () -> untyped
  private def load_yardoc: () -> untyped
  private def not_prepared: () -> untyped
  # Hack to load a custom fulldoc template object that does
  # not do any rendering/generation. We need this to access the
  # generate_*_list methods.
  private def fulldoc_template: () -> untyped
  # Needed to synchronize threads in {#setup_yardopts}
  # @private
  @@library_chdir_lock: untyped
end

# Returns the index of libraries served by the server.
class YARD::Server::Commands::LibraryIndexCommand < ::YARD::Server::Commands::Base
  attr_accessor options: untyped
  def run: () -> untyped
end

class YARD::Server::Commands::LibraryIndexOptions < ::YARD::CLI::YardocOptions
  attr_accessor adapter: untyped
  attr_accessor libraries: untyped
  #
  # @!attribute template
  attr_accessor template: untyped
  #
  # @!attribute type
  attr_accessor type: untyped
  #
  # @!attribute serialize
  attr_accessor serialize: untyped
end

class YARD::Server::Commands::LibraryOptions < ::YARD::CLI::YardocOptions
  attr_accessor command: untyped
  attr_accessor frames: untyped
  def adapter: () -> untyped
  def library: () -> untyped
  def single_library: () -> untyped
  def serializer: () -> untyped
  def serialize: () -> untyped
  def each: () -> untyped
end

# Returns a list of objects of a specific type
class YARD::Server::Commands::ListCommand < ::YARD::Server::Commands::LibraryCommand
  def run: () -> untyped
  # An object that keeps track of global state throughout the entire template
  # rendering process (including any sub-templates).
  #
  # @return [OpenStruct] a struct object that stores state
  # @since 0.6.0
  def globals: () -> OpenStruct
  # Runs a list of objects against the {Verifier} object passed into the
  # template and returns the subset of verified objects.
  #
  # @param [Array<CodeObjects::Base>] list a list of code objects
  # @return [Array<CodeObjects::Base>] a list of code objects that match
  #   the verifier. If no verifier is supplied, all objects are returned.
  def run_verifier: (Array[YARD::CodeObjects::Base] list) -> Array[YARD::CodeObjects::Base]
  # Escapes text. This is used a lot by the HtmlHelper and there should
  # be some helper to "clean up" text for whatever, this is it.
  def h: (untyped text) -> untyped
  # Links objects or URLs. This method will delegate to the correct +link_+
  # method depending on the arguments passed in.
  #
  # @example Linking a URL
  #   linkify('http://example.com')
  # @example Including docstring contents of an object
  #   linkify('include:YARD::Docstring')
  # @example Linking to an extra file
  #   linkify('file:README')
  # @example Linking an object by path
  #   linkify('YARD::Docstring')
  def linkify: (*untyped args) -> untyped
  # Includes an object's docstring into output.
  # @since 0.6.0
  # @param [CodeObjects::Base] obj the object to include
  # @return [String] the object's docstring (no tags)
  def link_include_object: (YARD::CodeObjects::Base obj) -> String
  # Include a file as a docstring in output
  # @since 0.7.0
  # @param [String] file the filename to include
  # @return [String] the file's contents
  def link_include_file: (String file) -> String
  # Links to an object with an optional title
  #
  # @param [CodeObjects::Base] obj the object to link to
  # @param [String] title the title to use for the link
  # @return [String] the linked object
  def link_object: (YARD::CodeObjects::Base obj, ?String title) -> String
  # Links to a URL
  #
  # @param [String] url the URL to link to
  # @param [String] title the optional title to display the link as
  # @param [Hash] params optional parameters for the link
  # @return [String] the linked URL
  def link_url: (String url, ?String title, ?Hash[untyped, untyped] params) -> String
  # Links to an extra file
  #
  # @param [String] filename the filename to link to
  # @param [String] title the title of the link
  # @param [String] anchor optional anchor
  # @return [String] the link to the file
  # @since 0.5.5
  def link_file: (String filename, ?String title, ?String anchor) -> String
  # Formats a list of return types for output and links each type.
  #
  # @example Formatting types
  #   format_types(['String', 'Array']) #=> "(String, Array)"
  # @example Formatting types without surrounding brackets
  #   format_types(['String', 'Array'], false) #=> "String, Array"
  # @param [Array<String>] list a list of types
  # @param [Boolean] brackets whether to surround the types in brackets
  # @return [String] the formatted list of Ruby types
  def format_types: (Array[String] list, ?bool brackets) -> String
  # @example Formatted type of an exception class
  #   o = ClassObject.new(:root, :MyError)
  #   o.superclass = P('RuntimeError')
  #   format_object_type(o) # => "Exception"
  # @example Formatted type of a method
  #   o = MethodObject.new(:root, :to_s)
  #   format_object_type(o) # => "Method"
  # @param [CodeObjects::Base] object the object to retrieve the type for
  # @return [String] the human-readable formatted {CodeObjects::Base#type #type}
  #   for the object
  def format_object_type: (YARD::CodeObjects::Base object) -> String
  # @example
  #   s = format_object_title ModuleObject.new(:root, :MyModuleName)
  #   s # => "Module: MyModuleName"
  # @param [CodeObjects::Base] object the object to retrieve a title for
  # @return [String] the page title name for a given object
  def format_object_title: (YARD::CodeObjects::Base object) -> String
  # Indents and formats source code
  #
  # @param [String] value the input source code
  # @return [String] formatted source code
  def format_source: (String value) -> String
end

# Serves requests from the root of the server
class YARD::Server::Commands::RootRequestCommand < ::YARD::Server::Commands::Base
  def run: () -> untyped
  # Serves an empty favicon.
  # @raise [FinishRequest] finalizes an empty body if the path matches
  #   /favicon.ico so browsers don't complain.
  def favicon?: () -> bool
  # Attempts to route a path to a static template file.
  #
  # @raise [FinishRequest] if a file was found and served
  # @return [void]
  def static_template_file?: () -> void
  # @since 0.6.0
  private def find_file: (untyped adapter, untyped url) -> untyped
  #
  # Normalizes a request path.  Raises an exception if the path cannot be
  # normalized.
  private def normalize_path: (untyped path) -> untyped
  #
  # Loads Apache-compatible mime.types in +file+.
  private def load_mime_types: (untyped file) -> untyped
  #
  # Returns the mime type of +filename+ from the list in +mime_tab+.  If no
  # mime type was found application/octet-stream is returned.
  private def mime_type: (untyped filename, untyped mime_tab) -> untyped
  #
  # Parses an HTTP header +raw+ into a hash of header fields with an Array
  # of values.
  private def parse_header: (untyped raw) -> untyped
  #
  # Splits a header value +str+ according to HTTP specification.
  private def split_header_value: (untyped str) -> untyped
  #
  # Parses a Range header value +ranges_specifier+
  private def parse_range_header: (untyped ranges_specifier) -> untyped
  #
  # Parses q values in +value+ as used in Accept headers.
  private def parse_qvalues: (untyped value) -> untyped
  #
  # Removes quotes and escapes from +str+
  private def dequote: (untyped str) -> untyped
  #
  # Quotes and escapes quotes in +str+
  private def quote: (untyped str) -> untyped
  #
  # Parses the query component of a URI in +str+
  private def parse_query: (untyped str) -> untyped
  #
  # Parses form data in +io+ with the given +boundary+
  private def parse_form_data: (untyped io, untyped boundary) -> untyped
  # :stopdoc:
  # @since 0.6.0
  private def _make_regex: (untyped str) -> untyped
  # @since 0.6.0
  private def _make_regex!: (untyped str) -> untyped
  # @since 0.6.0
  private def _escape: (untyped str, untyped regex) -> untyped
  # @since 0.6.0
  private def _unescape: (untyped str, untyped regex) -> untyped
  # Escapes HTTP reserved and unwise characters in +str+
  # @since 0.6.0
  private def escape: (untyped str) -> untyped
  # Unescapes HTTP reserved and unwise characters in +str+
  # @since 0.6.0
  private def unescape: (untyped str) -> untyped
  # Escapes form reserved characters in +str+
  # @since 0.6.0
  private def escape_form: (untyped str) -> untyped
  # Unescapes form reserved characters in +str+
  # @since 0.6.0
  private def unescape_form: (untyped str) -> untyped
  # Escapes path +str+
  # @since 0.6.0
  private def escape_path: (untyped str) -> untyped
  # Escapes 8 bit characters in +str+
  # @since 0.6.0
  private def escape8bit: (untyped str) -> untyped
end

# Performs a search over the objects inside of a library and returns
# the results as HTML or plaintext
class YARD::Server::Commands::SearchCommand < ::YARD::Server::Commands::LibraryCommand
  attr_accessor results: untyped
  attr_accessor query: untyped
  def run: () -> untyped
  def visible_results: () -> untyped
  private def url_for: (untyped object) -> untyped
  private def serve_xhr: () -> untyped
  private def serve_normal: () -> untyped
  private def search_for_object: () -> untyped
  # Modifies {Templates::Helpers::HtmlHelper#url_for_file} to return a URL instead
  # of a disk location.
  # @param (see Templates::Helpers::HtmlHelper#url_for_file)
  # @return (see Templates::Helpers::HtmlHelper#url_for_file)
  def url_for_file: (String | YARD::CodeObjects::ExtraFileObject filename, ?String anchor) -> String
  # Modifies {Templates::Helpers::HtmlHelper#url_for_list} to return a URL
  # based on the list prefix instead of a HTML filename.
  # @param (see Templates::Helpers::HtmlHelper#url_for_list)
  # @return (see Templates::Helpers::HtmlHelper#url_for_list)
  def url_for_list: (String | Symbol type) -> String
  # Returns the frames URL for the page
  # @return (see Templates::Helpers::HtmlHelper#url_for_frameset)
  def url_for_frameset: () -> String
  # Returns the main URL, first checking a readme and then linking to the index
  # @return (see Templates::Helpers::HtmlHelper#url_for_main)
  def url_for_main: () -> String
  # Returns the URL for the alphabetic index page
  # @return (see Templates::Helpers::HtmlHelper#url_for_index)
  def url_for_index: () -> String
  # @param path_components [Array<String>] components of a URL
  # @return [String] the absolute path from any mounted base URI.
  def abs_url: (*Array[String] path_components) -> String
  # @example The base path for a library 'foo'
  #   base_path('docs') # => 'docs/foo'
  # @param [String] path the path prefix for a base path URI
  # @return [String] the base URI for a library with an extra +path+ prefix
  def base_path: (String path) -> String
  # @return [Router] convenience method for accessing the router
  def router: () -> YARD::Server::Router
  # @return [String] a timestamp for a given file
  def mtime: (untyped file) -> String
  # @return [String] a URL for a file with a timestamp
  def mtime_url: (untyped file) -> String
  # Prunes the method listing by running the verifier and removing attributes/aliases
  # @param [Array<CodeObjects::Base>] list a list of methods
  # @param [Boolean] hide_attributes whether to prune attribute methods from the list
  # @return [Array<CodeObjects::Base>] a pruned list of methods
  def prune_method_listing: (Array[YARD::CodeObjects::Base] list, ?bool hide_attributes) -> Array[YARD::CodeObjects::Base]
  # An object that keeps track of global state throughout the entire template
  # rendering process (including any sub-templates).
  #
  # @return [OpenStruct] a struct object that stores state
  # @since 0.6.0
  def globals: () -> OpenStruct
  # Runs a list of objects against the {Verifier} object passed into the
  # template and returns the subset of verified objects.
  #
  # @param [Array<CodeObjects::Base>] list a list of code objects
  # @return [Array<CodeObjects::Base>] a list of code objects that match
  #   the verifier. If no verifier is supplied, all objects are returned.
  def run_verifier: (Array[YARD::CodeObjects::Base] list) -> Array[YARD::CodeObjects::Base]
  # Escapes text. This is used a lot by the HtmlHelper and there should
  # be some helper to "clean up" text for whatever, this is it.
  def h: (untyped text) -> untyped
  # Links objects or URLs. This method will delegate to the correct +link_+
  # method depending on the arguments passed in.
  #
  # @example Linking a URL
  #   linkify('http://example.com')
  # @example Including docstring contents of an object
  #   linkify('include:YARD::Docstring')
  # @example Linking to an extra file
  #   linkify('file:README')
  # @example Linking an object by path
  #   linkify('YARD::Docstring')
  def linkify: (*untyped args) -> untyped
  # Includes an object's docstring into output.
  # @since 0.6.0
  # @param [CodeObjects::Base] obj the object to include
  # @return [String] the object's docstring (no tags)
  def link_include_object: (YARD::CodeObjects::Base obj) -> String
  # Include a file as a docstring in output
  # @since 0.7.0
  # @param [String] file the filename to include
  # @return [String] the file's contents
  def link_include_file: (String file) -> String
  # Links to an object with an optional title
  #
  # @param [CodeObjects::Base] obj the object to link to
  # @param [String] title the title to use for the link
  # @return [String] the linked object
  def link_object: (YARD::CodeObjects::Base obj, ?String title) -> String
  # Links to a URL
  #
  # @param [String] url the URL to link to
  # @param [String] title the optional title to display the link as
  # @param [Hash] params optional parameters for the link
  # @return [String] the linked URL
  def link_url: (String url, ?String title, ?Hash[untyped, untyped] params) -> String
  # Links to an extra file
  #
  # @param [String] filename the filename to link to
  # @param [String] title the title of the link
  # @param [String] anchor optional anchor
  # @return [String] the link to the file
  # @since 0.5.5
  def link_file: (String filename, ?String title, ?String anchor) -> String
  # Formats a list of return types for output and links each type.
  #
  # @example Formatting types
  #   format_types(['String', 'Array']) #=> "(String, Array)"
  # @example Formatting types without surrounding brackets
  #   format_types(['String', 'Array'], false) #=> "String, Array"
  # @param [Array<String>] list a list of types
  # @param [Boolean] brackets whether to surround the types in brackets
  # @return [String] the formatted list of Ruby types
  def format_types: (Array[String] list, ?bool brackets) -> String
  # @example Formatted type of an exception class
  #   o = ClassObject.new(:root, :MyError)
  #   o.superclass = P('RuntimeError')
  #   format_object_type(o) # => "Exception"
  # @example Formatted type of a method
  #   o = MethodObject.new(:root, :to_s)
  #   format_object_type(o) # => "Method"
  # @param [CodeObjects::Base] object the object to retrieve the type for
  # @return [String] the human-readable formatted {CodeObjects::Base#type #type}
  #   for the object
  def format_object_type: (YARD::CodeObjects::Base object) -> String
  # @example
  #   s = format_object_title ModuleObject.new(:root, :MyModuleName)
  #   s # => "Module: MyModuleName"
  # @param [CodeObjects::Base] object the object to retrieve a title for
  # @return [String] the page title name for a given object
  def format_object_title: (YARD::CodeObjects::Base object) -> String
  # Indents and formats source code
  #
  # @param [String] value the input source code
  # @return [String] formatted source code
  def format_source: (String value) -> String
end

# Serves static content when no other router matches a request
class YARD::Server::Commands::StaticFileCommand < ::YARD::Server::Commands::LibraryCommand
  def run: () -> untyped
  # Serves an empty favicon.
  # @raise [FinishRequest] finalizes an empty body if the path matches
  #   /favicon.ico so browsers don't complain.
  def favicon?: () -> bool
  # Attempts to route a path to a static template file.
  #
  # @raise [FinishRequest] if a file was found and served
  # @return [void]
  def static_template_file?: () -> void
  # @since 0.6.0
  private def find_file: (untyped adapter, untyped url) -> untyped
  #
  # Normalizes a request path.  Raises an exception if the path cannot be
  # normalized.
  private def normalize_path: (untyped path) -> untyped
  #
  # Loads Apache-compatible mime.types in +file+.
  private def load_mime_types: (untyped file) -> untyped
  #
  # Returns the mime type of +filename+ from the list in +mime_tab+.  If no
  # mime type was found application/octet-stream is returned.
  private def mime_type: (untyped filename, untyped mime_tab) -> untyped
  #
  # Parses an HTTP header +raw+ into a hash of header fields with an Array
  # of values.
  private def parse_header: (untyped raw) -> untyped
  #
  # Splits a header value +str+ according to HTTP specification.
  private def split_header_value: (untyped str) -> untyped
  #
  # Parses a Range header value +ranges_specifier+
  private def parse_range_header: (untyped ranges_specifier) -> untyped
  #
  # Parses q values in +value+ as used in Accept headers.
  private def parse_qvalues: (untyped value) -> untyped
  #
  # Removes quotes and escapes from +str+
  private def dequote: (untyped str) -> untyped
  #
  # Quotes and escapes quotes in +str+
  private def quote: (untyped str) -> untyped
  #
  # Parses the query component of a URI in +str+
  private def parse_query: (untyped str) -> untyped
  #
  # Parses form data in +io+ with the given +boundary+
  private def parse_form_data: (untyped io, untyped boundary) -> untyped
  # :stopdoc:
  # @since 0.6.0
  private def _make_regex: (untyped str) -> untyped
  # @since 0.6.0
  private def _make_regex!: (untyped str) -> untyped
  # @since 0.6.0
  private def _escape: (untyped str, untyped regex) -> untyped
  # @since 0.6.0
  private def _unescape: (untyped str, untyped regex) -> untyped
  # Escapes HTTP reserved and unwise characters in +str+
  # @since 0.6.0
  private def escape: (untyped str) -> untyped
  # Unescapes HTTP reserved and unwise characters in +str+
  # @since 0.6.0
  private def unescape: (untyped str) -> untyped
  # Escapes form reserved characters in +str+
  # @since 0.6.0
  private def escape_form: (untyped str) -> untyped
  # Unescapes form reserved characters in +str+
  # @since 0.6.0
  private def unescape_form: (untyped str) -> untyped
  # Escapes path +str+
  # @since 0.6.0
  private def escape_path: (untyped str) -> untyped
  # Escapes 8 bit characters in +str+
  # @since 0.6.0
  private def escape8bit: (untyped str) -> untyped
  # Defines the paths used to search for static assets. To define an
  # extra path, use {YARD::Server.register_static_path} rather than
  # modifying this constant directly. Also note that files in the
  # document root will always take precedence over these paths.
  STATIC_PATHS: untyped
end

# Include this module to get access to {#static_template_file?}
# and {favicon?} helpers.
module YARD::Server::Commands::StaticFileHelpers
  # Serves an empty favicon.
  # @raise [FinishRequest] finalizes an empty body if the path matches
  #   /favicon.ico so browsers don't complain.
  def favicon?: () -> bool

  # Attempts to route a path to a static template file.
  #
  # @raise [FinishRequest] if a file was found and served
  # @return [void]
  def static_template_file?: () -> void

  # @since 0.6.0
  private def find_file: (untyped adapter, untyped url) -> untyped

  def self.find_file: (untyped adapter, untyped url) -> untyped

  #
  # Normalizes a request path.  Raises an exception if the path cannot be
  # normalized.
  private def normalize_path: (untyped path) -> untyped

  #
  # Loads Apache-compatible mime.types in +file+.
  private def load_mime_types: (untyped file) -> untyped

  #
  # Returns the mime type of +filename+ from the list in +mime_tab+.  If no
  # mime type was found application/octet-stream is returned.
  private def mime_type: (untyped filename, untyped mime_tab) -> untyped

  #
  # Parses an HTTP header +raw+ into a hash of header fields with an Array
  # of values.
  private def parse_header: (untyped raw) -> untyped

  #
  # Splits a header value +str+ according to HTTP specification.
  private def split_header_value: (untyped str) -> untyped

  #
  # Parses a Range header value +ranges_specifier+
  private def parse_range_header: (untyped ranges_specifier) -> untyped

  #
  # Parses q values in +value+ as used in Accept headers.
  private def parse_qvalues: (untyped value) -> untyped

  #
  # Removes quotes and escapes from +str+
  private def dequote: (untyped str) -> untyped

  #
  # Quotes and escapes quotes in +str+
  private def quote: (untyped str) -> untyped

  #
  # Parses the query component of a URI in +str+
  private def parse_query: (untyped str) -> untyped

  #
  # Parses form data in +io+ with the given +boundary+
  private def parse_form_data: (untyped io, untyped boundary) -> untyped

  # :stopdoc:
  # @since 0.6.0
  private def _make_regex: (untyped str) -> untyped

  # @since 0.6.0
  private def _make_regex!: (untyped str) -> untyped

  # @since 0.6.0
  private def _escape: (untyped str, untyped regex) -> untyped

  # @since 0.6.0
  private def _unescape: (untyped str, untyped regex) -> untyped

  # Escapes HTTP reserved and unwise characters in +str+
  # @since 0.6.0
  private def escape: (untyped str) -> untyped

  # Unescapes HTTP reserved and unwise characters in +str+
  # @since 0.6.0
  private def unescape: (untyped str) -> untyped

  # Escapes form reserved characters in +str+
  # @since 0.6.0
  private def escape_form: (untyped str) -> untyped

  # Unescapes form reserved characters in +str+
  # @since 0.6.0
  private def unescape_form: (untyped str) -> untyped

  # Escapes path +str+
  # @since 0.6.0
  private def escape_path: (untyped str) -> untyped

  # Escapes 8 bit characters in +str+
  # @since 0.6.0
  private def escape8bit: (untyped str) -> untyped
end

# A module that is mixed into {Templates::Template} in order to customize
# certain template methods.
module YARD::Server::DocServerHelper
  # Modifies {Templates::Helpers::HtmlHelper#url_for} to return a URL instead
  # of a disk location.
  # @param (see Templates::Helpers::HtmlHelper#url_for)
  # @return (see Templates::Helpers::HtmlHelper#url_for)
  def url_for: (String | YARD::CodeObjects::Base obj, ?String anchor, ?bool relative) -> String

  # Modifies {Templates::Helpers::HtmlHelper#url_for_file} to return a URL instead
  # of a disk location.
  # @param (see Templates::Helpers::HtmlHelper#url_for_file)
  # @return (see Templates::Helpers::HtmlHelper#url_for_file)
  def url_for_file: (String | YARD::CodeObjects::ExtraFileObject filename, ?String anchor) -> String

  # Modifies {Templates::Helpers::HtmlHelper#url_for_list} to return a URL
  # based on the list prefix instead of a HTML filename.
  # @param (see Templates::Helpers::HtmlHelper#url_for_list)
  # @return (see Templates::Helpers::HtmlHelper#url_for_list)
  def url_for_list: (String | Symbol type) -> String

  # Returns the frames URL for the page
  # @return (see Templates::Helpers::HtmlHelper#url_for_frameset)
  def url_for_frameset: () -> String

  # Returns the main URL, first checking a readme and then linking to the index
  # @return (see Templates::Helpers::HtmlHelper#url_for_main)
  def url_for_main: () -> String

  # Returns the URL for the alphabetic index page
  # @return (see Templates::Helpers::HtmlHelper#url_for_index)
  def url_for_index: () -> String

  # @param path_components [Array<String>] components of a URL
  # @return [String] the absolute path from any mounted base URI.
  def abs_url: (*Array[String] path_components) -> String

  # @example The base path for a library 'foo'
  #   base_path('docs') # => 'docs/foo'
  # @param [String] path the path prefix for a base path URI
  # @return [String] the base URI for a library with an extra +path+ prefix
  def base_path: (String path) -> String

  # @return [Router] convenience method for accessing the router
  def router: () -> YARD::Server::Router

  # @return [String] a timestamp for a given file
  def mtime: (untyped file) -> String

  # @return [String] a URL for a file with a timestamp
  def mtime_url: (untyped file) -> String
end

# A custom {Serializers::Base serializer} which returns resource URLs instead of
# static relative paths to files on disk.
class YARD::Server::DocServerSerializer < ::YARD::Serializers::FileSystemSerializer
  def initialize: (?untyped _command) -> void
  def serialized_path: (untyped object) -> untyped
  private def urlencode: (untyped name) -> untyped
end

# Short circuits a request by raising an error. This exception is caught
# by {Commands::Base#call} to immediately end a request and return a response.
class YARD::Server::FinishRequest < ::RuntimeError
end

module YARD::Server::HTTPUtils
  #
  # Default mime types
  DefaultMimeTypes: untyped

  UNESCAPED: untyped

  UNESCAPED_FORM: untyped

  NONASCII: untyped

  ESCAPED: untyped

  UNESCAPED_PCHAR: untyped

  #
  # HTTPUtils provides utility methods for working with the HTTP protocol.
  #
  # This module is generally used internally by WEBrick
  #
  # Normalizes a request path.  Raises an exception if the path cannot be
  # normalized.
  private def normalize_path: (untyped path) -> untyped

  # Normalizes a request path.  Raises an exception if the path cannot be
  # normalized.
  # @since 0.6.0
  def self.normalize_path: (untyped path) -> untyped

  #
  # Loads Apache-compatible mime.types in +file+.
  private def load_mime_types: (untyped file) -> untyped

  # Loads Apache-compatible mime.types in +file+.
  # @since 0.6.0
  def self.load_mime_types: (untyped file) -> untyped

  #
  # Returns the mime type of +filename+ from the list in +mime_tab+.  If no
  # mime type was found application/octet-stream is returned.
  private def mime_type: (untyped filename, untyped mime_tab) -> untyped

  # Returns the mime type of +filename+ from the list in +mime_tab+.  If no
  # mime type was found application/octet-stream is returned.
  # @since 0.6.0
  def self.mime_type: (untyped filename, untyped mime_tab) -> untyped

  #
  # Parses an HTTP header +raw+ into a hash of header fields with an Array
  # of values.
  private def parse_header: (untyped raw) -> untyped

  # Parses an HTTP header +raw+ into a hash of header fields with an Array
  # of values.
  # @since 0.6.0
  def self.parse_header: (untyped raw) -> untyped

  #
  # Splits a header value +str+ according to HTTP specification.
  private def split_header_value: (untyped str) -> untyped

  # Splits a header value +str+ according to HTTP specification.
  # @since 0.6.0
  def self.split_header_value: (untyped str) -> untyped

  #
  # Parses a Range header value +ranges_specifier+
  private def parse_range_header: (untyped ranges_specifier) -> untyped

  # Parses a Range header value +ranges_specifier+
  # @since 0.6.0
  def self.parse_range_header: (untyped ranges_specifier) -> untyped

  #
  # Parses q values in +value+ as used in Accept headers.
  private def parse_qvalues: (untyped value) -> untyped

  # Parses q values in +value+ as used in Accept headers.
  # @since 0.6.0
  def self.parse_qvalues: (untyped value) -> untyped

  #
  # Removes quotes and escapes from +str+
  private def dequote: (untyped str) -> untyped

  # Removes quotes and escapes from +str+
  # @since 0.6.0
  def self.dequote: (untyped str) -> untyped

  #
  # Quotes and escapes quotes in +str+
  private def quote: (untyped str) -> untyped

  # Quotes and escapes quotes in +str+
  # @since 0.6.0
  def self.quote: (untyped str) -> untyped

  #
  # Parses the query component of a URI in +str+
  private def parse_query: (untyped str) -> untyped

  # Parses the query component of a URI in +str+
  # @since 0.6.0
  def self.parse_query: (untyped str) -> untyped

  #
  # Parses form data in +io+ with the given +boundary+
  private def parse_form_data: (untyped io, untyped boundary) -> untyped

  # Parses form data in +io+ with the given +boundary+
  # @since 0.6.0
  def self.parse_form_data: (untyped io, untyped boundary) -> untyped

  # :stopdoc:
  # @since 0.6.0
  private def _make_regex: (untyped str) -> untyped

  # :stopdoc:
  def self._make_regex: (untyped str) -> untyped

  # @since 0.6.0
  private def _make_regex!: (untyped str) -> untyped

  def self._make_regex!: (untyped str) -> untyped

  # @since 0.6.0
  private def _escape: (untyped str, untyped regex) -> untyped

  def self._escape: (untyped str, untyped regex) -> untyped

  # @since 0.6.0
  private def _unescape: (untyped str, untyped regex) -> untyped

  def self._unescape: (untyped str, untyped regex) -> untyped

  # Escapes HTTP reserved and unwise characters in +str+
  # @since 0.6.0
  private def escape: (untyped str) -> untyped

  #
  # Escapes HTTP reserved and unwise characters in +str+
  def self.escape: (untyped str) -> untyped

  # Unescapes HTTP reserved and unwise characters in +str+
  # @since 0.6.0
  private def unescape: (untyped str) -> untyped

  #
  # Unescapes HTTP reserved and unwise characters in +str+
  def self.unescape: (untyped str) -> untyped

  # Escapes form reserved characters in +str+
  # @since 0.6.0
  private def escape_form: (untyped str) -> untyped

  #
  # Escapes form reserved characters in +str+
  def self.escape_form: (untyped str) -> untyped

  # Unescapes form reserved characters in +str+
  # @since 0.6.0
  private def unescape_form: (untyped str) -> untyped

  #
  # Unescapes form reserved characters in +str+
  def self.unescape_form: (untyped str) -> untyped

  # Escapes path +str+
  # @since 0.6.0
  private def escape_path: (untyped str) -> untyped

  #
  # Escapes path +str+
  def self.escape_path: (untyped str) -> untyped

  # Escapes 8 bit characters in +str+
  # @since 0.6.0
  private def escape8bit: (untyped str) -> untyped

  #
  # Escapes 8 bit characters in +str+
  def self.escape8bit: (untyped str) -> untyped
end

#
# Stores multipart form data.  FormData objects are created when
# WEBrick::HTTPUtils.parse_form_data is called.
class YARD::Server::HTTPUtils::FormData < ::String
  #
  # The name of the form data part
  attr_accessor name: untyped
  #
  # The filename of the form data part
  attr_accessor filename: untyped
  # :nodoc:
  attr_accessor next_data: untyped
  #
  # Creates a new FormData object.
  #
  # +args+ is an Array of form data entries.  One FormData will be created
  # for each entry.
  #
  # This is called by WEBrick::HTTPUtils.parse_form_data for you
  def initialize: (*untyped args) -> void
  #
  # Retrieves the header at the first entry in +key+
  def []: (*untyped key) -> untyped
  #
  # Adds +str+ to this FormData which may be the body, a header or a
  # header entry.
  #
  # This is called by WEBrick::HTTPUtils.parse_form_data for you
  def <<: (untyped str) -> untyped
  #
  # Adds +data+ at the end of the chain of entries
  #
  # This is called by WEBrick::HTTPUtils.parse_form_data for you.
  def append_data: (untyped data) -> untyped
  #
  # Yields each entry in this FormData
  def each_data: () -> untyped
  #
  # Returns all the FormData as an Array
  def list: () -> untyped
  # Returns all the FormData as an Array
  # @since 0.6.0
  #
  # A FormData will behave like an Array
  def to_ary: () -> untyped
  #
  # This FormData's body
  def to_s: () -> untyped
  # :nodoc:
  EmptyRawHeader: untyped
  # :nodoc:
  EmptyHeader: untyped
end

# This exception is raised when {LibraryVersion#prepare!} fails, or discovers
# that the library is not "prepared" to be served by
class YARD::Server::LibraryNotPreparedError < ::RuntimeError
end

# A library version encapsulates a library's documentation at a specific version.
# Although the version is optional, this allows for creating multiple documentation
# points for a specific library, each representing a unique version. The term
# "library" used in other parts of the YARD::Server documentation refers to
# objects of this class unless otherwise noted.
#
# A library points to a location where a {#yardoc_file} is located so that
# its documentation may be loaded and served. Optionally, a {#source_path} is
# given to point to a location where any extra files (and {YARD::CLI::Yardoc .yardopts})
# should be loaded from. Both of these methods may not be known immediately,
# since the yardoc file may not be built until later. Resolving the yardoc
# file and source path are dependent on the specific library "source type" used.
# Source types (known as "library source") are discussed in detail below.
#
# == Using with Adapters
# A list of libraries need to be passed into adapters upon creation. In
# most cases, you will never do this manually, but if you use a {RackMiddleware},
# you will need to pass in this list yourself. To build this list of libraries,
# you should create a hash of library names mapped to an *Array* of LibraryVersion
# objects. For example:
#
#   {'mylib' => [LibraryVersion.new('mylib', '1.0', ...),
#                LibraryVersion.new('mylib', '2.0', ...)]}
#
# Note that you can also use {Adapter#add_library} for convenience.
#
# The "array" part is required, even for just one library version.
#
# == Library Sources
# The {#source} method represents the library source type, ie. where the
# library "comes from". It might come from "disk", or it might come from a
# "gem" (technically the disk, but a separate type nonetheless). In these
# two cases, the yardoc file sits somewhere on your filesystem, though
# it may also be built dynamically if it does not yet exist. This behaviour
# is controlled through the {#prepare!} method, which prepares the yardoc file
# given a specific library source. We will see how this works in detail in
# the following section.
#
# == Implementing a Custom Library Source
# YARD can be extended to support custom library sources in order to
# build or retrieve a yardoc file at runtime from many different locations.
#
# To implement this behaviour, 3 methods can be added to the +LibraryVersion+
# class, +#load_yardoc_from_SOURCE+, +#yardoc_file_for_SOURCE+, and
# +#source_path_for_SOURCE+. In all cases, "SOURCE" represents the source
# type used in {#source} when creating the library object. The
# +#yardoc_file_for_SOURCE+ and +#source_path_for_SOURCE+ methods are called upon
# creation and should return the location where the source code for the library
# lives. The load method is called from {#prepare!} if there is no yardoc file
# and should set {#yardoc_file}. Below is a full example for
# implementing a custom library source, +:http+, which reads packaged .yardoc
# databases from zipped archives off of an HTTP server.
#
# Note that only +#load_yardoc_from_SOURCE+ is required. The other two
# methods are optional and can be set manually (via {#source_path=} and
# {#yardoc_file=}) on the object at any time.
#
# @example Implementing a Custom Library Source
#   # Adds the source type "http" for .yardoc files zipped on HTTP servers
#   class LibraryVersion
#     def load_yardoc_from_http
#       Thread.new do
#         # zip/unzip method implementations are not shown
#         download_zip_file("http://mysite.com/yardocs/#{self}.zip")
#         unzip_file_to("/path/to/yardocs/#{self}")
#       end
#
#       # tell the server it's not ready yet (but it might be next time)
#       raise LibraryNotPreparedError
#     end
#
#     def yardoc_file_for_http
#       "/path/to/yardocs/#{self}/.yardoc"
#     end
#
#     def source_path_for_http
#       File.dirname(yardoc_file)
#     end
#   end
#
#   # Creating a library of this source type:
#   LibraryVersion.new('name', '1.0', nil, :http)
#
class YARD::Server::LibraryVersion
  # @return [String] the name of the library
  attr_accessor name: String
  # @return [String] the version of the specific library
  attr_accessor version: String
  # @return [String] the location of the yardoc file used to load the object
  #   information from.
  # @return [nil] if no yardoc file exists yet. In this case, {#prepare!} will
  #   be called on this library to build the yardoc file.
  # @note To implement a custom yardoc file getter, implement
  attr_accessor yardoc_file: String?
  # @return [Symbol] the source type representing where the yardoc should be
  #   loaded from. Defaults are +:disk+ and +:gem+, though custom sources
  #   may be implemented. This value is used to inform {#prepare!} about how
  #   to load the necessary data in order to display documentation for an object.
  # @see LibraryVersion LibraryVersion documentation for "Implementing a Custom Library Source"
  attr_accessor source: Symbol
  # @return [String] the location of the source code for a library. This
  #   value is filled by calling +#source_path_for_SOURCE+ on this class.
  # @return [nil] if there is no source code
  # @see LibraryVersion LibraryVersion documentation for "Implementing a Custom Library Source"
  attr_accessor source_path: String?
  # @param [String] name the name of the library
  # @param [String] version the specific (usually, but not always, numeric) library
  #   version
  # @param [String] yardoc the location of the yardoc file, or nil if it is
  #   generated later
  # @param [Symbol] source the location of the files used to build the yardoc.
  #   Builtin source types are +:disk+ or +:gem+.
  def initialize: (String name, ?String version, ?String yardoc, ?Symbol source) -> void
  # @param [Boolean] url_format if true, returns the string in a URI-compatible
  #   format (for appending to a URL). Otherwise, it is given in a more human
  #   readable format.
  # @return [String] the string representation of the library.
  def to_s: (?bool url_format) -> String
  # @return [Fixnum] used for Hash mapping.
  def hash: () -> Integer
  # @return [Boolean] whether another LibraryVersion is equal to this one
  def eql?: (untyped other) -> bool
  # @return [Boolean] whether another LibraryVersion is equal to this one
  # @since 0.6.0
  #
  def ==: (untyped other) -> bool
  # @return [Boolean] whether another LibraryVersion is equal to this one
  # @since 0.6.0
  #
  def equal?: (untyped other) -> bool
  # @return [Boolean] whether the library has been completely processed
  #   and is ready to be served
  def ready?: () -> bool
  # @note You should not directly override this method. Instead, implement
  #   +load_yardoc_from_SOURCENAME+ when implementing loading for a specific
  #   source type. See the {LibraryVersion} documentation for "Implementing
  #   a Custom Library Source"
  #
  # Prepares a library to be displayed by the server. This callback is
  # performed before each request on a library to ensure that it is loaded
  # and ready to be viewed. If any steps need to be performed prior to loading,
  # they are performed through this method (though they should be implemented
  # through the +load_yardoc_from_SOURCE+ method).
  #
  # @raise [LibraryNotPreparedError] if the library is not ready to be
  #   displayed. Usually when raising this error, you would simultaneously
  #   begin preparing the library for subsequent requests, although this
  #   is not necessary.
  def prepare!: () -> untyped
  # @return [Gem::Specification] a gemspec object for a given library. Used
  #   for :gem source types.
  # @return [nil] if there is no installed gem for the library
  def gemspec: () -> Gem::Specification?
  # Called when a library of source type "disk" is to be prepared. In this
  # case, the {#yardoc_file} should already be set, but the library may not
  # be prepared. Run preparation if not done.
  #
  # @raise [LibraryNotPreparedError] if the yardoc file has not been
  #   prepared.
  def load_yardoc_from_disk: () -> untyped
  # Called when a library of source type "gem" is to be prepared. In this
  # case, the {#yardoc_file} needs to point to the correct location for
  # the installed gem. The yardoc file is built if it has not been done.
  #
  # @raise [LibraryNotPreparedError] if the gem does not have an existing
  #   yardoc file.
  def load_yardoc_from_gem: () -> untyped
  # @return [String] the source path for a disk source
  def source_path_for_disk: () -> String
  # @return [String] the source path for a gem source
  def source_path_for_gem: () -> String
  # @return [String] the yardoc file for a gem source
  def yardoc_file_for_gem: () -> String
  private def load_source_path: () -> untyped
  private def load_yardoc_file: () -> untyped
  private def serializer: () -> untyped
  @@chdir_mutex: untyped
end

# Raises an error if a resource is not found. This exception is caught by
# {Commands::Base#call} to immediately end a request and return a 404 response
# code. If a message is provided, the body is set to the exception message.
class YARD::Server::NotFoundError < ::RuntimeError
end

# A server adapter to respond to requests using the Rack server infrastructure.
class YARD::Server::RackAdapter < ::YARD::Server::Adapter
  # Responds to Rack requests and builds a response with the {Router}.
  # @return [Array(Numeric,Hash,Array)] the Rack-style response
  def call: (untyped env) -> [ Numeric, Hash[untyped, untyped], Array[untyped] ]
  # Starts the Rack server. This method will pass control to the server and
  # block.
  # @return [void]
  def start: () -> void
  private def print_start_message: (untyped server) -> untyped
  #
  # Normalizes a request path.  Raises an exception if the path cannot be
  # normalized.
  private def normalize_path: (untyped path) -> untyped
  #
  # Loads Apache-compatible mime.types in +file+.
  private def load_mime_types: (untyped file) -> untyped
  #
  # Returns the mime type of +filename+ from the list in +mime_tab+.  If no
  # mime type was found application/octet-stream is returned.
  private def mime_type: (untyped filename, untyped mime_tab) -> untyped
  #
  # Parses an HTTP header +raw+ into a hash of header fields with an Array
  # of values.
  private def parse_header: (untyped raw) -> untyped
  #
  # Splits a header value +str+ according to HTTP specification.
  private def split_header_value: (untyped str) -> untyped
  #
  # Parses a Range header value +ranges_specifier+
  private def parse_range_header: (untyped ranges_specifier) -> untyped
  #
  # Parses q values in +value+ as used in Accept headers.
  private def parse_qvalues: (untyped value) -> untyped
  #
  # Removes quotes and escapes from +str+
  private def dequote: (untyped str) -> untyped
  #
  # Quotes and escapes quotes in +str+
  private def quote: (untyped str) -> untyped
  #
  # Parses the query component of a URI in +str+
  private def parse_query: (untyped str) -> untyped
  #
  # Parses form data in +io+ with the given +boundary+
  private def parse_form_data: (untyped io, untyped boundary) -> untyped
  # :stopdoc:
  # @since 0.6.0
  private def _make_regex: (untyped str) -> untyped
  # @since 0.6.0
  private def _make_regex!: (untyped str) -> untyped
  # @since 0.6.0
  private def _escape: (untyped str, untyped regex) -> untyped
  # @since 0.6.0
  private def _unescape: (untyped str, untyped regex) -> untyped
  # Escapes HTTP reserved and unwise characters in +str+
  # @since 0.6.0
  private def escape: (untyped str) -> untyped
  # Unescapes HTTP reserved and unwise characters in +str+
  # @since 0.6.0
  private def unescape: (untyped str) -> untyped
  # Escapes form reserved characters in +str+
  # @since 0.6.0
  private def escape_form: (untyped str) -> untyped
  # Unescapes form reserved characters in +str+
  # @since 0.6.0
  private def unescape_form: (untyped str) -> untyped
  # Escapes path +str+
  # @since 0.6.0
  private def escape_path: (untyped str) -> untyped
  # Escapes 8 bit characters in +str+
  # @since 0.6.0
  private def escape8bit: (untyped str) -> untyped
end

# This class wraps the {RackAdapter} into a Rack-compatible middleware.
# See {#initialize} for a list of options to pass via Rack's +#use+ method.
#
# @note You must pass a +:libraries+ option to the RackMiddleware via +#use+. To
#   read about how to return a list of libraries, see {LibraryVersion} or look
#   at the example below.
# @example Using the RackMiddleware in a Rack application
#   libraries = {:mylib => [YARD::Server::LibraryVersion.new('mylib', nil, '/path/to/.yardoc')]}
#   use YARD::Server::RackMiddleware, :libraries => libraries
#
class YARD::Server::RackMiddleware
  # Creates a new Rack-based middleware for serving YARD documentation.
  #
  # @param app the next Rack middleware in the stack
  # @option opts [Hash{String=>Array<LibraryVersion>}] :libraries ({})
  #   the map of libraries to serve through the adapter. This option is *required*.
  # @option opts [Hash] :options ({}) a list of options to pass to the adapter.
  #   See {Adapter#options} for a list.
  # @option opts [Hash] :server_options ({}) a list of options to pass to the server.
  #   See {Adapter#server_options} for a list.
  def initialize: (untyped app, ?Hash[untyped, untyped] opts) -> void
  def call: (untyped env) -> untyped
end

# A router class implements the logic used to recognize a request for a specific
# URL and run specific {Commands::Base commands}.
#
# == Subclassing Notes
# To create a custom router, subclass this class and pass it into the adapter
# options through {Adapter#initialize} or by directly modifying {Adapter#router}.
#
# The most general customization is to change the URL prefixes recognized by
# routing, which can be done by overriding {#docs_prefix}, {#list_prefix},
# {#static_prefix}, and {#search_prefix}.
#
# == Implementing Custom Caching
# By default, the Router class performs static disk-based caching on all
# requests through the +#check_static_cache+. To override this behaviour,
# or create your own caching mechanism, mixin your own custom module with
# this method implemented as per {StaticCaching#check_static_cache}.
#
# @example Creating a subclassed router
#   # Adds 'my' to all routing prefixes
#   class MyRouter < YARD::Server::Router
#     def docs_prefix; 'mydocs' end
#     def list_prefix; 'mylist' end
#     def static_prefix; 'mystatic' end
#     def search_prefix; 'mysearch' end
#   end
#
#   # Using it:
#   WebrickAdapter.new(libraries, :router => MyRouter).start
class YARD::Server::Router
  # @return [Adapter Dependent] the request data coming in with the routing
  attr_accessor request: untyped
  # @return [Adapter] the adapter used by the router
  attr_accessor adapter: YARD::Server::Adapter
  # Creates a new router for a specific adapter
  #
  # @param [Adapter] adapter the adapter to route requests to
  def initialize: (YARD::Server::Adapter adapter) -> void
  # Perform routing on a specific request, serving the request as a static
  # file through {Commands::RootRequestCommand} if no route is found.
  #
  # @param [Adapter Dependent] request the request object
  # @return [Array(Numeric,Hash,Array)] the Rack-style server response data
  def call: (untyped request) -> [ Numeric, Hash[untyped, untyped], Array[untyped] ]
  # @return [String] the URI prefix for all object documentation requests
  def docs_prefix: () -> String
  # @return [String] the URI prefix for all class/method/file list requests
  def list_prefix: () -> String
  # @return [String] the URI prefix for all search requests
  def search_prefix: () -> String
  # @return [String] the URI prefix for all static assets (templates)
  def static_prefix: () -> String
  # @return [Array(LibraryVersion, Array<String>)] the library followed
  #   by the rest of the path components in the request path. LibraryVersion
  #   will be nil if no matching library was found.
  def parse_library_from_path: (untyped paths) -> [ YARD::Server::LibraryVersion, Array[String] ]
  # Performs routing algorithm to find which prefix is called, first
  # parsing out library name/version information.
  #
  # @return [Array(Numeric,Hash,Array<String>)] the Rack-style response
  # @return [nil] if no route is matched
  def route: (?untyped path) -> [ Numeric, Hash[untyped, untyped], Array[String] ]?
  # Routes requests from {#docs_prefix} and calls the appropriate command
  # @param [LibraryVersion] library the library to route for
  # @param [Array<String>] paths path components (split by '/')
  # @return (see #route)
  def route_docs: (YARD::Server::LibraryVersion library, Array[String] paths) -> [ Numeric, Hash[untyped, untyped], Array[String] ]?
  # Routes for the index of a library / multiple libraries
  # @return (see #route)
  def route_index: () -> [ Numeric, Hash[untyped, untyped], Array[String] ]?
  # Routes requests from {#list_prefix} and calls the appropriate command
  # @param (see #route_docs)
  # @return (see #route_docs)
  def route_list: (YARD::Server::LibraryVersion library, Array[String] paths) -> [ Numeric, Hash[untyped, untyped], Array[String] ]?
  # Routes requests from {#search_prefix} and calls the appropriate command
  # @param (see #route_docs)
  # @return (see #route_docs)
  def route_search: (YARD::Server::LibraryVersion library, Array[String] paths) -> [ Numeric, Hash[untyped, untyped], Array[String] ]?
  def route_static: (untyped library, untyped paths) -> untyped
  # Adds extra :library/:path option keys to the adapter options.
  # Use this method when passing options to a command.
  #
  # @param (see #route_docs)
  # @return [Hash] finalized options
  def final_options: (YARD::Server::LibraryVersion library, Array[String] paths) -> Hash[untyped, untyped]
  # Called by a router to return the cached object. By default, this
  # method performs disk-based caching. To perform other forms of caching,
  # implement your own +#check_static_cache+ method and mix the module into
  # the Router class.
  #
  # Note that caching does not occur here. This method simply checks for
  # the existence of cached data. To actually cache a response, see
  # {Commands::Base#cache}.
  #
  # @example Implementing In-Memory Cache Checking
  #   module MemoryCaching
  #     def check_static_cache
  #       # $memory_cache is filled by {Commands::Base#cache}
  #       cached_data = $memory_cache[request.path]
  #       if cached_data
  #         [200, {'Content-Type' => 'text/html'}, [cached_data]]
  #       else
  #         nil
  #       end
  #     end
  #   end
  #
  #   class YARD::Server::Router; include MemoryCaching; end
  # @return [Array(Numeric,Hash,Array)] the Rack-style response
  # @return [nil] if no cache is available and routing should continue
  # @see Commands::Base#cache
  def check_static_cache: () -> [ Numeric, Hash[untyped, untyped], Array[untyped] ]?
end

# Implements static caching for requests.
#
# @see Router Router documentation for "Caching"
module YARD::Server::StaticCaching
  # Called by a router to return the cached object. By default, this
  # method performs disk-based caching. To perform other forms of caching,
  # implement your own +#check_static_cache+ method and mix the module into
  # the Router class.
  #
  # Note that caching does not occur here. This method simply checks for
  # the existence of cached data. To actually cache a response, see
  # {Commands::Base#cache}.
  #
  # @example Implementing In-Memory Cache Checking
  #   module MemoryCaching
  #     def check_static_cache
  #       # $memory_cache is filled by {Commands::Base#cache}
  #       cached_data = $memory_cache[request.path]
  #       if cached_data
  #         [200, {'Content-Type' => 'text/html'}, [cached_data]]
  #       else
  #         nil
  #       end
  #     end
  #   end
  #
  #   class YARD::Server::Router; include MemoryCaching; end
  # @return [Array(Numeric,Hash,Array)] the Rack-style response
  # @return [nil] if no cache is available and routing should continue
  # @see Commands::Base#cache
  def check_static_cache: () -> [ Numeric, Hash[untyped, untyped], Array[untyped] ]?
end

# The main adapter to initialize a WEBrick server.
class YARD::Server::WebrickAdapter < ::YARD::Server::Adapter
  # Initializes a WEBrick server. If {Adapter#server_options} contains a
  # +:daemonize+ key set to true, the server will be daemonized.
  def start: () -> untyped
end

# The main WEBrick servlet implementation, accepting only GET requests.
class YARD::Server::WebrickServlet < ::WEBrick::HTTPServlet::AbstractServlet
  attr_accessor adapter: untyped
  def initialize: (untyped server, untyped adapter) -> void
  # @private
  def do_GET: (untyped request, untyped response) -> untyped
end
