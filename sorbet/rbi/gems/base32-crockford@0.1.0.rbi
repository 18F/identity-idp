# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `base32-crockford` gem.
# Please instead update this file by running `bin/tapioca gem base32-crockford`.


# source://base32-crockford//lib/base32/crockford.rb#9
module Base32; end

# encode a value with the encoding defined by _Douglas_ _Crockford_ in
# <http://www.crockford.com/wrmg/base32.html>
#
# this is *not* the same as the Base32 encoding defined in RFC 4648
#
#
# The Base32 symbol set is a superset of the Base16 symbol set.
#
# We chose a symbol set of 10 digits and 22 letters. We exclude 4 of the 26
# letters: I L O U.
#
# Excluded Letters
#
# I:: Can be confused with 1
# L:: Can be confused with 1
# O:: Can be confused with 0
# U:: Accidental obscenity
#
# When decoding, upper and lower case letters are accepted, and i and l will
# be treated as 1 and o will be treated as 0. When encoding, only upper case
# letters are used.
#
# If the bit-length of the number to be encoded is not a multiple of 5 bits,
# then zero-extend the number to make its bit-length a multiple of 5.
#
# Hyphens (-) can be inserted into symbol strings. This can partition a
# string into manageable pieces, improving readability by helping to prevent
# confusion. Hyphens are ignored during decoding. An application may look for
# hyphens to assure symbol string correctness.
#
# source://base32-crockford//lib/base32/crockford.rb#43
class Base32::Crockford
  class << self
    # decode a string to an integer using Douglas Crockfords Base32 Encoding
    #
    # the string is converted to uppercase and hyphens are stripped before
    # decoding
    #
    #   I,i,l,L decodes to 1
    #   O,o decodes to 0
    #
    #   Base32::Crockford.decode("16J") # => 1234
    #   Base32::Crockford.decode("OI") # => 1
    #   Base32::Crockford.decode("3G923-0VQVS") # => 123456789012345
    #
    # returns +nil+ if the string contains invalid characters and can't be
    # decoded
    #
    # source://base32-crockford//lib/base32/crockford.rb#98
    def decode(string); end

    # same as decode, but raises ArgumentError when the string can't be decoded
    #
    # source://base32-crockford//lib/base32/crockford.rb#106
    def decode!(string); end

    # encodes an integer into a string
    #
    # when +split+ is given a hyphen is inserted every <n> characters to improve
    # readability
    #
    # when +length+ is given, the resulting string is zero-padded to be exactly
    # this number of characters long (hyphens are ignored)
    #
    #   Base32::Crockford.encode(1234) # => "16J"
    #   Base32::Crockford.encode(123456789012345, :split=>5) # => "3G923-0VQVS"
    #
    # @raise [ArgumentError]
    #
    # source://base32-crockford//lib/base32/crockford.rb#64
    def encode(number, opts = T.unsafe(nil)); end

    # return the canonical encoding of a string. converts it to uppercase
    # and removes hyphens
    #
    # replaces invalid characters with a question mark ('?')
    #
    # source://base32-crockford//lib/base32/crockford.rb#115
    def normalize(string); end

    # returns false iff the string contains invalid characters and can't be
    # decoded
    #
    # @return [Boolean]
    #
    # source://base32-crockford//lib/base32/crockford.rb#124
    def valid?(string); end

    private

    # source://base32-crockford//lib/base32/crockford.rb#129
    def clean(string); end
  end
end

# source://base32-crockford//lib/base32/crockford.rb#49
Base32::Crockford::DECODE_MAP = T.let(T.unsafe(nil), Hash)

# source://base32-crockford//lib/base32/crockford.rb#46
Base32::Crockford::ENCODE_CHARS = T.let(T.unsafe(nil), Array)

# source://base32-crockford//lib/base32/crockford.rb#44
Base32::Crockford::VERSION = T.let(T.unsafe(nil), String)
